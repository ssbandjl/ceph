diff --git a/src/msg/CMakeLists.txt b/src/msg/CMakeLists.txt
index fada39b457f..e8cc3fdabdf 100644
--- a/src/msg/CMakeLists.txt
+++ b/src/msg/CMakeLists.txt
@@ -2,9 +2,9 @@ set(msg_srcs
   DispatchQueue.cc
   Message.cc
   Messenger.cc
-  QueueStrategy.cc
   Connection.cc
-  msg_types.cc)
+  msg_types.cc
+  compressor_registry.cc)
 
 list(APPEND msg_srcs
   async/AsyncConnection.cc
@@ -17,6 +17,7 @@ list(APPEND msg_srcs
   async/PosixStack.cc
   async/Stack.cc
   async/crypto_onwire.cc
+  async/compression_onwire.cc
   async/frames_v2.cc
   async/net_handler.cc)
 
@@ -28,6 +29,11 @@ elseif(FREEBSD OR APPLE)
     async/EventKqueue.cc)
 endif(LINUX)
 
+if(WIN32)
+  list(APPEND msg_srcs
+    async/EventPoll.cc)
+endif(WIN32)
+
 if(HAVE_RDMA)
   list(APPEND msg_srcs
     async/rdma/Infiniband.cc
@@ -39,6 +45,8 @@ if(HAVE_RDMA)
 endif()
 
 add_library(common-msg-objs OBJECT ${msg_srcs})
+target_compile_definitions(common-msg-objs PRIVATE
+  $<TARGET_PROPERTY:fmt::fmt,INTERFACE_COMPILE_DEFINITIONS>)
 target_include_directories(common-msg-objs PRIVATE ${OPENSSL_INCLUDE_DIR})
 
 if(WITH_DPDK)
diff --git a/src/msg/Connection.cc b/src/msg/Connection.cc
index 21f147b8034..9183871b594 100644
--- a/src/msg/Connection.cc
+++ b/src/msg/Connection.cc
@@ -7,8 +7,17 @@
 
 bool Connection::is_blackhole() const {
   auto& conf = msgr->cct->_conf;
-  return ((conf->ms_blackhole_mon && peer_type == CEPH_ENTITY_TYPE_MON) ||
-      (conf->ms_blackhole_osd && peer_type == CEPH_ENTITY_TYPE_OSD) ||
-      (conf->ms_blackhole_mds && peer_type == CEPH_ENTITY_TYPE_MDS) ||
-      (conf->ms_blackhole_client && peer_type == CEPH_ENTITY_TYPE_CLIENT));
+
+  switch (peer_type) {
+  case CEPH_ENTITY_TYPE_MON:
+    return conf->ms_blackhole_mon;
+  case CEPH_ENTITY_TYPE_OSD:
+    return conf->ms_blackhole_osd;
+  case CEPH_ENTITY_TYPE_MDS:
+    return conf->ms_blackhole_mds;
+  case CEPH_ENTITY_TYPE_CLIENT:
+    return conf->ms_blackhole_client;
+  default:
+    return false;
+  }
 }
diff --git a/src/msg/Connection.h b/src/msg/Connection.h
index 1532ce04919..801d3fa200f 100644
--- a/src/msg/Connection.h
+++ b/src/msg/Connection.h
@@ -69,8 +69,6 @@ public:
   Interceptor *interceptor;
 #endif
 
-  friend class PipeConnection;
-
 public:
   void set_priv(const RefCountedPtr& o) {
     std::lock_guard l{lock};
diff --git a/src/msg/DispatchQueue.cc b/src/msg/DispatchQueue.cc
index 5a081591a59..b8ed6f7efe8 100644
--- a/src/msg/DispatchQueue.cc
+++ b/src/msg/DispatchQueue.cc
@@ -20,6 +20,8 @@
 #define dout_subsys ceph_subsys_ms
 #include "common/debug.h"
 
+using ceph::cref_t;
+using ceph::ref_t;
 
 /*******************
  * DispatchQueue
@@ -213,11 +215,9 @@ void DispatchQueue::entry()
 
 void DispatchQueue::discard_queue(uint64_t id) {
   std::lock_guard l{lock};
-  list<QueueItem> removed;
+  std::list<QueueItem> removed;
   mqueue.remove_by_class(id, &removed);
-  for (list<QueueItem>::iterator i = removed.begin();
-       i != removed.end();
-       ++i) {
+  for (auto i = removed.begin(); i != removed.end(); ++i) {
     ceph_assert(!(i->is_code())); // We don't discard id 0, ever!
     const ref_t<Message>& m = i->get_message();
     remove_arrival(m);
diff --git a/src/msg/DispatchQueue.h b/src/msg/DispatchQueue.h
index 243de2cba02..de0cb7d1a08 100644
--- a/src/msg/DispatchQueue.h
+++ b/src/msg/DispatchQueue.h
@@ -41,9 +41,9 @@ class DispatchQueue {
   class QueueItem {
     int type;
     ConnectionRef con;
-    ref_t<Message> m;
+    ceph::ref_t<Message> m;
   public:
-    explicit QueueItem(const ref_t<Message>& m) : type(-1), con(0), m(m) {}
+    explicit QueueItem(const ceph::ref_t<Message>& m) : type(-1), con(0), m(m) {}
     QueueItem(int type, Connection *con) : type(type), con(con), m(0) {}
     bool is_code() const {
       return type != -1;
@@ -52,7 +52,7 @@ class DispatchQueue {
       ceph_assert(is_code());
       return type;
     }
-    const ref_t<Message>& get_message() {
+    const ceph::ref_t<Message>& get_message() {
       ceph_assert(!is_code());
       return m;
     }
@@ -61,7 +61,7 @@ class DispatchQueue {
       return con.get();
     }
   };
-    
+
   CephContext *cct;
   Messenger *msgr;
   mutable ceph::mutex lock;
@@ -69,17 +69,17 @@ class DispatchQueue {
 
   PrioritizedQueue<QueueItem, uint64_t> mqueue;
 
-  std::set<pair<double, ref_t<Message>>> marrival;
-  map<ref_t<Message>, decltype(marrival)::iterator> marrival_map;
-  void add_arrival(const ref_t<Message>& m) {
+  std::set<std::pair<double, ceph::ref_t<Message>>> marrival;
+  std::map<ceph::ref_t<Message>, decltype(marrival)::iterator> marrival_map;
+  void add_arrival(const ceph::ref_t<Message>& m) {
     marrival_map.insert(
       make_pair(
 	m,
-	marrival.insert(make_pair(m->get_recv_stamp(), m)).first
+	marrival.insert(std::make_pair(m->get_recv_stamp(), m)).first
 	)
       );
   }
-  void remove_arrival(const ref_t<Message>& m) {
+  void remove_arrival(const ceph::ref_t<Message>& m) {
     auto it = marrival_map.find(m);
     ceph_assert(it != marrival_map.end());
     marrival.erase(it->second);
@@ -87,7 +87,7 @@ class DispatchQueue {
   }
 
   std::atomic<uint64_t> next_id;
-    
+
   enum { D_CONNECT = 1, D_ACCEPT, D_BAD_REMOTE_RESET, D_BAD_RESET, D_CONN_REFUSED, D_NUM_CODES };
 
   /**
@@ -106,7 +106,7 @@ class DispatchQueue {
   ceph::mutex local_delivery_lock;
   ceph::condition_variable local_delivery_cond;
   bool stop_local_delivery;
-  std::queue<pair<ref_t<Message>, int>> local_messages;
+  std::queue<std::pair<ceph::ref_t<Message>, int>> local_messages;
   class LocalDeliveryThread : public Thread {
     DispatchQueue *dq;
   public:
@@ -117,8 +117,8 @@ class DispatchQueue {
     }
   } local_delivery_thread;
 
-  uint64_t pre_dispatch(const ref_t<Message>& m);
-  void post_dispatch(const ref_t<Message>& m, uint64_t msize);
+  uint64_t pre_dispatch(const ceph::ref_t<Message>& m);
+  void post_dispatch(const ceph::ref_t<Message>& m, uint64_t msize);
 
  public:
 
@@ -126,9 +126,9 @@ class DispatchQueue {
   Throttle dispatch_throttler;
 
   bool stop;
-  void local_delivery(const ref_t<Message>& m, int priority);
+  void local_delivery(const ceph::ref_t<Message>& m, int priority);
   void local_delivery(Message* m, int priority) {
-    return local_delivery(ref_t<Message>(m, false), priority); /* consume ref */
+    return local_delivery(ceph::ref_t<Message>(m, false), priority); /* consume ref */
   }
   void run_local_delivery();
 
@@ -197,15 +197,15 @@ class DispatchQueue {
     cond.notify_all();
   }
 
-  bool can_fast_dispatch(const cref_t<Message> &m) const;
-  void fast_dispatch(const ref_t<Message>& m);
+  bool can_fast_dispatch(const ceph::cref_t<Message> &m) const;
+  void fast_dispatch(const ceph::ref_t<Message>& m);
   void fast_dispatch(Message* m) {
-    return fast_dispatch(ref_t<Message>(m, false)); /* consume ref */
+    return fast_dispatch(ceph::ref_t<Message>(m, false)); /* consume ref */
   }
-  void fast_preprocess(const ref_t<Message>& m);
-  void enqueue(const ref_t<Message>& m, int priority, uint64_t id);
+  void fast_preprocess(const ceph::ref_t<Message>& m);
+  void enqueue(const ceph::ref_t<Message>& m, int priority, uint64_t id);
   void enqueue(Message* m, int priority, uint64_t id) {
-    return enqueue(ref_t<Message>(m, false), priority, id); /* consume ref */
+    return enqueue(ceph::ref_t<Message>(m, false), priority, id); /* consume ref */
   }
   void discard_queue(uint64_t id);
   void discard_local();
@@ -218,7 +218,7 @@ class DispatchQueue {
   void shutdown();
   bool is_started() const {return dispatch_thread.is_started();}
 
-  DispatchQueue(CephContext *cct, Messenger *msgr, string &name)
+  DispatchQueue(CephContext *cct, Messenger *msgr, std::string &name)
     : cct(cct), msgr(msgr),
       lock(ceph::make_mutex("Messenger::DispatchQueue::lock" + name)),
       mqueue(cct->_conf->ms_pq_max_tokens_per_priority,
@@ -228,7 +228,7 @@ class DispatchQueue {
       local_delivery_lock(ceph::make_mutex("Messenger::DispatchQueue::local_delivery_lock" + name)),
       stop_local_delivery(false),
       local_delivery_thread(this),
-      dispatch_throttler(cct, string("msgr_dispatch_throttler-") + name,
+      dispatch_throttler(cct, std::string("msgr_dispatch_throttler-") + name,
                          cct->_conf->ms_dispatch_throttle_bytes),
       stop(false)
     {}
diff --git a/src/msg/DispatchStrategy.h b/src/msg/DispatchStrategy.h
deleted file mode 100644
index 4c9726ed635..00000000000
--- a/src/msg/DispatchStrategy.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
-// vim: ts=8 sw=2 smarttab
-/*
- * Ceph - scalable distributed file system
- *
- * Copyright (C) 2014 CohortFS, LLC
- *
- * This is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License version 2.1, as published by the Free Software
- * Foundation.  See file COPYING.
- *
- */
-
-#ifndef DISPATCH_STRATEGY_H
-#define DISPATCH_STRATEGY_H
-
-#include "msg/Message.h"
-
-class Messenger;
-
-class DispatchStrategy
-{
-protected:
-  Messenger *msgr = nullptr;
-public:
-  DispatchStrategy() {}
-  Messenger *get_messenger() { return msgr; }
-  void set_messenger(Messenger *_msgr) { msgr = _msgr; }
-  virtual void ds_dispatch(Message *m) = 0;
-  virtual void shutdown() = 0;
-  virtual void start() = 0;
-  virtual void wait() = 0;
-  virtual ~DispatchStrategy() {}
-};
-
-#endif /* DISPATCH_STRATEGY_H */
diff --git a/src/msg/FastStrategy.h b/src/msg/FastStrategy.h
deleted file mode 100644
index 001ff40045f..00000000000
--- a/src/msg/FastStrategy.h
+++ /dev/null
@@ -1,35 +0,0 @@
-// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
-// vim: ts=8 sw=2 smarttab
-/*
- * Ceph - scalable distributed file system
- *
- * Copyright (C) 2014 CohortFS, LLC
- *
- * This is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License version 2.1, as published by the Free Software
- * Foundation.  See file COPYING.
- *
- */
-
-
-#ifndef FAST_STRATEGY_H
-#define FAST_STRATEGY_H
-#include "DispatchStrategy.h"
-
-class FastStrategy : public DispatchStrategy {
-public:
-  FastStrategy() {}
-  void ds_dispatch(Message *m) override {
-    msgr->ms_fast_preprocess(m);
-    if (msgr->ms_can_fast_dispatch(m))
-      msgr->ms_fast_dispatch(m);
-    else
-      msgr->ms_deliver_dispatch(m);
-  }
-  void shutdown() override {}
-  void start() override {}
-  void wait() override {}
-  virtual ~FastStrategy() {}
-};
-#endif /* FAST_STRATEGY_H */
diff --git a/src/msg/Message.cc b/src/msg/Message.cc
index c57bc3bc1bd..e10981794b4 100644
--- a/src/msg/Message.cc
+++ b/src/msg/Message.cc
@@ -36,11 +36,13 @@
 #include "messages/MMonPaxos.h"
 #include "messages/MConfig.h"
 #include "messages/MGetConfig.h"
+#include "messages/MKVData.h"
 
 #include "messages/MMonProbe.h"
 #include "messages/MMonJoin.h"
 #include "messages/MMonElection.h"
 #include "messages/MMonSync.h"
+#include "messages/MMonPing.h"
 #include "messages/MMonScrub.h"
 
 #include "messages/MLog.h"
@@ -83,12 +85,10 @@
 #include "messages/MOSDPGRemove.h"
 #include "messages/MOSDPGInfo.h"
 #include "messages/MOSDPGInfo2.h"
-#include "messages/MOSDPGCreate.h"
 #include "messages/MOSDPGCreate2.h"
 #include "messages/MOSDPGTrim.h"
 #include "messages/MOSDPGLease.h"
 #include "messages/MOSDPGLeaseAck.h"
-#include "messages/MOSDScrub.h"
 #include "messages/MOSDScrub2.h"
 #include "messages/MOSDScrubReserve.h"
 #include "messages/MOSDRepScrub.h"
@@ -110,12 +110,12 @@
 #include "messages/MMonGetVersionReply.h"
 #include "messages/MMonHealth.h"
 #include "messages/MMonHealthChecks.h"
-#include "messages/MMonMetadata.h"
 #include "messages/MAuth.h"
 #include "messages/MAuthReply.h"
 #include "messages/MMonSubscribe.h"
 #include "messages/MMonSubscribeAck.h"
 #include "messages/MMonGlobalID.h"
+#include "messages/MMonUsedPendingKeys.h"
 #include "messages/MClientSession.h"
 #include "messages/MClientReconnect.h"
 #include "messages/MClientRequest.h"
@@ -128,8 +128,9 @@
 #include "messages/MClientLease.h"
 #include "messages/MClientSnap.h"
 #include "messages/MClientQuota.h"
+#include "messages/MClientMetrics.h"
 
-#include "messages/MMDSSlaveRequest.h"
+#include "messages/MMDSPeerRequest.h"
 
 #include "messages/MMDSMap.h"
 #include "messages/MFSMap.h"
@@ -144,6 +145,8 @@
 #include "messages/MMDSOpenIno.h"
 #include "messages/MMDSOpenInoReply.h"
 #include "messages/MMDSSnapUpdate.h"
+#include "messages/MMDSScrub.h"
+#include "messages/MMDSScrubStats.h"
 
 #include "messages/MDirUpdate.h"
 #include "messages/MDiscover.h"
@@ -174,6 +177,8 @@
 #include "messages/MHeartbeat.h"
 
 #include "messages/MMDSTableRequest.h"
+#include "messages/MMDSMetrics.h"
+#include "messages/MMDSPing.h"
 
 //#include "messages/MInodeUpdate.h"
 #include "messages/MCacheExpire.h"
@@ -184,6 +189,7 @@
 #include "messages/MMgrDigest.h"
 #include "messages/MMgrReport.h"
 #include "messages/MMgrOpen.h"
+#include "messages/MMgrUpdate.h"
 #include "messages/MMgrClose.h"
 #include "messages/MMgrConfigure.h"
 #include "messages/MMonMgrReport.h"
@@ -211,6 +217,10 @@
 #include "messages/MOSDPGUpdateLogMissing.h"
 #include "messages/MOSDPGUpdateLogMissingReply.h"
 
+#ifdef WITH_BLKIN
+#include "Messenger.h"
+#endif
+
 #define DEBUGLVL  10    // debug level of output
 
 #define dout_subsys ceph_subsys_ms
@@ -276,7 +286,7 @@ void Message::encode(uint64_t features, int crcflags, bool skip_header_crc)
       snprintf(fn, sizeof(fn), ENCODE_STRINGIFY(ENCODE_DUMP) "/%s__%d.%x",
 	       abi::__cxa_demangle(typeid(*this).name(), 0, 0, &status),
 	       getpid(), i++);
-      int fd = ::open(fn, O_WRONLY|O_TRUNC|O_CREAT|O_CLOEXEC, 0644);
+      int fd = ::open(fn, O_WRONLY|O_TRUNC|O_CREAT|O_CLOEXEC|O_BINARY, 0644);
       if (fd >= 0) {
 	bl.write_fd(fd);
 	::close(fd);
@@ -288,9 +298,9 @@ void Message::encode(uint64_t features, int crcflags, bool skip_header_crc)
   }
 }
 
-void Message::dump(Formatter *f) const
+void Message::dump(ceph::Formatter *f) const
 {
-  stringstream ss;
+  std::stringstream ss;
   print(ss);
   f->dump_string("summary", ss.str());
 }
@@ -347,12 +357,14 @@ Message *decode_message(CephContext *cct,
   }
 
   // make message
-  ref_t<Message> m;
+  ceph::ref_t<Message> m;
   int type = header.type;
   switch (type) {
 
     // -- with payload --
 
+    using ceph::make_message;
+
   case MSG_PGSTATS:
     m = make_message<MPGStats>();
     break;
@@ -393,6 +405,9 @@ Message *decode_message(CephContext *cct,
   case MSG_GET_CONFIG:
     m = make_message<MGetConfig>();
     break;
+  case MSG_KV_DATA:
+    m = make_message<MKVData>();
+    break;
 
   case MSG_MON_PROBE:
     m = make_message<MMonProbe>();
@@ -406,6 +421,9 @@ Message *decode_message(CephContext *cct,
   case MSG_MON_SYNC:
     m = make_message<MMonSync>();
     break;
+  case MSG_MON_PING:
+    m = make_message<MMonPing>();
+    break;
   case MSG_MON_SCRUB:
     m = make_message<MMonScrub>();
     break;
@@ -464,9 +482,6 @@ Message *decode_message(CephContext *cct,
   case CEPH_MSG_MON_GET_VERSION_REPLY:
     m = make_message<MMonGetVersionReply>();
     break;
-  case CEPH_MSG_MON_METADATA:
-    m = make_message<MMonMetadata>();
-    break;
 
   case MSG_OSD_BOOT:
     m = make_message<MOSDBoot>();
@@ -552,9 +567,6 @@ Message *decode_message(CephContext *cct,
   case MSG_OSD_PG_INFO2:
     m = make_message<MOSDPGInfo2>();
     break;
-  case MSG_OSD_PG_CREATE:
-    m = make_message<MOSDPGCreate>();
-    break;
   case MSG_OSD_PG_CREATE2:
     m = make_message<MOSDPGCreate2>();
     break;
@@ -568,9 +580,6 @@ Message *decode_message(CephContext *cct,
     m = make_message<MOSDPGLeaseAck>();
     break;
 
-  case MSG_OSD_SCRUB:
-    m = make_message<MOSDScrub>();
-    break;
   case MSG_OSD_SCRUB2:
     m = make_message<MOSDScrub2>();
     break;
@@ -636,6 +645,9 @@ Message *decode_message(CephContext *cct,
   case MSG_MON_GLOBAL_ID:
     m = make_message<MMonGlobalID>();
     break; 
+  case MSG_MON_USED_PENDING_KEYS:
+    m = make_message<MMonUsedPendingKeys>();
+    break; 
 
     // clients
   case CEPH_MSG_MON_SUBSCRIBE:
@@ -680,10 +692,13 @@ Message *decode_message(CephContext *cct,
   case CEPH_MSG_CLIENT_QUOTA:
     m = make_message<MClientQuota>();
     break;
+  case CEPH_MSG_CLIENT_METRICS:
+    m = make_message<MClientMetrics>();
+    break;
 
     // mds
-  case MSG_MDS_SLAVE_REQUEST:
-    m = make_message<MMDSSlaveRequest>();
+  case MSG_MDS_PEER_REQUEST:
+    m = make_message<MMDSPeerRequest>();
     break;
 
   case CEPH_MSG_MDS_MAP:
@@ -748,6 +763,14 @@ Message *decode_message(CephContext *cct,
     m = make_message<MMDSFragmentNotifyAck>();
     break;
 
+  case MSG_MDS_SCRUB:
+    m = make_message<MMDSScrub>();
+    break;
+
+  case MSG_MDS_SCRUB_STATS:
+    m = make_message<MMDSScrubStats>();
+    break;
+
   case MSG_MDS_EXPORTDIRDISCOVER:
     m = make_message<MExportDirDiscover>();
     break;
@@ -795,6 +818,9 @@ Message *decode_message(CephContext *cct,
     break;
 
 
+  case MSG_MDS_DENTRYUNLINK_ACK:
+    m = make_message<MDentryUnlinkAck>();
+    break;
   case MSG_MDS_DENTRYUNLINK:
     m = make_message<MDentryUnlink>();
     break;
@@ -827,6 +853,14 @@ Message *decode_message(CephContext *cct,
     m = make_message<MLock>();
     break;
 
+  case MSG_MDS_METRICS:
+    m = make_message<MMDSMetrics>();
+    break;
+
+  case MSG_MDS_PING:
+    m = make_message<MMDSPing>();
+    break;
+
   case MSG_MGR_BEACON:
     m = make_message<MMgrBeacon>();
     break;
@@ -859,6 +893,10 @@ Message *decode_message(CephContext *cct,
     m = make_message<MMgrOpen>();
     break;
 
+  case MSG_MGR_UPDATE:
+    m = make_message<MMgrUpdate>();
+    break;
+
   case MSG_MGR_CLOSE:
     m = make_message<MMgrClose>();
     break;
@@ -929,7 +967,7 @@ Message *decode_message(CephContext *cct,
   try {
     m->decode_payload();
   }
-  catch (const buffer::error &e) {
+  catch (const ceph::buffer::error &e) {
     if (cct) {
       lderr(cct) << "failed to decode message of type " << type
 		 << " v" << header.version
@@ -948,7 +986,7 @@ Message *decode_message(CephContext *cct,
   return m.detach();
 }
 
-void Message::encode_trace(bufferlist &bl, uint64_t features) const
+void Message::encode_trace(ceph::bufferlist &bl, uint64_t features) const
 {
   using ceph::encode;
   auto p = trace.get_info();
@@ -959,7 +997,7 @@ void Message::encode_trace(bufferlist &bl, uint64_t features) const
   encode(*p, bl);
 }
 
-void Message::decode_trace(bufferlist::const_iterator &p, bool create)
+void Message::decode_trace(ceph::bufferlist::const_iterator &p, bool create)
 {
   blkin_trace_info info = {};
   decode(info, p);
@@ -971,12 +1009,12 @@ void Message::decode_trace(bufferlist::const_iterator &p, bool create)
   const auto msgr = connection->get_messenger();
   const auto endpoint = msgr->get_trace_endpoint();
   if (info.trace_id) {
-    trace.init(get_type_name(), endpoint, &info, true);
+    trace.init(get_type_name().data(), endpoint, &info, true);
     trace.event("decoded trace");
   } else if (create || (msgr->get_myname().is_osd() &&
                         msgr->cct->_conf->osd_blkin_trace_all)) {
     // create a trace even if we didn't get one on the wire
-    trace.init(get_type_name(), endpoint);
+    trace.init(get_type_name().data(), endpoint);
     trace.event("created trace");
   }
   trace.keyval("tid", get_tid());
@@ -992,7 +1030,7 @@ void Message::decode_trace(bufferlist::const_iterator &p, bool create)
 // problems, we currently always encode and decode using the old footer format that doesn't
 // allow for message authentication.  Eventually we should fix that.  PLR
 
-void encode_message(Message *msg, uint64_t features, bufferlist& payload)
+void encode_message(Message *msg, uint64_t features, ceph::bufferlist& payload)
 {
   ceph_msg_footer_old old_footer;
   msg->encode(features, MSG_CRC_ALL);
@@ -1006,6 +1044,7 @@ void encode_message(Message *msg, uint64_t features, bufferlist& payload)
   old_footer.flags = footer.flags;   
   encode(old_footer, payload);
 
+  using ceph::encode;
   encode(msg->get_payload(), payload);
   encode(msg->get_middle(), payload);
   encode(msg->get_data(), payload);
@@ -1016,12 +1055,12 @@ void encode_message(Message *msg, uint64_t features, bufferlist& payload)
 // We've slipped in a 0 signature at this point, so any signature checking after this will
 // fail.  PLR
 
-Message *decode_message(CephContext *cct, int crcflags, bufferlist::const_iterator& p)
+Message *decode_message(CephContext *cct, int crcflags, ceph::bufferlist::const_iterator& p)
 {
   ceph_msg_header h;
   ceph_msg_footer_old fo;
   ceph_msg_footer f;
-  bufferlist fr, mi, da;
+  ceph::bufferlist fr, mi, da;
   decode(h, p);
   decode(fo, p);
   f.front_crc = fo.front_crc;
@@ -1029,6 +1068,7 @@ Message *decode_message(CephContext *cct, int crcflags, bufferlist::const_iterat
   f.data_crc = fo.data_crc;
   f.flags = fo.flags;
   f.sig = 0;
+  using ceph::decode;
   decode(fr, p);
   decode(mi, p);
   decode(da, p);
diff --git a/src/msg/Message.h b/src/msg/Message.h
index b223aa6ebe7..6ebf06346c3 100644
--- a/src/msg/Message.h
+++ b/src/msg/Message.h
@@ -15,11 +15,15 @@
 #ifndef CEPH_MESSAGE_H
 #define CEPH_MESSAGE_H
 
+#include <concepts>
 #include <cstdlib>
 #include <ostream>
 #include <string_view>
 
 #include <boost/intrusive/list.hpp>
+#if FMT_VERSION >= 90000
+#include <fmt/ostream.h>
+#endif
 
 #include "include/Context.h"
 #include "common/RefCountedObj.h"
@@ -46,6 +50,7 @@
 #define MSG_MON_PROBE              67
 #define MSG_MON_JOIN               68
 #define MSG_MON_SYNC		   69
+#define MSG_MON_PING               140
 
 /* monitor <-> mon admin tool */
 #define MSG_MON_COMMAND            50
@@ -57,6 +62,7 @@
 #define MSG_GETPOOLSTATSREPLY      59
 
 #define MSG_MON_GLOBAL_ID          60
+#define MSG_MON_USED_PENDING_KEYS  141
 
 #define MSG_ROUTE                  47
 #define MSG_FORWARD                46
@@ -66,6 +72,8 @@
 #define MSG_CONFIG           62
 #define MSG_GET_CONFIG       63
 
+#define MSG_KV_DATA          54
+
 #define MSG_MON_GET_PURGED_SNAPS 76
 #define MSG_MON_GET_PURGED_SNAPS_REPLY 77
 
@@ -146,12 +154,13 @@
 // *** MDS ***
 
 #define MSG_MDS_BEACON             100  // to monitor
-#define MSG_MDS_SLAVE_REQUEST      101
+#define MSG_MDS_PEER_REQUEST       101
 #define MSG_MDS_TABLE_REQUEST      102
+#define MSG_MDS_SCRUB              135
 
                                 // 150 already in use (MSG_OSD_RECOVERY_RESERVE)
 
-#define MSG_MDS_RESOLVE            0x200
+#define MSG_MDS_RESOLVE            0x200 // 0x2xx are for mdcache of mds
 #define MSG_MDS_RESOLVEACK         0x201
 #define MSG_MDS_CACHEREJOIN        0x202
 #define MSG_MDS_DISCOVER           0x203
@@ -169,10 +178,11 @@
 #define MSG_MDS_OPENINOREPLY       0x210
 #define MSG_MDS_SNAPUPDATE         0x211
 #define MSG_MDS_FRAGMENTNOTIFYACK  0x212
-#define MSG_MDS_LOCK               0x300
+#define MSG_MDS_DENTRYUNLINK_ACK   0x213
+#define MSG_MDS_LOCK               0x300 // 0x3xx are for locker of mds
 #define MSG_MDS_INODEFILECAPS      0x301
 
-#define MSG_MDS_EXPORTDIRDISCOVER     0x449
+#define MSG_MDS_EXPORTDIRDISCOVER     0x449 // 0x4xx are for migrator of mds
 #define MSG_MDS_EXPORTDIRDISCOVERACK  0x450
 #define MSG_MDS_EXPORTDIRCANCEL       0x451
 #define MSG_MDS_EXPORTDIRPREP         0x452
@@ -190,6 +200,9 @@
 #define MSG_MDS_GATHERCAPS            0x472
 
 #define MSG_MDS_HEARTBEAT          0x500  // for mds load balancer
+#define MSG_MDS_METRICS            0x501  // for mds metric aggregator
+#define MSG_MDS_PING               0x502  // for mds pinger
+#define MSG_MDS_SCRUB_STATS        0x503  // for mds scrub stack
 
 // *** generic ***
 #define MSG_TIMECHECK             0x600
@@ -228,6 +241,9 @@
 #define MSG_MGR_COMMAND           0x709
 #define MSG_MGR_COMMAND_REPLY     0x70a
 
+// *** ceph-mgr <-> MON daemons ***
+#define MSG_MGR_UPDATE     0x70b
+
 // ======================================================
 
 // abstract Message class
@@ -236,8 +252,10 @@ class Message : public RefCountedObject {
 public:
 #ifdef WITH_SEASTAR
   using ConnectionRef = crimson::net::ConnectionRef;
+  using ConnectionFRef = crimson::net::ConnectionFRef;
 #else
   using ConnectionRef = ::ConnectionRef;
+  using ConnectionFRef = ::ConnectionRef;
 #endif // WITH_SEASTAR
 
 protected:
@@ -258,7 +276,7 @@ protected:
   /* time at which message was fully read */
   utime_t recv_complete_stamp;
 
-  ConnectionRef connection;
+  ConnectionFRef connection;
 
   uint32_t magic = 0;
 
@@ -315,8 +333,6 @@ public:
     header.type = t;
     header.version = version;
     header.compat_version = compat_version;
-    header.priority = 0;  // undef
-    header.data_off = 0;
     memset(&footer, 0, sizeof(footer));
   }
 
@@ -335,7 +351,7 @@ protected:
       completion_hook->complete(0);
   }
 public:
-  const ConnectionRef& get_connection() const { return connection; }
+  const ConnectionFRef& get_connection() const { return connection; }
   void set_connection(ConnectionRef c) {
     connection = std::move(c);
   }
@@ -396,7 +412,7 @@ public:
   void set_payload(ceph::buffer::list& bl) {
     if (byte_throttler)
       byte_throttler->put(payload.length());
-    payload.claim(bl);
+    payload = std::move(bl);
     if (byte_throttler)
       byte_throttler->take(payload.length());
   }
@@ -404,7 +420,7 @@ public:
   void set_middle(ceph::buffer::list& bl) {
     if (byte_throttler)
       byte_throttler->put(middle.length());
-    middle.claim(bl);
+    middle = std::move(bl);
     if (byte_throttler)
       byte_throttler->take(middle.length());
   }
@@ -423,9 +439,9 @@ public:
   void claim_data(ceph::buffer::list& bl) {
     if (byte_throttler)
       byte_throttler->put(data.length());
-    bl.claim(data);
+    bl = std::move(data);
   }
-  off_t get_data_len() const { return data.length(); }
+  uint32_t get_data_len() const { return data.length(); }
 
   void set_recv_stamp(utime_t t) { recv_stamp = t; }
   const utime_t& get_recv_stamp() const { return recv_stamp; }
@@ -536,6 +552,10 @@ extern Message *decode_message(CephContext *cct, int crcflags,
 class SafeMessage : public Message {
 public:
   using Message::Message;
+  bool is_a_client() const {
+    return get_connection()->get_peer_type() == CEPH_ENTITY_TYPE_CLIENT;
+  }
+
 private:
   using RefCountedObject::get;
   using RefCountedObject::put;
@@ -548,4 +568,15 @@ ceph::ref_t<T> make_message(Args&&... args) {
 }
 }
 
+namespace crimson {
+template<class T, typename... Args>
+MURef<T> make_message(Args&&... args) {
+  return {new T(std::forward<Args>(args)...), TOPNSPC::common::UniquePtrDeleter{}};
+}
+}
+
+#if FMT_VERSION >= 90000
+template <std::derived_from<Message> M> struct fmt::formatter<M> : fmt::ostream_formatter {};
+#endif
+
 #endif
diff --git a/src/msg/MessageRef.h b/src/msg/MessageRef.h
index 5eb3655cb84..fd66872e727 100644
--- a/src/msg/MessageRef.h
+++ b/src/msg/MessageRef.h
@@ -16,14 +16,18 @@
 #define CEPH_MESSAGEREF_H
  
 #include <boost/intrusive_ptr.hpp>
+#include "common/RefCountedObj.h"
 
 template<typename T>
 using MRef = boost::intrusive_ptr<T>;
 template<typename T>
 using MConstRef = boost::intrusive_ptr<T const>;
+template<typename T>
+using MURef = std::unique_ptr<T, TOPNSPC::common::UniquePtrDeleter>;
 
 using MessageRef = MRef<class Message>;
 using MessageConstRef = MConstRef<class Message>;
+using MessageURef = MURef<class Message>;
 
 /* cd src/messages/ && for f in *; do printf 'class '; basename "$f" .h | tr -d '\n'; printf ';\n'; done >> ../msg/MessageRef.h */
 
@@ -88,7 +92,7 @@ class MMDSOpenIno;
 class MMDSOpenInoReply;
 class MMDSResolveAck;
 class MMDSResolve;
-class MMDSSlaveRequest;
+class MMDSPeerRequest;
 class MMDSSnapUpdate;
 class MMDSTableRequest;
 class MMgrBeacon;
@@ -97,6 +101,7 @@ class MMgrConfigure;
 class MMgrDigest;
 class MMgrMap;
 class MMgrOpen;
+class MMgrUpdate;
 class MMgrReport;
 class MMonCommandAck;
 class MMonCommand;
@@ -133,14 +138,11 @@ class MOSDForceRecovery;
 class MOSDFull;
 class MOSDMap;
 class MOSDMarkMeDown;
-class MOSDOp;
-class MOSDOpReply;
 class MOSDPeeringOp;
 class MOSDPGBackfill;
 class MOSDPGBackfillRemove;
 class MOSDPGCreate2;
 class MOSDPGCreated;
-class MOSDPGCreate;
 class MOSDPGInfo;
 class MOSDPGLog;
 class MOSDPGNotify;
@@ -163,7 +165,6 @@ class MOSDRepOpReply;
 class MOSDRepScrub;
 class MOSDRepScrubMap;
 class MOSDScrub2;
-class MOSDScrub;
 class MOSDScrubReserve;
 class MPGStatsAck;
 class MPGStats;
diff --git a/src/msg/Messenger.cc b/src/msg/Messenger.cc
index 0b57891bd2d..5bcfb56e104 100644
--- a/src/msg/Messenger.cc
+++ b/src/msg/Messenger.cc
@@ -10,12 +10,12 @@
 
 #include "msg/async/AsyncMessenger.h"
 
-Messenger *Messenger::create_client_messenger(CephContext *cct, string lname)
+Messenger *Messenger::create_client_messenger(CephContext *cct, std::string lname)
 {
   std::string public_msgr_type = cct->_conf->ms_public_type.empty() ? cct->_conf.get_val<std::string>("ms_type") : cct->_conf->ms_public_type;
   auto nonce = get_random_nonce();
   return Messenger::create(cct, public_msgr_type, entity_name_t::CLIENT(),
-			   std::move(lname), nonce, 0);
+			   std::move(lname), nonce);
 }
 
 uint64_t Messenger::get_pid_nonce()
@@ -33,16 +33,11 @@ uint64_t Messenger::get_random_nonce()
   return ceph::util::generate_random_number<uint64_t>();
 }
 
-Messenger *Messenger::create(CephContext *cct, const string &type,
-			     entity_name_t name, string lname,
-			     uint64_t nonce, uint64_t cflags)
+Messenger *Messenger::create(CephContext *cct, const std::string &type,
+			     entity_name_t name, std::string lname,
+			     uint64_t nonce)
 {
-  int r = -1;
-  if (type == "random") {
-    r = 0;
-    //r = ceph::util::generate_random_number(0, 1);
-  }
-  if (r == 0 || type.find("async") != std::string::npos)
+  if (type == "random" || type.find("async") != std::string::npos)
     return new AsyncMessenger(cct, name, type, std::move(lname), nonce);
   lderr(cct) << "unrecognized ms_type '" << type << "'" << dendl;
   return nullptr;
@@ -63,9 +58,11 @@ Messenger::Messenger(CephContext *cct_, entity_name_t w)
     socket_priority(-1),
     cct(cct_),
     crcflags(get_default_crc_flags(cct->_conf)),
-    auth_registry(cct)
+    auth_registry(cct),
+    comp_registry(cct)
 {
   auth_registry.refresh_config();
+  comp_registry.refresh_config();
 }
 
 void Messenger::set_endpoint_addr(const entity_addr_t& a,
@@ -107,8 +104,9 @@ int get_default_crc_flags(const ConfigProxy& conf)
   return r;
 }
 
-int Messenger::bindv(const entity_addrvec_t& addrs)
+int Messenger::bindv(const entity_addrvec_t& bind_addrs,
+                     std::optional<entity_addrvec_t> public_addrs)
 {
-  return bind(addrs.legacy_addr());
+  return bind(bind_addrs.legacy_addr(), std::move(public_addrs));
 }
 
diff --git a/src/msg/Messenger.h b/src/msg/Messenger.h
index 3620a7e5ae0..71b7d2549c5 100644
--- a/src/msg/Messenger.h
+++ b/src/msg/Messenger.h
@@ -17,8 +17,9 @@
 #ifndef CEPH_MESSENGER_H
 #define CEPH_MESSENGER_H
 
-#include <map>
 #include <deque>
+#include <map>
+#include <optional>
 
 #include <errno.h>
 #include <sstream>
@@ -34,6 +35,7 @@
 #include "auth/Crypto.h"
 #include "common/item_history.h"
 #include "auth/AuthRegistry.h"
+#include "compressor_registry.h"
 #include "include/ceph_assert.h"
 
 #include <errno.h>
@@ -59,6 +61,29 @@ struct Interceptor {
     STOP
   };
 
+  enum STEP {
+    START_CLIENT_BANNER_EXCHANGE = 1,
+    START_SERVER_BANNER_EXCHANGE,
+    BANNER_EXCHANGE_BANNER_CONNECTING,
+    BANNER_EXCHANGE,
+    HANDLE_PEER_BANNER_BANNER_CONNECTING,
+    HANDLE_PEER_BANNER,
+    HANDLE_PEER_BANNER_PAYLOAD_HELLO_CONNECTING,
+    HANDLE_PEER_BANNER_PAYLOAD,
+    SEND_AUTH_REQUEST,
+    HANDLE_AUTH_REQUEST_ACCEPTING_SIGN,
+    SEND_CLIENT_IDENTITY,
+    SEND_SERVER_IDENTITY,
+    SEND_RECONNECT,
+    SEND_RECONNECT_OK,
+    READY,
+    HANDLE_MESSAGE,
+    READ_MESSAGE_COMPLETE,
+    SESSION_RETRY,
+    SEND_COMPRESSION_REQUEST,
+    HANDLE_COMPRESSION_REQUEST
+  };
+
   virtual ~Interceptor() {}
   virtual ACTION intercept(Connection *conn, uint32_t step) = 0;
 };
@@ -96,14 +121,6 @@ public:
   Interceptor *interceptor = nullptr;
 #endif
 
-  /**
-   * Various Messenger conditional config/type flags to allow
-   * different "transport" Messengers to tune themselves
-   */
-  static const int HAS_HEAVY_TRAFFIC    = 0x0001;
-  static const int HAS_MANY_CONNECTIONS = 0x0002;
-  static const int HEARTBEAT            = 0x0004;
-
   /**
    *  The CephContext this Messenger uses. Many other components initialize themselves
    *  from this value.
@@ -143,15 +160,12 @@ public:
    * @param name entity name to register
    * @param lname logical name of the messenger in this process (e.g., "client")
    * @param nonce nonce value to uniquely identify this instance on the current host
-   * @param features bits for the local connection
-   * @param cflags general std::set of flags to configure transport resources
    */
   static Messenger *create(CephContext *cct,
                            const std::string &type,
                            entity_name_t name,
 			   std::string lname,
-                           uint64_t nonce,
-			   uint64_t cflags);
+                           uint64_t nonce);
 
   static uint64_t get_random_nonce();
   static uint64_t get_pid_nonce();
@@ -162,7 +176,6 @@ public:
    * Create a new messenger instance.
    * Same as the above, but a slightly simpler interface for clients:
    * - Generate a random nonce
-   * - use the default feature bits
    * - get the messenger type from cct
    * - use the client entity_type
    *
@@ -219,6 +232,9 @@ public:
     auth_server = as;
   }
 
+  // for compression
+  CompressorRegistry comp_registry;
+
 protected:
   /**
    * std::set messenger's address
@@ -254,14 +270,7 @@ public:
    * @param addr The address to use as a template.
    */
   virtual bool set_addr_unknowns(const entity_addrvec_t &addrs) = 0;
-  /**
-   * set the address for this Messenger. This is useful if the Messenger
-   * binds to a specific address but advertises a different address on the
-   * the network.
-   *
-   * @param addr The address to use.
-   */
-  virtual void set_addrs(const entity_addrvec_t &addr) = 0;
+
   /// Get the default send priority.
   int get_default_send_priority() { return default_send_priority; }
   /**
@@ -411,12 +420,15 @@ public:
    * in an unspecified order.
    *
    * @param bind_addr The address to bind to.
+   * @patam public_addrs The addresses to announce over the network
    * @return 0 on success, or -1 on error, or -errno if
    * we can be more specific about the failure.
    */
-  virtual int bind(const entity_addr_t& bind_addr) = 0;
+  virtual int bind(const entity_addr_t& bind_addr,
+		   std::optional<entity_addrvec_t> public_addrs=std::nullopt) = 0;
 
-  virtual int bindv(const entity_addrvec_t& addrs);
+  virtual int bindv(const entity_addrvec_t& bind_addrs,
+                    std::optional<entity_addrvec_t> public_addrs=std::nullopt);
 
   /**
    * This function performs a full restart of the Messenger component,
@@ -655,7 +667,7 @@ public:
    *
    * @param m The Message we are testing.
    */
-  bool ms_can_fast_dispatch(const cref_t<Message>& m) {
+  bool ms_can_fast_dispatch(const ceph::cref_t<Message>& m) {
     for (const auto &dispatcher : fast_dispatchers) {
       if (dispatcher->ms_can_fast_dispatch2(m))
 	return true;
@@ -669,7 +681,7 @@ public:
    * @param m The Message we are fast dispatching.
    * If none of our Dispatchers can handle it, ceph_abort().
    */
-  void ms_fast_dispatch(const ref_t<Message> &m) {
+  void ms_fast_dispatch(const ceph::ref_t<Message> &m) {
     m->set_dispatch_stamp(ceph_clock_now());
     for (const auto &dispatcher : fast_dispatchers) {
       if (dispatcher->ms_can_fast_dispatch2(m)) {
@@ -680,12 +692,12 @@ public:
     ceph_abort();
   }
   void ms_fast_dispatch(Message *m) {
-    return ms_fast_dispatch(ref_t<Message>(m, false)); /* consume ref */
+    return ms_fast_dispatch(ceph::ref_t<Message>(m, false)); /* consume ref */
   }
   /**
    *
    */
-  void ms_fast_preprocess(const ref_t<Message> &m) {
+  void ms_fast_preprocess(const ceph::ref_t<Message> &m) {
     for (const auto &dispatcher : fast_dispatchers) {
       dispatcher->ms_fast_preprocess2(m);
     }
@@ -697,7 +709,7 @@ public:
    *
    *  @param m The Message to deliver.
    */
-  void ms_deliver_dispatch(const ref_t<Message> &m) {
+  void ms_deliver_dispatch(const ceph::ref_t<Message> &m) {
     m->set_dispatch_stamp(ceph_clock_now());
     for (const auto &dispatcher : dispatchers) {
       if (dispatcher->ms_dispatch2(m))
@@ -708,7 +720,7 @@ public:
     ceph_assert(!cct->_conf->ms_die_on_unhandled_msg);
   }
   void ms_deliver_dispatch(Message *m) {
-    return ms_deliver_dispatch(ref_t<Message>(m, false)); /* consume ref */
+    return ms_deliver_dispatch(ceph::ref_t<Message>(m, false)); /* consume ref */
   }
   /**
    * Notify each Dispatcher of a new Connection. Call
diff --git a/src/msg/Policy.h b/src/msg/Policy.h
index 10a426f2f46..0cfa03aee57 100644
--- a/src/msg/Policy.h
+++ b/src/msg/Policy.h
@@ -42,7 +42,12 @@ struct Policy {
   ThrottleType* throttler_messages;
   
   /// Specify features supported locally by the endpoint.
-  uint64_t features_supported;
+#ifdef MSG_POLICY_UNIT_TESTING
+  uint64_t features_supported{CEPH_FEATURES_SUPPORTED_DEFAULT};
+#else
+  static constexpr uint64_t features_supported{CEPH_FEATURES_SUPPORTED_DEFAULT};
+#endif
+
   /// Specify features any remotes must have to talk to this endpoint.
   uint64_t features_required;
   
@@ -50,7 +55,6 @@ struct Policy {
     : lossy(false), server(false), standby(false), resetcheck(true),
       throttler_bytes(NULL),
       throttler_messages(NULL),
-      features_supported(CEPH_FEATURES_SUPPORTED_DEFAULT),
       features_required(0) {}
 private:
   Policy(bool l, bool s, bool st, bool r, bool rlc, uint64_t req)
@@ -58,7 +62,6 @@ private:
       register_lossy_clients(rlc),
       throttler_bytes(NULL),
       throttler_messages(NULL),
-      features_supported(CEPH_FEATURES_SUPPORTED_DEFAULT),
       features_required(req) {}
   
 public:
diff --git a/src/msg/QueueStrategy.cc b/src/msg/QueueStrategy.cc
deleted file mode 100644
index 85b0a11e602..00000000000
--- a/src/msg/QueueStrategy.cc
+++ /dev/null
@@ -1,107 +0,0 @@
-// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
-// vim: ts=8 sw=2 smarttab
-/*
- * Ceph - scalable distributed file system
- *
- * Copyright (C) 2014 CohortFS, LLC
- *
- * This is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License version 2.1, as published by the Free Software
- * Foundation.  See file COPYING.
- *
- */
-#include <string>
-#include "QueueStrategy.h"
-#define dout_subsys ceph_subsys_ms
-#include "common/debug.h"
-
-QueueStrategy::QueueStrategy(int _n_threads)
-  : n_threads(_n_threads),
-    stop(false),
-    mqueue(),
-    disp_threads()
-{
-}
-
-void QueueStrategy::ds_dispatch(Message *m) {
-  msgr->ms_fast_preprocess(m);
-  if (msgr->ms_can_fast_dispatch(m)) {
-    msgr->ms_fast_dispatch(m);
-    return;
-  }
-  std::lock_guard l{lock};
-  mqueue.push_back(*m);
-  if (disp_threads.size()) {
-    if (! disp_threads.empty()) {
-      QSThread *thrd = &disp_threads.front();
-      disp_threads.pop_front();
-      thrd->cond.notify_all();
-    }
-  }
-}
-
-void QueueStrategy::entry(QSThread *thrd)
-{
-  for (;;) {
-    ref_t<Message> m;
-    std::unique_lock l{lock};
-    for (;;) {
-      if (! mqueue.empty()) {
-	m = ref_t<Message>(&mqueue.front(), false);
-	mqueue.pop_front();
-	break;
-      }
-      if (stop)
-	break;
-      disp_threads.push_front(*thrd);
-      thrd->cond.wait(l);
-    }
-    l.unlock();
-    if (stop) {
-	if (!m) break;
-	continue;
-    }
-    get_messenger()->ms_deliver_dispatch(m);
-  }
-}
-
-void QueueStrategy::shutdown()
-{
-  QSThread *thrd;
-  std::lock_guard l{lock};
-  stop = true;
-  while (disp_threads.size()) {
-    thrd = &(disp_threads.front());
-    disp_threads.pop_front();
-    thrd->cond.notify_all();
-  }
-}
-
-void QueueStrategy::wait()
-{
-  std::unique_lock l{lock};
-  ceph_assert(stop);
-  for (auto& thread : threads) {
-    l.unlock();
-
-    // join outside of lock
-    thread->join();
-
-    l.lock();
-  }
-}
-
-void QueueStrategy::start()
-{
-  ceph_assert(!stop);
-  std::lock_guard l{lock};
-  threads.reserve(n_threads);
-  for (int ix = 0; ix < n_threads; ++ix) {
-    string thread_name = "ms_qs_";
-    thread_name.append(std::to_string(ix));
-    auto thrd = std::make_unique<QSThread>(this);
-    thrd->create(thread_name.c_str());
-    threads.emplace_back(std::move(thrd));
-  }
-}
diff --git a/src/msg/QueueStrategy.h b/src/msg/QueueStrategy.h
deleted file mode 100644
index b7f6df85d7c..00000000000
--- a/src/msg/QueueStrategy.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
-// vim: ts=8 sw=2 smarttab
-/*
- * Ceph - scalable distributed file system
- *
- * Copyright (C) 2014 CohortFS, LLC
- *
- * This is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License version 2.1, as published by the Free Software
- * Foundation.  See file COPYING.
- *
- */
-
-
-#ifndef QUEUE_STRATEGY_H
-#define QUEUE_STRATEGY_H
-
-#include <vector>
-#include <memory>
-#include <boost/intrusive/list.hpp>
-#include "DispatchStrategy.h"
-#include "msg/Messenger.h"
-
-namespace bi = boost::intrusive;
-
-class QueueStrategy : public DispatchStrategy {
-  ceph::mutex lock = ceph::make_mutex("QueueStrategy::lock");
-  const int n_threads;
-  bool stop;
-
-  Message::Queue mqueue;
-
-  class QSThread : public Thread {
-  public:
-    bi::list_member_hook<> thread_q;
-    QueueStrategy *dq;
-    ceph::condition_variable cond;
-    explicit QSThread(QueueStrategy *dq) : thread_q(), dq(dq) {}
-    void* entry() {
-      dq->entry(this);
-      return NULL;
-    }
-
-    typedef bi::list< QSThread,
-		      bi::member_hook< QSThread,
-				       bi::list_member_hook<>,
-				       &QSThread::thread_q > > Queue;
-  };
-
-  std::vector<std::unique_ptr<QSThread>> threads; //< all threads
-  QSThread::Queue disp_threads; //< waiting threads
-
-public:
-  explicit QueueStrategy(int n_threads);
-  void ds_dispatch(Message *m) override;
-  void shutdown() override;
-  void start() override;
-  void wait() override;
-  void entry(QSThread *thrd);
-  virtual ~QueueStrategy() {}
-};
-#endif /* QUEUE_STRATEGY_H */
diff --git a/src/msg/async/AsyncConnection.cc b/src/msg/async/AsyncConnection.cc
index 82ef1389734..8051f5907ef 100644
--- a/src/msg/async/AsyncConnection.cc
+++ b/src/msg/async/AsyncConnection.cc
@@ -35,7 +35,7 @@
 #define dout_subsys ceph_subsys_ms
 #undef dout_prefix
 #define dout_prefix _conn_prefix(_dout)
-ostream& AsyncConnection::_conn_prefix(std::ostream *_dout) {
+std::ostream& AsyncConnection::_conn_prefix(std::ostream *_dout) {
   return *_dout << "-- " << async_msgr->get_myaddrs() << " >> "
 		<< *peer_addrs << " conn(" << this
 		<< (msgr2 ? " msgr2=" : " legacy=")
@@ -168,8 +168,8 @@ void AsyncConnection::maybe_start_delay_thread()
   if (!delay_state) {
     async_msgr->cct->_conf.with_val<std::string>(
       "ms_inject_delay_type",
-      [this](const string& s) {
-	if (s.find(ceph_entity_type_name(peer_type)) != string::npos) {
+      [this](const std::string& s) {
+	if (s.find(ceph_entity_type_name(peer_type)) != std::string::npos) {
 	  ldout(msgr->cct, 1) << __func__ << " setting up a delay queue"
 			      << dendl;
 	  delay_state = new DelayedDelivery(async_msgr, center, dispatch_queue,
@@ -226,6 +226,7 @@ ssize_t AsyncConnection::read_until(unsigned len, char *p)
                                << " left is " << left << " buffer still has "
                                << recv_end - recv_start << dendl;
     if (left == 0) {
+      state_offset = 0;
       return 0;
     }
     state_offset += to_read;
@@ -289,7 +290,7 @@ ssize_t AsyncConnection::read_bulk(char *buf, unsigned len)
       goto again;
     } else {
       ldout(async_msgr->cct, 1) << __func__ << " reading from fd=" << cs.fd()
-                          << " : "<< strerror(nread) << dendl;
+                          << " : "<< nread << " " << strerror(nread) << dendl;
       return -1;
     }
   } else if (nread == 0) {
@@ -300,7 +301,7 @@ ssize_t AsyncConnection::read_bulk(char *buf, unsigned len)
   return nread;
 }
 
-ssize_t AsyncConnection::write(bufferlist &bl,
+ssize_t AsyncConnection::write(ceph::buffer::list &bl,
                                std::function<void(ssize_t)> callback,
                                bool more) {
 
@@ -327,7 +328,12 @@ ssize_t AsyncConnection::_try_send(bool more)
   ceph_assert(center->in_thread());
   ldout(async_msgr->cct, 25) << __func__ << " cs.send " << outgoing_bl.length()
                              << " bytes" << dendl;
-  ssize_t r = cs.send(outgoing_bl, more);
+  // network block would make ::send return EAGAIN, that would make here looks
+  // like do not call cs.send() and r = 0
+  ssize_t r = 0;
+  if (likely(!inject_network_congestion())) {
+    r = cs.send(outgoing_bl, more);
+  }
   if (r < 0) {
     ldout(async_msgr->cct, 1) << __func__ << " send error: " << cpp_strerror(r) << dendl;
     return r;
@@ -362,6 +368,11 @@ void AsyncConnection::inject_delay() {
   }
 }
 
+bool AsyncConnection::inject_network_congestion() const {
+  return (async_msgr->cct->_conf->ms_inject_network_congestion > 0 &&
+	  rand() % async_msgr->cct->_conf->ms_inject_network_congestion != 0);
+}
+
 void AsyncConnection::process() {
   std::lock_guard<std::mutex> l(lock);
   last_active = ceph::coarse_mono_clock::now();
@@ -384,8 +395,10 @@ void AsyncConnection::process() {
       // clear timer (if any) since we are connecting/re-connecting
       if (last_tick_id) {
         center->delete_time_event(last_tick_id);
-        last_tick_id = 0;
       }
+      last_connect_started = ceph::coarse_mono_clock::now();
+      last_tick_id = center->create_time_event(
+          connect_timeout_us, tick_handler);
 
       if (cs) {
         center->delete_file_event(cs.fd(), EVENT_READABLE | EVENT_WRITABLE);
@@ -394,6 +407,12 @@ void AsyncConnection::process() {
 
       SocketOptions opts;
       opts.priority = async_msgr->get_socket_priority();
+      if (async_msgr->cct->_conf->mon_use_min_delay_socket) {
+          if (async_msgr->get_mytype() == CEPH_ENTITY_TYPE_MON &&
+              peer_is_mon()) {
+            opts.priority = SOCKET_PRIORITY_MIN_DELAY;
+          }
+      }
       opts.connect_bind_addr = msgr->get_myaddrs().front();
       ssize_t r = worker->connect(target_addr, opts, &cs);
       if (r < 0) {
@@ -432,18 +451,19 @@ void AsyncConnection::process() {
       ldout(async_msgr->cct, 10)
           << __func__ << " connect successfully, ready to send banner" << dendl;
       state = STATE_CONNECTION_ESTABLISHED;
-      ceph_assert(last_tick_id == 0);
-      // exclude TCP nonblock connect time
-      last_connect_started = ceph::coarse_mono_clock::now();
-      last_tick_id = center->create_time_event(
-        connect_timeout_us, tick_handler);
       break;
     }
 
     case STATE_ACCEPTING: {
       center->create_file_event(cs.fd(), EVENT_READABLE, read_handler);
       state = STATE_CONNECTION_ESTABLISHED;
-
+      if (async_msgr->cct->_conf->mon_use_min_delay_socket) {
+        if (async_msgr->get_mytype() == CEPH_ENTITY_TYPE_MON &&
+            peer_is_mon()) {
+          cs.set_priority(cs.fd(), SOCKET_PRIORITY_MIN_DELAY,
+                          target_addr.get_family());
+        }
+      }
       break;
     }
 
@@ -767,7 +787,8 @@ void AsyncConnection::tick(uint64_t id)
           (now - last_connect_started).count()) {
       ldout(async_msgr->cct, 1) << __func__ << " see no progress in more than "
                                 << connect_timeout_us
-                                << " us during connecting, fault."
+                                << " us during connecting to "
+                                << target_addr << ", fault."
                                 << dendl;
       protocol->fault();
     } else {
diff --git a/src/msg/async/AsyncConnection.h b/src/msg/async/AsyncConnection.h
index 20d095dfafb..82c29985b18 100644
--- a/src/msg/async/AsyncConnection.h
+++ b/src/msg/async/AsyncConnection.h
@@ -56,7 +56,7 @@ class AsyncConnection : public Connection {
   ssize_t read_until(unsigned needed, char *p);
   ssize_t read_bulk(char *buf, unsigned len);
 
-  ssize_t write(bufferlist &bl, std::function<void(ssize_t)> callback,
+  ssize_t write(ceph::buffer::list &bl, std::function<void(ssize_t)> callback,
                 bool more=false);
   ssize_t _try_send(bool more=false);
 
@@ -64,6 +64,7 @@ class AsyncConnection : public Connection {
   void _stop();
   void fault();
   void inject_delay();
+  bool inject_network_congestion() const;
 
   bool is_queued() const;
   void shutdown_socket();
@@ -114,7 +115,7 @@ private:
 public:
   void maybe_start_delay_thread();
 
-  ostream& _conn_prefix(std::ostream *_dout);
+  std::ostream& _conn_prefix(std::ostream *_dout);
 
   bool is_connected() override;
 
@@ -182,7 +183,7 @@ private:
   DispatchQueue *dispatch_queue;
 
   // lockfree, only used in own thread
-  bufferlist outgoing_bl;
+  ceph::buffer::list outgoing_bl;
   bool open_write = false;
 
   std::mutex write_lock;
@@ -197,7 +198,7 @@ private:
   uint32_t recv_max_prefetch;
   uint32_t recv_start;
   uint32_t recv_end;
-  set<uint64_t> register_time_events; // need to delete it if stop
+  std::set<uint64_t> register_time_events; // need to delete it if stop
   ceph::coarse_mono_clock::time_point last_connect_started;
   ceph::coarse_mono_clock::time_point last_active;
   ceph::mono_clock::time_point recv_start_time;
@@ -233,7 +234,6 @@ private:
   void process();
   void wakeup_from(uint64_t id);
   void tick(uint64_t id);
-  void local_deliver();
   void stop(bool queue_reset);
   void cleanup();
   PerfCounters *get_perf_counter() {
diff --git a/src/msg/async/AsyncMessenger.cc b/src/msg/async/AsyncMessenger.cc
index 54e4a69f63a..7572827b37b 100644
--- a/src/msg/async/AsyncMessenger.cc
+++ b/src/msg/async/AsyncMessenger.cc
@@ -32,11 +32,11 @@
 #define dout_subsys ceph_subsys_ms
 #undef dout_prefix
 #define dout_prefix _prefix(_dout, this)
-static ostream& _prefix(std::ostream *_dout, AsyncMessenger *m) {
+static std::ostream& _prefix(std::ostream *_dout, AsyncMessenger *m) {
   return *_dout << "-- " << m->get_myaddrs() << " ";
 }
 
-static ostream& _prefix(std::ostream *_dout, Processor *p) {
+static std::ostream& _prefix(std::ostream *_dout, Processor *p) {
   return *_dout << " Processor -- ";
 }
 
@@ -60,7 +60,7 @@ Processor::Processor(AsyncMessenger *r, Worker *w, CephContext *c)
     listen_handler(new C_processor_accept(this)) {}
 
 int Processor::bind(const entity_addrvec_t &bind_addrs,
-		    const set<int>& avoid_ports,
+		    const std::set<int>& avoid_ports,
 		    entity_addrvec_t* bound_addrs)
 {
   const auto& conf = msgr->cct->_conf;
@@ -278,7 +278,7 @@ class C_handle_reap : public EventCallback {
  */
 
 AsyncMessenger::AsyncMessenger(CephContext *cct, entity_name_t name,
-                               const std::string &type, string mname, uint64_t _nonce)
+                               const std::string &type, std::string mname, uint64_t _nonce)
   : SimplePolicyMessenger(cct, name),
     dispatch_queue(cct, this, mname),
     nonce(_nonce)
@@ -324,7 +324,7 @@ void AsyncMessenger::ready()
 
   stack->ready();
   if (pending_bind) {
-    int err = bindv(pending_bind_addrs);
+    int err = bindv(pending_bind_addrs, saved_public_addrs);
     if (err) {
       lderr(cct) << __func__ << " postponed bind failed" << dendl;
       ceph_abort();
@@ -357,9 +357,11 @@ int AsyncMessenger::shutdown()
   return 0;
 }
 
-int AsyncMessenger::bind(const entity_addr_t &bind_addr)
+int AsyncMessenger::bind(const entity_addr_t &bind_addr,
+                         std::optional<entity_addrvec_t> public_addrs)
 {
-  ldout(cct,10) << __func__ << " " << bind_addr << dendl;
+  ldout(cct, 10) << __func__ << " " << bind_addr
+                 << " public " << public_addrs << dendl;
   // old bind() can take entity_addr_t(). new bindv() can take a
   // 0.0.0.0-like address but needs type and family to be set.
   auto a = bind_addr;
@@ -371,10 +373,11 @@ int AsyncMessenger::bind(const entity_addr_t &bind_addr)
       a.set_family(AF_INET);
     }
   }
-  return bindv(entity_addrvec_t(a));
+  return bindv(entity_addrvec_t(a), public_addrs);
 }
 
-int AsyncMessenger::bindv(const entity_addrvec_t &bind_addrs)
+int AsyncMessenger::bindv(const entity_addrvec_t &bind_addrs,
+                          std::optional<entity_addrvec_t> public_addrs)
 {
   lock.lock();
 
@@ -384,7 +387,14 @@ int AsyncMessenger::bindv(const entity_addrvec_t &bind_addrs)
     return -1;
   }
 
-  ldout(cct,10) << __func__ << " " << bind_addrs << dendl;
+  ldout(cct, 10) << __func__ << " " << bind_addrs
+                 << " public " << public_addrs << dendl;
+  if (public_addrs && bind_addrs != public_addrs) {
+    // for the sake of rebind() and the is-not-ready case let's
+    // store public_addrs. there is no point in that if public
+    // addrs are indifferent from bind_addrs.
+    saved_public_addrs = std::move(public_addrs);
+  }
 
   if (!stack->is_ready()) {
     ldout(cct, 10) << __func__ << " Network Stack is not ready for bind yet - postponed" << dendl;
@@ -397,7 +407,7 @@ int AsyncMessenger::bindv(const entity_addrvec_t &bind_addrs)
   lock.unlock();
 
   // bind to a socket
-  set<int> avoid_ports;
+  std::set<int> avoid_ports;
   entity_addrvec_t bound_addrs;
   unsigned i = 0;
   for (auto &&p : processors) {
@@ -421,7 +431,7 @@ int AsyncMessenger::bindv(const entity_addrvec_t &bind_addrs)
   return 0;
 }
 
-int AsyncMessenger::rebind(const set<int>& avoid_ports)
+int AsyncMessenger::rebind(const std::set<int>& avoid_ports)
 {
   ldout(cct,1) << __func__ << " rebind avoid " << avoid_ports << dendl;
   ceph_assert(did_bind);
@@ -437,7 +447,7 @@ int AsyncMessenger::rebind(const set<int>& avoid_ports)
 
   entity_addrvec_t bound_addrs;
   entity_addrvec_t bind_addrs = get_myaddrs();
-  set<int> new_avoid(avoid_ports);
+  std::set<int> new_avoid(avoid_ports);
   for (auto& a : bind_addrs.v) {
     new_avoid.insert(a.get_port());
     a.set_port(0);
@@ -494,6 +504,20 @@ void AsyncMessenger::_finish_bind(const entity_addrvec_t& bind_addrs,
   entity_addrvec_t newaddrs = *my_addrs;
   for (auto& a : newaddrs.v) {
     a.set_nonce(nonce);
+    if (saved_public_addrs) {
+      // transplantate network layer addresses while keeping ports
+      // (as they can be figured out by msgr from the allowed range [1])
+      // unless they are explicitly specified (NATing both IP/port?)
+      //
+      // [1]: the low-level `Processor::bind` scans for free ports in
+      // a range controlled by ms_bind_port_min and ms_bind_port_max
+      const auto& public_addr =
+        saved_public_addrs->addr_of_type(a.get_type());
+      const auto public_port = public_addr.get_port();
+      const auto bound_port = a.get_port();
+      a.set_sockaddr(public_addr.get_sockaddr());
+      a.set_port(public_port == 0 ? bound_port : public_port);
+    }
   }
   set_myaddrs(newaddrs);
 
@@ -765,17 +789,6 @@ bool AsyncMessenger::set_addr_unknowns(const entity_addrvec_t &addrs)
   return ret;
 }
 
-void AsyncMessenger::set_addrs(const entity_addrvec_t &addrs)
-{
-  std::lock_guard l{lock};
-  auto t = addrs;
-  for (auto& a : t.v) {
-    a.set_nonce(nonce);
-  }
-  set_myaddrs(t);
-  _init_local_connection();
-}
-
 void AsyncMessenger::shutdown_connections(bool queue_reset)
 {
   ldout(cct,1) << __func__ << " " << dendl;
diff --git a/src/msg/async/AsyncMessenger.h b/src/msg/async/AsyncMessenger.h
index 9c420b18d53..0a3227dec5d 100644
--- a/src/msg/async/AsyncMessenger.h
+++ b/src/msg/async/AsyncMessenger.h
@@ -18,6 +18,7 @@
 #define CEPH_ASYNCMESSENGER_H
 
 #include <map>
+#include <optional>
 
 #include "include/types.h"
 #include "include/xlist.h"
@@ -44,9 +45,9 @@ class AsyncMessenger;
  */
 class Processor {
   AsyncMessenger *msgr;
-  NetHandler net;
+  ceph::NetHandler net;
   Worker *worker;
-  vector<ServerSocket> listen_sockets;
+  std::vector<ServerSocket> listen_sockets;
   EventCallbackRef listen_handler;
 
   class C_processor_accept;
@@ -57,7 +58,7 @@ class Processor {
 
   void stop();
   int bind(const entity_addrvec_t &bind_addrs,
-	   const set<int>& avoid_ports,
+	   const std::set<int>& avoid_ports,
 	   entity_addrvec_t* bound_addrs);
   void start();
   void accept();
@@ -82,7 +83,7 @@ public:
    * be a value that will be repeated if the daemon restarts.
    */
   AsyncMessenger(CephContext *cct, entity_name_t name, const std::string &type,
-                 string mname, uint64_t _nonce);
+                 std::string mname, uint64_t _nonce);
 
   /**
    * Destroy the AsyncMessenger. Pretty simple since all the work is done
@@ -94,7 +95,6 @@ public:
    * @{
    */
   bool set_addr_unknowns(const entity_addrvec_t &addr) override;
-  void set_addrs(const entity_addrvec_t &addrs) override;
 
   int get_dispatch_queue_len() override {
     return dispatch_queue.get_queue_len();
@@ -114,9 +114,11 @@ public:
     cluster_protocol = p;
   }
 
-  int bind(const entity_addr_t& bind_addr) override;
-  int rebind(const set<int>& avoid_ports) override;
-  int bindv(const entity_addrvec_t& bind_addrs) override;
+  int bind(const entity_addr_t& bind_addr,
+	   std::optional<entity_addrvec_t> public_addrs=std::nullopt) override;
+  int rebind(const std::set<int>& avoid_ports) override;
+  int bindv(const entity_addrvec_t& bind_addrs,
+	    std::optional<entity_addrvec_t> public_addrs=std::nullopt) override;
 
   int client_bind(const entity_addr_t& bind_addr) override;
 
@@ -230,11 +232,19 @@ private:
   bool need_addr = true;
 
   /**
-   * set to bind addresses if bind was called before NetworkStack was ready to
-   * bind
+   * set to bind addresses if bind or bindv were called before NetworkStack
+   * was ready to bind
    */
   entity_addrvec_t pending_bind_addrs;
 
+  /**
+   * set to public addresses (those announced by the msgr's protocols).
+   * they are stored to handle the cases when either:
+   *   a) bind or bindv were called before NetworkStack was ready to bind,
+   *   b) rebind is called down the road.
+   */
+  std::optional<entity_addrvec_t> saved_public_addrs;
+
   /**
    * false; set to true if a pending bind exists
    */
@@ -268,10 +278,10 @@ private:
    *
    * These are not yet in the conns map.
    */
-  set<AsyncConnectionRef> accepting_conns;
+  std::set<AsyncConnectionRef> accepting_conns;
 
   /// anonymous outgoing connections
-  set<AsyncConnectionRef> anon_conns;
+  std::set<AsyncConnectionRef> anon_conns;
 
   /**
    * list of connection are closed which need to be clean up
@@ -285,7 +295,7 @@ private:
    * AsyncConnection in this set.
    */
   ceph::mutex deleted_lock = ceph::make_mutex("AsyncMessenger::deleted_lock");
-  set<AsyncConnectionRef> deleted_conns;
+  std::set<AsyncConnectionRef> deleted_conns;
 
   EventCallbackRef reap_handler;
 
diff --git a/src/msg/async/Event.cc b/src/msg/async/Event.cc
index 4d2fb339416..4662e42bd14 100644
--- a/src/msg/async/Event.cc
+++ b/src/msg/async/Event.cc
@@ -28,9 +28,13 @@
 #ifdef HAVE_KQUEUE
 #include "EventKqueue.h"
 #else
+#ifdef HAVE_POLL
+#include "EventPoll.h"
+#else
 #include "EventSelect.h"
 #endif
 #endif
+#endif
 
 #define dout_subsys ceph_subsys_ms
 
@@ -46,10 +50,14 @@ class C_handle_notify : public EventCallback {
     char c[256];
     int r = 0;
     do {
+      #ifdef _WIN32
+      r = recv(fd_or_id, c, sizeof(c), 0);
+      #else
       r = read(fd_or_id, c, sizeof(c));
+      #endif
       if (r < 0) {
-        if (errno != EAGAIN)
-          ldout(cct, 1) << __func__ << " read notify pipe failed: " << cpp_strerror(errno) << dendl;
+        if (ceph_sock_errno() != EAGAIN)
+          ldout(cct, 1) << __func__ << " read notify pipe failed: " << cpp_strerror(ceph_sock_errno()) << dendl;
       }
     } while (r > 0);
   }
@@ -69,7 +77,7 @@ class C_handle_notify : public EventCallback {
  *      about the poller. The name of the superclass is probably sufficient
  *      for most cases.
  */
-EventCenter::Poller::Poller(EventCenter* center, const string& name)
+EventCenter::Poller::Poller(EventCenter* center, const std::string& name)
     : owner(center), poller_name(name), slot(owner->pollers.size())
 {
   owner->pollers.push_back(this);
@@ -94,7 +102,7 @@ EventCenter::Poller::~Poller()
   slot = -1;
 }
 
-ostream& EventCenter::_event_prefix(std::ostream *_dout)
+std::ostream& EventCenter::_event_prefix(std::ostream *_dout)
 {
   return *_dout << "Event(" << this << " nevent=" << nevent
                 << " time_id=" << time_event_next_id << ").";
@@ -118,9 +126,13 @@ int EventCenter::init(int nevent, unsigned center_id, const std::string &type)
 #else
 #ifdef HAVE_KQUEUE
   driver = new KqueueDriver(cct);
+#else
+#ifdef HAVE_POLL
+  driver = new PollDriver(cct);
 #else
   driver = new SelectDriver(cct);
 #endif
+#endif
 #endif
   }
 
@@ -142,14 +154,20 @@ int EventCenter::init(int nevent, unsigned center_id, const std::string &type)
     return 0;
 
   int fds[2];
+
+  #ifdef _WIN32
+  if (win_socketpair(fds) < 0) {
+  #else
   if (pipe_cloexec(fds, 0) < 0) {
-    int e = errno;
+  #endif
+    int e = ceph_sock_errno();
     lderr(cct) << __func__ << " can't create notify pipe: " << cpp_strerror(e) << dendl;
     return -e;
   }
 
   notify_receive_fd = fds[0];
   notify_send_fd = fds[1];
+
   r = net.set_nonblock(notify_receive_fd);
   if (r < 0) {
     return r;
@@ -177,9 +195,9 @@ EventCenter::~EventCenter()
   //assert(time_events.empty());
 
   if (notify_receive_fd >= 0)
-    ::close(notify_receive_fd);
+    compat_closesocket(notify_receive_fd);
   if (notify_send_fd >= 0)
-    ::close(notify_send_fd);
+    compat_closesocket(notify_send_fd);
 
   delete driver;
   if (notify_handler)
@@ -248,7 +266,7 @@ int EventCenter::create_file_event(int fd, int mask, EventCallbackRef ctxt)
     event->write_cb = ctxt;
   }
   ldout(cct, 20) << __func__ << " create event end fd=" << fd << " mask=" << mask
-                 << " original mask is " << event->mask << dendl;
+                 << " current mask is " << event->mask << dendl;
   return 0;
 }
 
@@ -281,7 +299,7 @@ void EventCenter::delete_file_event(int fd, int mask)
 
   event->mask = event->mask & (~mask);
   ldout(cct, 30) << __func__ << " delete event end fd=" << fd << " mask=" << mask
-                 << " original mask is " << event->mask << dendl;
+                 << " current mask is " << event->mask << dendl;
 }
 
 uint64_t EventCenter::create_time_event(uint64_t microseconds, EventCallbackRef ctxt)
@@ -327,10 +345,15 @@ void EventCenter::wakeup()
   ldout(cct, 20) << __func__ << dendl;
   char buf = 'c';
   // wake up "event_wait"
+  #ifdef _WIN32
+  int n = send(notify_send_fd, &buf, sizeof(buf), 0);
+  #else
   int n = write(notify_send_fd, &buf, sizeof(buf));
+  #endif
   if (n < 0) {
-    if (errno != EAGAIN) {
-      ldout(cct, 1) << __func__ << " write notify pipe failed: " << cpp_strerror(errno) << dendl;
+    if (ceph_sock_errno() != EAGAIN) {
+      ldout(cct, 1) << __func__ << " write notify pipe failed: "
+                    << cpp_strerror(ceph_sock_errno()) << dendl;
       ceph_abort();
     }
   }
@@ -340,6 +363,7 @@ int EventCenter::process_time_events()
 {
   int processed = 0;
   clock_type::time_point now = clock_type::now();
+  using ceph::operator <<;
   ldout(cct, 30) << __func__ << " cur time is " << now << dendl;
 
   while (!time_events.empty()) {
@@ -388,7 +412,7 @@ int EventCenter::process_events(unsigned timeout_microseconds,  ceph::timespan *
   tv.tv_usec = timeout_microseconds % 1000000;
 
   ldout(cct, 30) << __func__ << " wait second " << tv.tv_sec << " usec " << tv.tv_usec << dendl;
-  vector<FiredFileEvent> fired_events;
+  std::vector<FiredFileEvent> fired_events;
   numevents = driver->event_wait(fired_events, &tv);
   auto working_start = ceph::mono_clock::now();
   for (int event_id = 0; event_id < numevents; event_id++) {
@@ -422,7 +446,7 @@ int EventCenter::process_events(unsigned timeout_microseconds,  ceph::timespan *
 
   if (external_num_events.load()) {
     external_lock.lock();
-    deque<EventCallbackRef> cur_process;
+    std::deque<EventCallbackRef> cur_process;
     cur_process.swap(external_events);
     external_num_events.store(0);
     external_lock.unlock();
diff --git a/src/msg/async/Event.h b/src/msg/async/Event.h
index 5d6d04c9e8e..753a7c699f2 100644
--- a/src/msg/async/Event.h
+++ b/src/msg/async/Event.h
@@ -30,6 +30,10 @@
 #define HAVE_KQUEUE 1
 #endif
 
+#ifdef _WIN32
+#define HAVE_POLL 1
+#endif
+
 #ifdef __sun
 #include <sys/feature_tests.h>
 #ifdef _DTRACE_VERSION
@@ -76,7 +80,7 @@ class EventDriver {
   virtual int init(EventCenter *center, int nevent) = 0;
   virtual int add_event(int fd, int cur_mask, int mask) = 0;
   virtual int del_event(int fd, int cur_mask, int del_mask) = 0;
-  virtual int event_wait(vector<FiredFileEvent> &fired_events, struct timeval *tp) = 0;
+  virtual int event_wait(std::vector<FiredFileEvent> &fired_events, struct timeval *tp) = 0;
   virtual int resize_events(int newsize) = 0;
   virtual bool need_wakeup() { return true; }
 };
@@ -121,7 +125,7 @@ class EventCenter {
      */
   class Poller {
    public:
-    explicit Poller(EventCenter* center, const string& pollerName);
+    explicit Poller(EventCenter* center, const std::string& pollerName);
     virtual ~Poller();
 
     /**
@@ -142,7 +146,7 @@ class EventCenter {
     /// Human-readable string name given to the poller to make it
     /// easy to identify for debugging. For most pollers just passing
     /// in the subclass name probably makes sense.
-    string poller_name;
+    std::string poller_name;
 
     /// Index of this Poller in EventCenter::pollers.  Allows deletion
     /// without having to scan all the entries in pollers. -1 means
@@ -159,8 +163,8 @@ class EventCenter {
   pthread_t owner = 0;
   std::mutex external_lock;
   std::atomic_ulong external_num_events;
-  deque<EventCallbackRef> external_events;
-  vector<FileEvent> file_events;
+  std::deque<EventCallbackRef> external_events;
+  std::vector<FileEvent> file_events;
   EventDriver *driver;
   std::multimap<clock_type::time_point, TimeEvent> time_events;
   // Keeps track of all of the pollers currently defined.  We don't
@@ -171,7 +175,7 @@ class EventCenter {
   uint64_t time_event_next_id;
   int notify_receive_fd;
   int notify_send_fd;
-  NetHandler net;
+  ceph::NetHandler net;
   EventCallbackRef notify_handler;
   unsigned center_id;
   AssociatedCenters *global_centers = nullptr;
@@ -190,7 +194,7 @@ class EventCenter {
     notify_receive_fd(-1), notify_send_fd(-1), net(c),
     notify_handler(NULL), center_id(0) { }
   ~EventCenter();
-  ostream& _event_prefix(std::ostream *_dout);
+  std::ostream& _event_prefix(std::ostream *_dout);
 
   int init(int nevent, unsigned center_id, const std::string &type);
   void set_owner();
diff --git a/src/msg/async/EventEpoll.cc b/src/msg/async/EventEpoll.cc
index 000aaf4fcbc..7ed5321dcda 100644
--- a/src/msg/async/EventEpoll.cc
+++ b/src/msg/async/EventEpoll.cc
@@ -116,7 +116,7 @@ int EpollDriver::resize_events(int newsize)
   return 0;
 }
 
-int EpollDriver::event_wait(vector<FiredFileEvent> &fired_events, struct timeval *tvp)
+int EpollDriver::event_wait(std::vector<FiredFileEvent> &fired_events, struct timeval *tvp)
 {
   int retval, numevents = 0;
 
diff --git a/src/msg/async/EventEpoll.h b/src/msg/async/EventEpoll.h
index 0221f90d34c..454ecbc34ff 100644
--- a/src/msg/async/EventEpoll.h
+++ b/src/msg/async/EventEpoll.h
@@ -42,7 +42,7 @@ class EpollDriver : public EventDriver {
   int add_event(int fd, int cur_mask, int add_mask) override;
   int del_event(int fd, int cur_mask, int del_mask) override;
   int resize_events(int newsize) override;
-  int event_wait(vector<FiredFileEvent> &fired_events,
+  int event_wait(std::vector<FiredFileEvent> &fired_events,
 		 struct timeval *tp) override;
 };
 
diff --git a/src/msg/async/EventKqueue.cc b/src/msg/async/EventKqueue.cc
index d6ba4a3db36..efa03596303 100644
--- a/src/msg/async/EventKqueue.cc
+++ b/src/msg/async/EventKqueue.cc
@@ -212,7 +212,8 @@ int KqueueDriver::resize_events(int newsize)
   return 0;
 }
 
-int KqueueDriver::event_wait(vector<FiredFileEvent> &fired_events, struct timeval *tvp)
+int KqueueDriver::event_wait(std::vector<FiredFileEvent> &fired_events,
+			     struct timeval *tvp)
 {
   int retval, numevents = 0;
   struct timespec timeout;
diff --git a/src/msg/async/EventKqueue.h b/src/msg/async/EventKqueue.h
index 24863a93d96..836be7fd426 100644
--- a/src/msg/async/EventKqueue.h
+++ b/src/msg/async/EventKqueue.h
@@ -60,7 +60,7 @@ class KqueueDriver : public EventDriver {
   int add_event(int fd, int cur_mask, int add_mask) override;
   int del_event(int fd, int cur_mask, int del_mask) override;
   int resize_events(int newsize) override;
-  int event_wait(vector<FiredFileEvent> &fired_events,
+  int event_wait(std::vector<FiredFileEvent> &fired_events,
 		 struct timeval *tp) override;
 };
 
diff --git a/src/msg/async/EventPoll.cc b/src/msg/async/EventPoll.cc
new file mode 100644
index 00000000000..4c09dbb4db4
--- /dev/null
+++ b/src/msg/async/EventPoll.cc
@@ -0,0 +1,197 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*- 
+// vim: ts=8 sw=2 smarttab ft=cpp
+/*
+ * Ceph - scalable distributed file system
+ *
+ * Copyright (C) 2022 Rafael Lopez <rafael.lopez@softiron.com>
+ *
+ *
+ * This is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License version 2.1, as published by the Free Software
+ * Foundation.	See file COPYING.
+ *
+ */
+
+#include "common/errno.h"
+#include "EventPoll.h"
+
+#include <unistd.h>
+#define dout_subsys ceph_subsys_ms
+
+#undef dout_prefix
+#define dout_prefix *_dout << "PollDriver."
+
+#ifndef POLL_ADD
+#define POLL_ADD 1
+#ifndef POLL_MOD
+#define POLL_MOD 2
+#ifndef POLL_DEL
+#define POLL_DEL 3
+#endif
+#endif
+#endif
+
+int PollDriver::init(EventCenter *c, int nevent) {
+  // pfds array will auto scale up to hard_max_pfds, which should be
+  // greater than total daemons/op_threads (todo: cfg option?)
+  hard_max_pfds = 8192;
+  // 128 seems a good starting point, cover clusters up to ~350 OSDs
+  // with default ms_async_op_threads
+  max_pfds = 128;
+
+  pfds = (POLLFD*)calloc(max_pfds, sizeof(POLLFD));
+  if (!pfds) {
+    lderr(cct) << __func__ << " unable to allocate memory " << dendl;
+    return -ENOMEM;
+  }
+
+  //initialise pfds
+  for(int i = 0; i < max_pfds; i++){
+    pfds[i].fd = -1;
+    pfds[i].events = 0;
+    pfds[i].revents = 0;
+  }
+  return 0;
+}
+
+// Helper func to register/unregister interest in a FD's events by
+// manipulating it's entry in pfds array
+int PollDriver::poll_ctl(int fd, int op, int events) {
+  int pos = 0;
+  if (op == POLL_ADD) {
+    // Find an empty pollfd slot
+    for(pos = 0; pos < max_pfds ; pos++){
+      if(pfds[pos].fd == -1){
+	pfds[pos].fd = fd;
+	pfds[pos].events = events;
+	pfds[pos].revents = 0;
+	return 0;
+      }
+    }
+    // We ran out of slots, try to increase
+    if (max_pfds < hard_max_pfds) {
+      ldout(cct, 10) << __func__ << " exhausted pollfd slots"
+		     << ", doubling to " << max_pfds*2 << dendl;
+      pfds = (POLLFD*)realloc(pfds, max_pfds*2*sizeof(POLLFD));
+      if (!pfds) {
+	lderr(cct) << __func__ << " unable to realloc for more pollfd slots"
+		   << dendl;
+	return -ENOMEM;
+      }
+      // Initialise new slots
+      for (int i = max_pfds ; i < max_pfds*2 ; i++){
+	pfds[i].fd = -1;
+	pfds[i].events = 0;
+	pfds[i].revents = 0;
+      }
+      max_pfds = max_pfds*2;
+      pfds[pos].fd = fd;
+      pfds[pos].events = events;
+      pfds[pos].revents = 0;
+      return 0;
+    } else {
+    // Hit hard limit
+    lderr(cct) << __func__ << " hard limit for file descriptors per op" 
+	       << " thread reached (" << hard_max_pfds << ")" << dendl;
+    return -EMFILE;
+    }
+  } else if (op == POLL_MOD) {
+    for (pos = 0; pos < max_pfds; pos++ ){
+      if (pfds[pos].fd == fd) {
+	pfds[pos].events = events;
+	return 0;
+      }
+    }
+  } else if (op == POLL_DEL) {
+    for (pos = 0; pos < max_pfds; pos++ ){
+      if (pfds[pos].fd == fd) {
+	pfds[pos].fd = -1;
+	pfds[pos].events = 0;
+	return 0;
+      }
+    }
+  }
+  return 0;
+}
+
+int PollDriver::add_event(int fd, int cur_mask, int add_mask) {
+  ldout(cct, 10) << __func__ << " add event to fd=" << fd << " mask="
+		 << add_mask << dendl;
+  int op, events = 0;
+  op = cur_mask == EVENT_NONE ? POLL_ADD: POLL_MOD;
+
+  add_mask |= cur_mask; /* Merge old events */
+  if (add_mask & EVENT_READABLE) {
+    events |= POLLIN;
+  }
+  if (add_mask & EVENT_WRITABLE) {
+    events |= POLLOUT;
+  }
+  int ret = poll_ctl(fd, op, events);
+  return ret;
+}
+
+int PollDriver::del_event(int fd, int cur_mask, int delmask) {
+  ldout(cct, 10) << __func__ << " del event fd=" << fd << " cur mask="
+		 << cur_mask << dendl;
+  int op, events = 0;
+  int mask = cur_mask & (~delmask);
+
+  if (mask != EVENT_NONE) {
+    op = POLL_MOD;
+    if (mask & EVENT_READABLE) {
+      events |= POLLIN;
+    }
+    if (mask & EVENT_WRITABLE) {
+      events |= POLLOUT;
+    }
+  } else {
+    op = POLL_DEL;
+  }
+  poll_ctl(fd, op, events);
+  return 0;
+}
+
+int PollDriver::resize_events(int newsize) {
+  return 0;
+}
+
+int PollDriver::event_wait(std::vector<FiredFileEvent> &fired_events,
+			  struct timeval *tvp) {
+  int retval, numevents = 0;
+#ifdef _WIN32
+  retval = WSAPoll(pfds, max_pfds,
+		      tvp ? (tvp->tv_sec*1000 + tvp->tv_usec/1000) : -1);
+#else
+  retval = poll(pfds, max_pfds,
+		      tvp ? (tvp->tv_sec*1000 + tvp->tv_usec/1000) : -1);
+#endif
+  if (retval > 0) {
+    for (int j = 0; j < max_pfds; j++) {
+      if (pfds[j].fd != -1) {
+	int mask = 0;
+	struct FiredFileEvent fe;
+	if (pfds[j].revents & POLLIN) {
+	  mask |= EVENT_READABLE;
+	}
+	if (pfds[j].revents & POLLOUT) {
+	  mask |= EVENT_WRITABLE;
+	}
+	if (pfds[j].revents & POLLHUP) {
+	  mask |= EVENT_READABLE | EVENT_WRITABLE;
+	}
+	if (pfds[j].revents & POLLERR) {
+	  mask |= EVENT_READABLE | EVENT_WRITABLE;
+	}
+	if (mask) {
+	  fe.fd = pfds[j].fd;
+	  fe.mask = mask;
+	  fired_events.push_back(fe);
+	  numevents++;
+	}
+      }
+    }
+  }
+  return numevents;
+}
diff --git a/src/msg/async/EventPoll.h b/src/msg/async/EventPoll.h
new file mode 100644
index 00000000000..772d46a3e79
--- /dev/null
+++ b/src/msg/async/EventPoll.h
@@ -0,0 +1,50 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*- 
+// vim: ts=8 sw=2 smarttab
+/*
+ * Ceph - scalable distributed file system
+ *
+ * Copyright (C) 2022 Rafael Lopez <rafael.lopez@softiron.com>
+ *
+ *
+ * This is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License version 2.1, as published by the Free Software
+ * Foundation.  See file COPYING.
+ *
+ */
+
+#ifndef CEPH_MSG_EVENTPOLL_H
+#define CEPH_MSG_EVENTPOLL_H
+
+#ifdef _WIN32
+#include <winsock2.h>
+#else
+#include <poll.h>
+#endif
+
+#include "Event.h"
+
+typedef struct pollfd POLLFD;
+
+class PollDriver : public EventDriver {
+  int max_pfds;
+  int hard_max_pfds;
+  POLLFD *pfds;
+  CephContext *cct;
+
+ private:
+  int poll_ctl(int, int, int);
+
+ public:
+  explicit PollDriver(CephContext *c): cct(c) {}
+  ~PollDriver() override {}
+
+  int init(EventCenter *c, int nevent) override;
+  int add_event(int fd, int cur_mask, int add_mask) override;
+  int del_event(int fd, int cur_mask, int del_mask) override;
+  int resize_events(int newsize) override;
+  int event_wait(std::vector<FiredFileEvent> &fired_events,
+		 struct timeval *tp) override;
+};
+
+#endif
diff --git a/src/msg/async/EventSelect.cc b/src/msg/async/EventSelect.cc
index fdee6ebc3c8..35000ccea5c 100644
--- a/src/msg/async/EventSelect.cc
+++ b/src/msg/async/EventSelect.cc
@@ -26,8 +26,10 @@
 
 int SelectDriver::init(EventCenter *c, int nevent)
 {
+  #ifndef _WIN32
   ldout(cct, 0) << "Select isn't suitable for production env, just avoid "
                 << "compiling error or special purpose" << dendl;
+  #endif
   FD_ZERO(&rfds);
   FD_ZERO(&wfds);
   max_fd = 0;
@@ -67,7 +69,7 @@ int SelectDriver::resize_events(int newsize)
   return 0;
 }
 
-int SelectDriver::event_wait(vector<FiredFileEvent> &fired_events, struct timeval *tvp)
+int SelectDriver::event_wait(std::vector<FiredFileEvent> &fired_events, struct timeval *tvp)
 {
   int retval, numevents = 0;
 
diff --git a/src/msg/async/EventSelect.h b/src/msg/async/EventSelect.h
index 1b75da0b1b0..08af57bcfd2 100644
--- a/src/msg/async/EventSelect.h
+++ b/src/msg/async/EventSelect.h
@@ -35,7 +35,7 @@ class SelectDriver : public EventDriver {
   int add_event(int fd, int cur_mask, int add_mask) override;
   int del_event(int fd, int cur_mask, int del_mask) override;
   int resize_events(int newsize) override;
-  int event_wait(vector<FiredFileEvent> &fired_events,
+  int event_wait(std::vector<FiredFileEvent> &fired_events,
 		 struct timeval *tp) override;
 };
 
diff --git a/src/msg/async/PosixStack.cc b/src/msg/async/PosixStack.cc
index 0fc344c2ff4..373bed7dec3 100644
--- a/src/msg/async/PosixStack.cc
+++ b/src/msg/async/PosixStack.cc
@@ -38,13 +38,14 @@
 #define dout_prefix *_dout << "PosixStack "
 
 class PosixConnectedSocketImpl final : public ConnectedSocketImpl {
-  NetHandler &handler;
+  ceph::NetHandler &handler;
   int _fd;
   entity_addr_t sa;
   bool connected;
 
  public:
-  explicit PosixConnectedSocketImpl(NetHandler &h, const entity_addr_t &sa, int f, bool connected)
+  explicit PosixConnectedSocketImpl(ceph::NetHandler &h, const entity_addr_t &sa,
+				    int f, bool connected)
       : handler(h), _fd(f), sa(sa), connected(connected) {}
 
   int is_connected() override {
@@ -63,14 +64,19 @@ class PosixConnectedSocketImpl final : public ConnectedSocketImpl {
   }
 
   ssize_t read(char *buf, size_t len) override {
+    #ifdef _WIN32
+    ssize_t r = ::recv(_fd, buf, len, 0);
+    #else
     ssize_t r = ::read(_fd, buf, len);
+    #endif
     if (r < 0)
-      r = -errno;
+      r = -ceph_sock_errno();
     return r;
   }
 
   // return the sent length
   // < 0 means error occurred
+  #ifndef _WIN32
   static ssize_t do_sendmsg(int fd, struct msghdr &msg, unsigned len, bool more)
   {
     size_t sent = 0;
@@ -79,12 +85,13 @@ class PosixConnectedSocketImpl final : public ConnectedSocketImpl {
       ssize_t r;
       r = ::sendmsg(fd, &msg, MSG_NOSIGNAL | (more ? MSG_MORE : 0));
       if (r < 0) {
-        if (errno == EINTR) {
+        int err = ceph_sock_errno();
+        if (err == EINTR) {
           continue;
-        } else if (errno == EAGAIN) {
+        } else if (err == EAGAIN) {
           break;
         }
-        return -errno;
+        return -err;
       }
 
       sent += r;
@@ -106,7 +113,7 @@ class PosixConnectedSocketImpl final : public ConnectedSocketImpl {
     return (ssize_t)sent;
   }
 
-  ssize_t send(bufferlist &bl, bool more) override {
+  ssize_t send(ceph::buffer::list &bl, bool more) override {
     size_t sent_bytes = 0;
     auto pb = std::cbegin(bl.buffers());
     uint64_t left_pbrs = bl.get_num_buffers();
@@ -138,7 +145,7 @@ class PosixConnectedSocketImpl final : public ConnectedSocketImpl {
     }
 
     if (sent_bytes) {
-      bufferlist swapped;
+      ceph::buffer::list swapped;
       if (sent_bytes < bl.length()) {
         bl.splice(sent_bytes, bl.length()-sent_bytes, &swapped);
         bl.swap(swapped);
@@ -149,11 +156,58 @@ class PosixConnectedSocketImpl final : public ConnectedSocketImpl {
 
     return static_cast<ssize_t>(sent_bytes);
   }
+  #else
+  ssize_t send(bufferlist &bl, bool more) override
+  {
+    size_t total_sent_bytes = 0;
+    auto pb = std::cbegin(bl.buffers());
+    uint64_t left_pbrs = bl.get_num_buffers();
+    while (left_pbrs) {
+      WSABUF msgvec[IOV_MAX];
+      uint64_t size = std::min<uint64_t>(left_pbrs, IOV_MAX);
+      left_pbrs -= size;
+      unsigned msglen = 0;
+      for (auto iov = msgvec; iov != msgvec + size; iov++) {
+        iov->buf = const_cast<char*>(pb->c_str());
+        iov->len = pb->length();
+        msglen += pb->length();
+        ++pb;
+      }
+      DWORD sent_bytes = 0;
+      DWORD flags = 0;
+      if (more)
+        flags |= MSG_PARTIAL;
+
+      int ret_val = WSASend(_fd, msgvec, size, &sent_bytes, flags, NULL, NULL);
+      if (ret_val)
+        return -ret_val;
+
+      total_sent_bytes += sent_bytes;
+      if (static_cast<unsigned>(sent_bytes) < msglen)
+        break;
+    }
+
+    if (total_sent_bytes) {
+      bufferlist swapped;
+      if (total_sent_bytes < bl.length()) {
+        bl.splice(total_sent_bytes, bl.length()-total_sent_bytes, &swapped);
+        bl.swap(swapped);
+      } else {
+        bl.clear();
+      }
+    }
+
+    return static_cast<ssize_t>(total_sent_bytes);
+  }
+  #endif
   void shutdown() override {
     ::shutdown(_fd, SHUT_RDWR);
   }
   void close() override {
-    ::close(_fd);
+    compat_closesocket(_fd);
+  }
+  void set_priority(int sd, int prio, int domain) override {
+    handler.set_priority(sd, prio, domain);
   }
   int fd() const override {
     return _fd;
@@ -163,11 +217,11 @@ class PosixConnectedSocketImpl final : public ConnectedSocketImpl {
 };
 
 class PosixServerSocketImpl : public ServerSocketImpl {
-  NetHandler &handler;
+  ceph::NetHandler &handler;
   int _fd;
 
  public:
-  explicit PosixServerSocketImpl(NetHandler &h, int f,
+  explicit PosixServerSocketImpl(ceph::NetHandler &h, int f,
 				 const entity_addr_t& listen_addr, unsigned slot)
     : ServerSocketImpl(listen_addr.get_type(), slot),
       handler(h), _fd(f) {}
@@ -187,19 +241,19 @@ int PosixServerSocketImpl::accept(ConnectedSocket *sock, const SocketOptions &op
   socklen_t slen = sizeof(ss);
   int sd = accept_cloexec(_fd, (sockaddr*)&ss, &slen);
   if (sd < 0) {
-    return -errno;
+    return -ceph_sock_errno();
   }
 
   int r = handler.set_nonblock(sd);
   if (r < 0) {
     ::close(sd);
-    return -errno;
+    return -ceph_sock_errno();
   }
 
   r = handler.set_socket_options(sd, opt.nodelay, opt.rcbuf_size);
   if (r < 0) {
     ::close(sd);
-    return -errno;
+    return -ceph_sock_errno();
   }
 
   ceph_assert(NULL != out); //out should not be NULL in accept connection
@@ -224,24 +278,24 @@ int PosixWorker::listen(entity_addr_t &sa,
 {
   int listen_sd = net.create_socket(sa.get_family(), true);
   if (listen_sd < 0) {
-    return -errno;
+    return -ceph_sock_errno();
   }
 
   int r = net.set_nonblock(listen_sd);
   if (r < 0) {
     ::close(listen_sd);
-    return -errno;
+    return -ceph_sock_errno();
   }
 
   r = net.set_socket_options(listen_sd, opt.nodelay, opt.rcbuf_size);
   if (r < 0) {
     ::close(listen_sd);
-    return -errno;
+    return -ceph_sock_errno();
   }
 
   r = ::bind(listen_sd, sa.get_sockaddr(), sa.get_sockaddr_len());
   if (r < 0) {
-    r = -errno;
+    r = -ceph_sock_errno();
     ldout(cct, 10) << __func__ << " unable to bind to " << sa.get_sockaddr()
                    << ": " << cpp_strerror(r) << dendl;
     ::close(listen_sd);
@@ -250,7 +304,7 @@ int PosixWorker::listen(entity_addr_t &sa,
 
   r = ::listen(listen_sd, cct->_conf->ms_tcp_listen_backlog);
   if (r < 0) {
-    r = -errno;
+    r = -ceph_sock_errno();
     lderr(cct) << __func__ << " unable to listen on " << sa << ": " << cpp_strerror(r) << dendl;
     ::close(listen_sd);
     return r;
@@ -272,7 +326,7 @@ int PosixWorker::connect(const entity_addr_t &addr, const SocketOptions &opts, C
   }
 
   if (sd < 0) {
-    return -errno;
+    return -ceph_sock_errno();
   }
 
   net.set_priority(sd, opts.priority, addr.get_family());
@@ -281,7 +335,7 @@ int PosixWorker::connect(const entity_addr_t &addr, const SocketOptions &opts, C
   return 0;
 }
 
-PosixNetworkStack::PosixNetworkStack(CephContext *c, const string &t)
-    : NetworkStack(c, t)
+PosixNetworkStack::PosixNetworkStack(CephContext *c)
+    : NetworkStack(c)
 {
 }
diff --git a/src/msg/async/PosixStack.h b/src/msg/async/PosixStack.h
index f1aaccd4b82..a4ff65b28f4 100644
--- a/src/msg/async/PosixStack.h
+++ b/src/msg/async/PosixStack.h
@@ -25,7 +25,7 @@
 #include "Stack.h"
 
 class PosixWorker : public Worker {
-  NetHandler net;
+  ceph::NetHandler net;
   void initialize() override;
  public:
   PosixWorker(CephContext *c, unsigned i)
@@ -38,14 +38,17 @@ class PosixWorker : public Worker {
 };
 
 class PosixNetworkStack : public NetworkStack {
-  vector<std::thread> threads;
+  std::vector<std::thread> threads;
+
+  virtual Worker* create_worker(CephContext *c, unsigned worker_id) override {
+    return new PosixWorker(c, worker_id);
+  }
 
  public:
-  explicit PosixNetworkStack(CephContext *c, const string &t);
+  explicit PosixNetworkStack(CephContext *c);
 
-  void spawn_worker(unsigned i, std::function<void ()> &&func) override {
-    threads.resize(i+1);
-    threads[i] = std::thread(func);
+  void spawn_worker(std::function<void ()> &&func) override {
+    threads.emplace_back(std::move(func));
   }
   void join_worker(unsigned i) override {
     ceph_assert(threads.size() > i && threads[i].joinable());
diff --git a/src/msg/async/Protocol.h b/src/msg/async/Protocol.h
index cccba183567..10436307ebf 100644
--- a/src/msg/async/Protocol.h
+++ b/src/msg/async/Protocol.h
@@ -47,7 +47,7 @@ public:
 };
 
 using rx_buffer_t =
-    std::unique_ptr<buffer::ptr_node, buffer::ptr_node::disposer>;
+  std::unique_ptr<ceph::buffer::ptr_node, ceph::buffer::ptr_node::disposer>;
 
 template <class C>
 class CtRxNode : public Ct<C> {
diff --git a/src/msg/async/ProtocolV1.cc b/src/msg/async/ProtocolV1.cc
index 46b3f269871..9376d46b0bd 100644
--- a/src/msg/async/ProtocolV1.cc
+++ b/src/msg/async/ProtocolV1.cc
@@ -15,7 +15,7 @@
 #define dout_subsys ceph_subsys_ms
 #undef dout_prefix
 #define dout_prefix _conn_prefix(_dout)
-ostream &ProtocolV1::_conn_prefix(std::ostream *_dout) {
+std::ostream &ProtocolV1::_conn_prefix(std::ostream *_dout) {
   return *_dout << "--1- " << messenger->get_myaddrs() << " >> "
                 << *connection->peer_addrs
 		<< " conn("
@@ -39,7 +39,7 @@ const int ASYNC_COALESCE_THRESHOLD = 256;
 
 using namespace std;
 
-static void alloc_aligned_buffer(bufferlist &data, unsigned len, unsigned off) {
+static void alloc_aligned_buffer(ceph::buffer::list &data, unsigned len, unsigned off) {
   // create a buffer to read into that matches the data alignment
   unsigned alloc_len = 0;
   unsigned left = len;
@@ -51,7 +51,7 @@ static void alloc_aligned_buffer(bufferlist &data, unsigned len, unsigned off) {
     left -= head;
   }
   alloc_len += left;
-  bufferptr ptr(buffer::create_small_page_aligned(alloc_len));
+  ceph::bufferptr ptr(ceph::buffer::create_small_page_aligned(alloc_len));
   if (head) ptr.set_offset(CEPH_PAGE_SIZE - head);
   data.push_back(std::move(ptr));
 }
@@ -211,7 +211,7 @@ void ProtocolV1::fault() {
 }
 
 void ProtocolV1::send_message(Message *m) {
-  bufferlist bl;
+  ceph::buffer::list bl;
   uint64_t f = connection->get_features();
 
   // TODO: Currently not all messages supports reencode like MOSDMap, so here
@@ -249,7 +249,7 @@ void ProtocolV1::send_message(Message *m) {
 }
 
 void ProtocolV1::prepare_send_message(uint64_t features, Message *m,
-                                      bufferlist &bl) {
+                                      ceph::buffer::list &bl) {
   ldout(cct, 20) << __func__ << " m " << *m << dendl;
 
   // associate message with Connection (for benefit of encode_payload)
@@ -315,7 +315,14 @@ void ProtocolV1::write_event() {
     auto start = ceph::mono_clock::now();
     bool more;
     do {
-      bufferlist data;
+      if (connection->is_queued()) {
+	if (r = connection->_try_send(); r!= 0) {
+	  // either fails to send or not all queued buffer is sent
+	  break;
+	}
+      }
+
+      ceph::buffer::list data;
       Message *m = _get_next_outgoing(&data);
       if (!m) {
         break;
@@ -436,7 +443,7 @@ CtPtr ProtocolV1::read(CONTINUATION_RX_TYPE<ProtocolV1> &next,
 }
 
 CtPtr ProtocolV1::write(CONTINUATION_TX_TYPE<ProtocolV1> &next,
-                        bufferlist &buffer) {
+                        ceph::buffer::list &buffer) {
   ssize_t r = connection->write(buffer, [&next, this](int r) {
     next.setParams(r);
     CONTINUATION_RUN(next);
@@ -662,7 +669,7 @@ CtPtr ProtocolV1::throttle_message() {
                    << "/" << connection->policy.throttler_messages->get_max()
                    << dendl;
     if (!connection->policy.throttler_messages->get_or_fail()) {
-      ldout(cct, 10) << __func__ << " wants 1 message from policy throttle "
+      ldout(cct, 1) << __func__ << " wants 1 message from policy throttle "
                      << connection->policy.throttler_messages->get_current()
                      << "/" << connection->policy.throttler_messages->get_max()
                      << " failed, just wait." << dendl;
@@ -693,7 +700,7 @@ CtPtr ProtocolV1::throttle_bytes() {
                      << connection->policy.throttler_bytes->get_current() << "/"
                      << connection->policy.throttler_bytes->get_max() << dendl;
       if (!connection->policy.throttler_bytes->get_or_fail(cur_msg_size)) {
-        ldout(cct, 10) << __func__ << " wants " << cur_msg_size
+        ldout(cct, 1) << __func__ << " wants " << cur_msg_size
                        << " bytes from policy throttler "
                        << connection->policy.throttler_bytes->get_current()
                        << "/" << connection->policy.throttler_bytes->get_max()
@@ -720,7 +727,7 @@ CtPtr ProtocolV1::throttle_dispatch_queue() {
   if (cur_msg_size) {
     if (!connection->dispatch_queue->dispatch_throttler.get_or_fail(
             cur_msg_size)) {
-      ldout(cct, 10)
+      ldout(cct, 1)
           << __func__ << " wants " << cur_msg_size
           << " bytes from dispatch throttle "
           << connection->dispatch_queue->dispatch_throttler.get_current() << "/"
@@ -749,7 +756,7 @@ CtPtr ProtocolV1::read_message_front() {
   unsigned front_len = current_header.front_len;
   if (front_len) {
     if (!front.length()) {
-      front.push_back(buffer::create(front_len));
+      front.push_back(ceph::buffer::create(front_len));
     }
     return READB(front_len, front.c_str(), handle_message_front);
   }
@@ -774,7 +781,7 @@ CtPtr ProtocolV1::read_message_middle() {
 
   if (current_header.middle_len) {
     if (!middle.length()) {
-      middle.push_back(buffer::create(current_header.middle_len));
+      middle.push_back(ceph::buffer::create(current_header.middle_len));
     }
     return READB(current_header.middle_len, middle.c_str(),
                  handle_message_middle);
@@ -807,7 +814,7 @@ CtPtr ProtocolV1::read_message_data_prepare() {
 #if 0
     // rx_buffers is broken by design... see
     //  http://tracker.ceph.com/issues/22480
-    map<ceph_tid_t, pair<bufferlist, int> >::iterator p =
+    map<ceph_tid_t, pair<ceph::buffer::list, int> >::iterator p =
         connection->rx_buffers.find(current_header.tid);
     if (p != connection->rx_buffers.end()) {
       ldout(cct, 10) << __func__ << " seleting rx buffer v " << p->second.second
@@ -841,7 +848,7 @@ CtPtr ProtocolV1::read_message_data() {
   ldout(cct, 20) << __func__ << " msg_left=" << msg_left << dendl;
 
   if (msg_left > 0) {
-    bufferptr bp = data_blp.get_current_ptr();
+    auto bp = data_blp.get_current_ptr();
     unsigned read_len = std::min(bp.length(), msg_left);
 
     return READB(read_len, bp.c_str(), handle_message_data);
@@ -858,7 +865,7 @@ CtPtr ProtocolV1::handle_message_data(char *buffer, int r) {
     return _fault();
   }
 
-  bufferptr bp = data_blp.get_current_ptr();
+  auto bp = data_blp.get_current_ptr();
   unsigned read_len = std::min(bp.length(), msg_left);
   ceph_assert(read_len <
 	      static_cast<unsigned>(std::numeric_limits<int>::max()));
@@ -1096,7 +1103,7 @@ void ProtocolV1::randomize_out_seq() {
   }
 }
 
-ssize_t ProtocolV1::write_message(Message *m, bufferlist &bl, bool more) {
+ssize_t ProtocolV1::write_message(Message *m, ceph::buffer::list &bl, bool more) {
   FUNCTRACE(cct);
   ceph_assert(connection->center->in_thread());
   m->set_seq(++out_seq);
@@ -1192,7 +1199,7 @@ void ProtocolV1::requeue_sent() {
     return;
   }
 
-  list<pair<bufferlist, Message *> > &rq = out_q[CEPH_MSG_PRIO_HIGHEST];
+  list<pair<ceph::buffer::list, Message *> > &rq = out_q[CEPH_MSG_PRIO_HIGHEST];
   out_seq -= sent.size();
   while (!sent.empty()) {
     Message *m = sent.back();
@@ -1200,7 +1207,7 @@ void ProtocolV1::requeue_sent() {
     ldout(cct, 10) << __func__ << " " << *m << " for resend "
                    << " (" << m->get_seq() << ")" << dendl;
     m->clear_payload();
-    rq.push_front(make_pair(bufferlist(), m));
+    rq.push_front(make_pair(ceph::buffer::list(), m));
   }
 }
 
@@ -1210,10 +1217,10 @@ uint64_t ProtocolV1::discard_requeued_up_to(uint64_t out_seq, uint64_t seq) {
   if (out_q.count(CEPH_MSG_PRIO_HIGHEST) == 0) {
     return seq;
   }
-  list<pair<bufferlist, Message *> > &rq = out_q[CEPH_MSG_PRIO_HIGHEST];
+  list<pair<ceph::buffer::list, Message *> > &rq = out_q[CEPH_MSG_PRIO_HIGHEST];
   uint64_t count = out_seq;
   while (!rq.empty()) {
-    pair<bufferlist, Message *> p = rq.front();
+    pair<ceph::buffer::list, Message *> p = rq.front();
     if (p.second->get_seq() == 0 || p.second->get_seq() > seq) break;
     ldout(cct, 10) << __func__ << " " << *(p.second) << " for resend seq "
                    << p.second->get_seq() << " <= " << seq << ", discarding"
@@ -1238,10 +1245,10 @@ void ProtocolV1::discard_out_queue() {
     (*p)->put();
   }
   sent.clear();
-  for (map<int, list<pair<bufferlist, Message *> > >::iterator p =
+  for (map<int, list<pair<ceph::buffer::list, Message *> > >::iterator p =
            out_q.begin();
        p != out_q.end(); ++p) {
-    for (list<pair<bufferlist, Message *> >::iterator r = p->second.begin();
+    for (list<pair<ceph::buffer::list, Message *> >::iterator r = p->second.begin();
          r != p->second.end(); ++r) {
       ldout(cct, 20) << __func__ << " discard " << r->second << dendl;
       r->second->put();
@@ -1313,13 +1320,13 @@ void ProtocolV1::reset_recv_state()
   }
 }
 
-Message *ProtocolV1::_get_next_outgoing(bufferlist *bl) {
+Message *ProtocolV1::_get_next_outgoing(ceph::buffer::list *bl) {
   Message *m = 0;
   if (!out_q.empty()) {
-    map<int, list<pair<bufferlist, Message *> > >::reverse_iterator it =
+    map<int, list<pair<ceph::buffer::list, Message *> > >::reverse_iterator it =
         out_q.rbegin();
     ceph_assert(!it->second.empty());
-    list<pair<bufferlist, Message *> >::iterator p = it->second.begin();
+    list<pair<ceph::buffer::list, Message *> >::iterator p = it->second.begin();
     m = p->second;
     if (p->first.length() && bl) {
       assert(bl->length() == 0);
@@ -1339,7 +1346,7 @@ CtPtr ProtocolV1::send_client_banner() {
   ldout(cct, 20) << __func__ << dendl;
   state = CONNECTING;
 
-  bufferlist bl;
+  ceph::buffer::list bl;
   bl.append(CEPH_BANNER, strlen(CEPH_BANNER));
   return WRITE(bl, handle_client_banner_write);
 }
@@ -1362,7 +1369,7 @@ CtPtr ProtocolV1::wait_server_banner() {
 
   ldout(cct, 20) << __func__ << dendl;
 
-  bufferlist myaddrbl;
+  ceph::buffer::list myaddrbl;
   unsigned banner_len = strlen(CEPH_BANNER);
   unsigned need_len = banner_len + sizeof(ceph_entity_addr) * 2;
   return READ(need_len, handle_server_banner_and_identify);
@@ -1384,7 +1391,7 @@ CtPtr ProtocolV1::handle_server_banner_and_identify(char *buffer, int r) {
     return _fault();
   }
 
-  bufferlist bl;
+  ceph::buffer::list bl;
   entity_addr_t paddr, peer_addr_for_me;
 
   bl.append(buffer + banner_len, sizeof(ceph_entity_addr) * 2);
@@ -1392,7 +1399,7 @@ CtPtr ProtocolV1::handle_server_banner_and_identify(char *buffer, int r) {
   try {
     decode(paddr, p);
     decode(peer_addr_for_me, p);
-  } catch (const buffer::error &e) {
+  } catch (const ceph::buffer::error &e) {
     lderr(cct) << __func__ << " decode peer addr failed " << dendl;
     return _fault();
   }
@@ -1455,7 +1462,7 @@ CtPtr ProtocolV1::handle_server_banner_and_identify(char *buffer, int r) {
     }
   }
 
-  bufferlist myaddrbl;
+  ceph::buffer::list myaddrbl;
   encode(messenger->get_myaddr_legacy(), myaddrbl, 0);  // legacy
   return WRITE(myaddrbl, handle_my_addr_write);
 }
@@ -1481,7 +1488,7 @@ CtPtr ProtocolV1::send_connect_message()
   ldout(cct, 20) << __func__ << dendl;
   ceph_assert(messenger->auth_client);
 
-  bufferlist auth_bl;
+  ceph::buffer::list auth_bl;
   vector<uint32_t> preferred_modes;
 
   if (connection->peer_type != CEPH_ENTITY_TYPE_MON ||
@@ -1532,7 +1539,7 @@ CtPtr ProtocolV1::send_connect_message()
         CEPH_MSG_CONNECT_LOSSY;  // this is fyi, actually, server decides!
   }
 
-  bufferlist bl;
+  ceph::buffer::list bl;
   bl.append((char *)&connect, sizeof(connect));
   if (auth_bl.length()) {
     bl.append(auth_bl.c_str(), auth_bl.length());
@@ -1614,14 +1621,14 @@ CtPtr ProtocolV1::handle_connect_reply_auth(char *buffer, int r) {
     return _fault();
   }
 
-  bufferlist authorizer_reply;
+  ceph::buffer::list authorizer_reply;
   authorizer_reply.append(buffer, connect_reply.authorizer_len);
 
   if (connection->peer_type != CEPH_ENTITY_TYPE_MON ||
       messenger->get_myname().type() == CEPH_ENTITY_TYPE_MON) {
     auto am = auth_meta;
     bool more = (connect_reply.tag == CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER);
-    bufferlist auth_retry_bl;
+    ceph::buffer::list auth_retry_bl;
     int r;
     connection->lock.unlock();
     if (more) {
@@ -1759,7 +1766,7 @@ CtPtr ProtocolV1::handle_ack_seq(char *buffer, int r) {
                 << " vs out_seq " << out_seq << dendl;
   out_seq = discard_requeued_up_to(out_seq, newly_acked_seq);
 
-  bufferlist bl;
+  ceph::buffer::list bl;
   uint64_t s = in_seq;
   bl.append((char *)&s, sizeof(s));
 
@@ -1830,7 +1837,7 @@ CtPtr ProtocolV1::send_server_banner() {
   ldout(cct, 20) << __func__ << dendl;
   state = ACCEPTING;
 
-  bufferlist bl;
+  ceph::buffer::list bl;
 
   bl.append(CEPH_BANNER, strlen(CEPH_BANNER));
 
@@ -1883,14 +1890,14 @@ CtPtr ProtocolV1::handle_client_banner(char *buffer, int r) {
     return _fault();
   }
 
-  bufferlist addr_bl;
+  ceph::buffer::list addr_bl;
   entity_addr_t peer_addr;
 
   addr_bl.append(buffer + strlen(CEPH_BANNER), sizeof(ceph_entity_addr));
   try {
     auto ti = addr_bl.cbegin();
     decode(peer_addr, ti);
-  } catch (const buffer::error &e) {
+  } catch (const ceph::buffer::error &e) {
     lderr(cct) << __func__ << " decode peer_addr failed " << dendl;
     return _fault();
   }
@@ -1941,7 +1948,7 @@ CtPtr ProtocolV1::handle_connect_message_1(char *buffer, int r) {
 CtPtr ProtocolV1::wait_connect_message_auth() {
   ldout(cct, 20) << __func__ << dendl;
   authorizer_buf.clear();
-  authorizer_buf.push_back(buffer::create(connect_msg.authorizer_len));
+  authorizer_buf.push_back(ceph::buffer::create(connect_msg.authorizer_len));
   return READB(connect_msg.authorizer_len, authorizer_buf.c_str(),
                handle_connect_message_auth);
 }
@@ -1977,7 +1984,7 @@ CtPtr ProtocolV1::handle_connect_message_2() {
                  << dendl;
 
   ceph_msg_connect_reply reply;
-  bufferlist authorizer_reply;
+  ceph::buffer::list authorizer_reply;
 
   // FIPS zeroization audit 20191115: this memset is not security related.
   memset(&reply, 0, sizeof(reply));
@@ -2043,7 +2050,7 @@ CtPtr ProtocolV1::handle_connect_message_2() {
                                       authorizer_reply);
   }
 
-  bufferlist auth_bl_copy = authorizer_buf;
+  ceph::buffer::list auth_bl_copy = authorizer_buf;
   auto am = auth_meta;
   am->auth_method = connect_msg.authorizer_protocol;
   if (!HAVE_FEATURE((uint64_t)connect_msg.features, CEPHX_V2)) {
@@ -2295,9 +2302,9 @@ CtPtr ProtocolV1::handle_connect_message_2() {
 
 CtPtr ProtocolV1::send_connect_message_reply(char tag,
                                              ceph_msg_connect_reply &reply,
-                                             bufferlist &authorizer_reply) {
+                                             ceph::buffer::list &authorizer_reply) {
   ldout(cct, 20) << __func__ << dendl;
-  bufferlist reply_bl;
+  ceph::buffer::list reply_bl;
   reply.tag = tag;
   reply.features =
       ((uint64_t)connect_msg.features & connection->policy.features_supported) |
@@ -2335,7 +2342,7 @@ CtPtr ProtocolV1::handle_connect_message_reply_write(int r) {
 
 CtPtr ProtocolV1::replace(const AsyncConnectionRef& existing,
                           ceph_msg_connect_reply &reply,
-                          bufferlist &authorizer_reply) {
+                          ceph::buffer::list &authorizer_reply) {
   ldout(cct, 10) << __func__ << " accept replacing " << existing << dendl;
 
   connection->inject_delay();
@@ -2468,7 +2475,7 @@ CtPtr ProtocolV1::replace(const AsyncConnectionRef& existing,
 }
 
 CtPtr ProtocolV1::open(ceph_msg_connect_reply &reply,
-                       bufferlist &authorizer_reply) {
+                       ceph::buffer::list &authorizer_reply) {
   ldout(cct, 20) << __func__ << dendl;
 
   connect_seq = connect_msg.connect_seq + 1;
@@ -2512,7 +2519,7 @@ CtPtr ProtocolV1::open(ceph_msg_connect_reply &reply,
 			     auth_meta->session_key,
 			     connection->get_features()));
 
-  bufferlist reply_bl;
+  ceph::buffer::list reply_bl;
   reply_bl.append((char *)&reply, sizeof(reply));
 
   if (reply.authorizer_len) {
diff --git a/src/msg/async/ProtocolV1.h b/src/msg/async/ProtocolV1.h
index 3f63a68b2e5..b23860e8a01 100644
--- a/src/msg/async/ProtocolV1.h
+++ b/src/msg/async/ProtocolV1.h
@@ -104,9 +104,9 @@ protected:
 
   enum class WriteStatus { NOWRITE, REPLACING, CANWRITE, CLOSED };
   std::atomic<WriteStatus> can_write;
-  std::list<Message *> sent;  // the first bufferlist need to inject seq
+  std::list<Message *> sent;  // the first ceph::buffer::list need to inject seq
   // priority queue for outbound msgs
-  std::map<int, std::list<std::pair<bufferlist, Message *>>> out_q;
+  std::map<int, std::list<std::pair<ceph::buffer::list, Message *>>> out_q;
   bool keepalive;
   bool write_in_progress = false;
 
@@ -120,8 +120,8 @@ protected:
   // Open state
   ceph_msg_connect connect_msg;
   ceph_msg_connect_reply connect_reply;
-  bufferlist authorizer_buf;  // auth(orizer) payload read off the wire
-  bufferlist authorizer_more;  // connect-side auth retry (we added challenge)
+  ceph::buffer::list authorizer_buf;  // auth(orizer) payload read off the wire
+  ceph::buffer::list authorizer_more;  // connect-side auth retry (we added challenge)
 
   utime_t backoff;  // backoff time
   utime_t recv_stamp;
@@ -129,9 +129,9 @@ protected:
   unsigned msg_left;
   uint64_t cur_msg_size;
   ceph_msg_header current_header;
-  bufferlist data_buf;
-  bufferlist::iterator data_blp;
-  bufferlist front, middle, data;
+  ceph::buffer::list data_buf;
+  ceph::buffer::list::iterator data_blp;
+  ceph::buffer::list front, middle, data;
 
   bool replacing;  // when replacing process happened, we will reply connect
                    // side with RETRY tag and accept side will clear replaced
@@ -147,7 +147,7 @@ protected:
   void run_continuation(CtPtr pcontinuation);
   CtPtr read(CONTINUATION_RX_TYPE<ProtocolV1> &next, int len,
              char *buffer = nullptr);
-  CtPtr write(CONTINUATION_TX_TYPE<ProtocolV1> &next,bufferlist &bl);
+  CtPtr write(CONTINUATION_TX_TYPE<ProtocolV1> &next,ceph::buffer::list &bl);
   inline CtPtr _fault() {  // helper fault method that stops continuation
     fault();
     return nullptr;
@@ -194,10 +194,10 @@ protected:
   void session_reset();
   void randomize_out_seq();
 
-  Message *_get_next_outgoing(bufferlist *bl);
+  Message *_get_next_outgoing(ceph::buffer::list *bl);
 
-  void prepare_send_message(uint64_t features, Message *m, bufferlist &bl);
-  ssize_t write_message(Message *m, bufferlist &bl, bool more);
+  void prepare_send_message(uint64_t features, Message *m, ceph::buffer::list &bl);
+  ssize_t write_message(Message *m, ceph::buffer::list &bl, bool more);
 
   void requeue_sent();
   uint64_t discard_requeued_up_to(uint64_t out_seq, uint64_t seq);
@@ -206,7 +206,7 @@ protected:
   void reset_recv_state();
   void reset_security();
 
-  ostream &_conn_prefix(std::ostream *_dout);
+  std::ostream& _conn_prefix(std::ostream *_dout);
 
 public:
   ProtocolV1(AsyncConnection *connection);
@@ -282,11 +282,11 @@ protected:
   CtPtr handle_connect_message_auth(char *buffer, int r);
   CtPtr handle_connect_message_2();
   CtPtr send_connect_message_reply(char tag, ceph_msg_connect_reply &reply,
-                                   bufferlist &authorizer_reply);
+                                   ceph::buffer::list &authorizer_reply);
   CtPtr handle_connect_message_reply_write(int r);
   CtPtr replace(const AsyncConnectionRef& existing, ceph_msg_connect_reply &reply,
-                bufferlist &authorizer_reply);
-  CtPtr open(ceph_msg_connect_reply &reply, bufferlist &authorizer_reply);
+                ceph::buffer::list &authorizer_reply);
+  CtPtr open(ceph_msg_connect_reply &reply, ceph::buffer::list &authorizer_reply);
   CtPtr handle_ready_connect_message_reply_write(int r);
   CtPtr wait_seq();
   CtPtr handle_seq(char *buffer, int r);
diff --git a/src/msg/async/ProtocolV2.cc b/src/msg/async/ProtocolV2.cc
index 4a237e744e6..7cda9637d90 100644
--- a/src/msg/async/ProtocolV2.cc
+++ b/src/msg/async/ProtocolV2.cc
@@ -16,7 +16,7 @@
 #define dout_subsys ceph_subsys_ms
 #undef dout_prefix
 #define dout_prefix _conn_prefix(_dout)
-ostream &ProtocolV2::_conn_prefix(std::ostream *_dout) {
+std::ostream &ProtocolV2::_conn_prefix(std::ostream *_dout) {
   return *_dout << "--2- " << messenger->get_myaddrs() << " >> "
                 << *connection->peer_addrs << " conn(" << connection << " "
                 << this
@@ -26,8 +26,10 @@ ostream &ProtocolV2::_conn_prefix(std::ostream *_dout) {
                 << " cs=" << connect_seq << " l=" << connection->policy.lossy
                 << " rev1=" << HAVE_MSGR2_FEATURE(peer_supported_features,
                                                   REVISION_1)
-                << " rx=" << session_stream_handlers.rx.get()
+                << " crypto rx=" << session_stream_handlers.rx.get()
                 << " tx=" << session_stream_handlers.tx.get()
+                << " comp rx=" << session_compression_handlers.rx.get()
+                << " tx=" << session_compression_handlers.tx.get()
                 << ").";
 }
 
@@ -45,8 +47,8 @@ void ProtocolV2::run_continuation(CtPtr pcontinuation) {
 void ProtocolV2::run_continuation(CtRef continuation) {
   try {
     CONTINUATION_RUN(continuation)
-  } catch (const buffer::error &e) {
-    lderr(cct) << __func__ << " failed decoding of frame header: " << e
+  } catch (const ceph::buffer::error &e) {
+    lderr(cct) << __func__ << " failed decoding of frame header: " << e.what()
                << dendl;
     _fault();
   } catch (const ceph::crypto::onwire::MsgAuthError &e) {
@@ -59,7 +61,7 @@ void ProtocolV2::run_continuation(CtRef continuation) {
 
 #define WRITE(B, D, C) write(D, CONTINUATION(C), B)
 
-#define READ(L, C) read(CONTINUATION(C), buffer::ptr_node::create(buffer::create(L)))
+#define READ(L, C) read(CONTINUATION(C), ceph::buffer::ptr_node::create(ceph::buffer::create(L)))
 
 #define READ_RXBUF(B, C) read(CONTINUATION(C), B)
 
@@ -94,8 +96,10 @@ ProtocolV2::ProtocolV2(AsyncConnection *connection)
       replacing(false),
       can_write(false),
       bannerExchangeCallback(nullptr),
-      tx_frame_asm(&session_stream_handlers, false),
-      rx_frame_asm(&session_stream_handlers, false),
+      tx_frame_asm(&session_stream_handlers, false, cct->_conf->ms_crc_data,
+                   &session_compression_handlers),
+      rx_frame_asm(&session_stream_handlers, false, cct->_conf->ms_crc_data,
+                   &session_compression_handlers),
       next_tag(static_cast<Tag>(0)),
       keepalive(false) {
 }
@@ -123,7 +127,7 @@ bool ProtocolV2::is_connected() { return can_write; }
 void ProtocolV2::discard_out_queue() {
   ldout(cct, 10) << __func__ << " started" << dendl;
 
-  for (list<Message *>::iterator p = sent.begin(); p != sent.end(); ++p) {
+  for (auto p = sent.begin(); p != sent.end(); ++p) {
     ldout(cct, 20) << __func__ << " discard " << *p << dendl;
     (*p)->put();
   }
@@ -246,15 +250,17 @@ void ProtocolV2::reset_recv_state() {
     // `write_event()` unlocks it just before calling `write_message()`.
     // `submit_to()` here is NOT blocking.
     connection->center->submit_to(connection->center->get_id(), [this] {
-      ldout(cct, 5) << "reset_recv_state (warped) reseting crypto handlers"
+      ldout(cct, 5) << "reset_recv_state (warped) reseting crypto and compression handlers"
                     << dendl;
       // Possibly unnecessary. See the comment in `deactivate_existing`.
       std::lock_guard<std::mutex> l(connection->lock);
       std::lock_guard<std::mutex> wl(connection->write_lock);
       reset_security();
+      reset_compression();
     }, /* always_async = */true);
   } else {
     reset_security();
+    reset_compression();
   }
 
   // clean read and write callbacks
@@ -527,8 +533,8 @@ ssize_t ProtocolV2::write_message(Message *m, bool more) {
   ceph_msg_header2 header2{header.seq,        header.tid,
                            header.type,       header.priority,
                            header.version,
-                           init_le32(0),      header.data_off,
-                           init_le64(ack_seq),
+                           ceph_le32(0),      header.data_off,
+                           ceph_le64(ack_seq),
                            footer.flags,      header.compat_version,
                            header.reserved};
 
@@ -556,8 +562,11 @@ ssize_t ProtocolV2::write_message(Message *m, bool more) {
     ldout(cct, 1) << __func__ << " error sending " << m << ", "
                   << cpp_strerror(rc) << dendl;
   } else {
-    connection->logger->inc(
-        l_msgr_send_bytes, total_send_size - connection->outgoing_bl.length());
+    const auto sent_bytes = total_send_size - connection->outgoing_bl.length();
+    connection->logger->inc(l_msgr_send_bytes, sent_bytes);
+    if (session_stream_handlers.tx) {
+      connection->logger->inc(l_msgr_send_encrypted_bytes, sent_bytes);
+    }
     ldout(cct, 10) << __func__ << " sending " << m
                    << (rc ? " continuely." : " done.") << dendl;
   }
@@ -585,7 +594,7 @@ bool ProtocolV2::append_frame(F& frame) {
 
   ldout(cct, 25) << __func__ << " assembled frame " << bl.length()
                  << " bytes " << tx_frame_asm << dendl;
-  connection->outgoing_bl.append(bl);
+  connection->outgoing_bl.claim_append(bl);
   return true;
 }
 
@@ -617,6 +626,14 @@ void ProtocolV2::handle_message_ack(uint64_t seq) {
   }
 }
 
+void ProtocolV2::reset_compression() {
+  ldout(cct, 5) << __func__ << dendl;
+
+  comp_meta = CompConnectionMeta{};
+  session_compression_handlers.rx.reset(nullptr);
+  session_compression_handlers.tx.reset(nullptr);
+}
+
 void ProtocolV2::write_event() {
   ldout(cct, 10) << __func__ << dendl;
   ssize_t r = 0;
@@ -639,6 +656,13 @@ void ProtocolV2::write_event() {
     auto start = ceph::mono_clock::now();
     bool more;
     do {
+      if (connection->is_queued()) {
+	if (r = connection->_try_send(); r!= 0) {
+	  // either fails to send or not all queued buffer is sent
+	  break;
+	}
+      }
+
       const auto out_entry = _get_next_outgoing();
       if (!out_entry.m) {
         break;
@@ -756,7 +780,7 @@ CtPtr ProtocolV2::read(CONTINUATION_RXBPTR_TYPE<ProtocolV2> &next,
     });
   if (r <= 0) {
     // error or done synchronously
-    if (unlikely(pre_auth.enabled) && r >= 0) {
+    if (unlikely(pre_auth.enabled) && r == 0) {
       pre_auth.rxbuf.append(*next.node);
       ceph_assert(!cct->_conf->ms_die_on_bug ||
 		  pre_auth.rxbuf.length() < 20000000);
@@ -787,7 +811,7 @@ CtPtr ProtocolV2::write(const std::string &desc,
 
 CtPtr ProtocolV2::write(const std::string &desc,
                         CONTINUATION_TYPE<ProtocolV2> &next,
-                        bufferlist &buffer) {
+                        ceph::bufferlist &buffer) {
   if (unlikely(pre_auth.enabled)) {
     pre_auth.txbuf.append(buffer);
     ceph_assert(!cct->_conf->ms_die_on_bug ||
@@ -821,11 +845,12 @@ CtPtr ProtocolV2::_banner_exchange(CtRef callback) {
   ldout(cct, 20) << __func__ << dendl;
   bannerExchangeCallback = &callback;
 
-  bufferlist banner_payload;
+  ceph::bufferlist banner_payload;
+  using ceph::encode;
   encode((uint64_t)CEPH_MSGR2_SUPPORTED_FEATURES, banner_payload, 0);
   encode((uint64_t)CEPH_MSGR2_REQUIRED_FEATURES, banner_payload, 0);
 
-  bufferlist bl;
+  ceph::bufferlist bl;
   bl.append(CEPH_BANNER_V2_PREFIX, strlen(CEPH_BANNER_V2_PREFIX));
   encode((uint16_t)banner_payload.length(), bl, 0);
   bl.claim_append(banner_payload);
@@ -862,14 +887,15 @@ CtPtr ProtocolV2::_handle_peer_banner(rx_buffer_t &&buffer, int r) {
   }
 
   uint16_t payload_len;
-  bufferlist bl;
+  ceph::bufferlist bl;
   buffer->set_offset(banner_prefix_len);
   buffer->set_length(sizeof(ceph_le16));
   bl.push_back(std::move(buffer));
   auto ti = bl.cbegin();
+  using ceph::decode;
   try {
     decode(payload_len, ti);
-  } catch (const buffer::error &e) {
+  } catch (const ceph::buffer::error &e) {
     lderr(cct) << __func__ << " decode banner payload len failed " << dendl;
     return _fault();
   }
@@ -891,13 +917,14 @@ CtPtr ProtocolV2::_handle_peer_banner_payload(rx_buffer_t &&buffer, int r) {
   uint64_t peer_supported_features;
   uint64_t peer_required_features;
 
-  bufferlist bl;
+  ceph::bufferlist bl;
+  using ceph::decode;
   bl.push_back(std::move(buffer));
   auto ti = bl.cbegin();
   try {
     decode(peer_supported_features, ti);
     decode(peer_required_features, ti);
-  } catch (const buffer::error &e) {
+  } catch (const ceph::buffer::error &e) {
     lderr(cct) << __func__ << " decode banner payload failed " << dendl;
     return _fault();
   }
@@ -1066,7 +1093,7 @@ CtPtr ProtocolV2::handle_read_frame_preamble_main(rx_buffer_t &&buffer, int r) {
 
   if (r < 0) {
     ldout(cct, 1) << __func__ << " read frame preamble failed r=" << r
-                  << " (" << cpp_strerror(r) << ")" << dendl;
+                  << dendl;
     return _fault();
   }
 
@@ -1101,6 +1128,7 @@ CtPtr ProtocolV2::handle_read_frame_preamble_main(rx_buffer_t &&buffer, int r) {
       lderr(cct) << __func__ << " not in ready state!" << dendl;
       return _fault();
     }
+    recv_stamp = ceph_clock_now();
     state = THROTTLE_MESSAGE;
     return CONTINUE(throttle_message);
   } else {
@@ -1132,6 +1160,8 @@ CtPtr ProtocolV2::handle_read_frame_dispatch() {
     case Tag::KEEPALIVE2_ACK:
     case Tag::ACK:
     case Tag::WAIT:
+    case Tag::COMPRESSION_REQUEST:
+    case Tag::COMPRESSION_DONE:
       return handle_frame_payload();
     case Tag::MESSAGE:
       return handle_message();
@@ -1159,7 +1189,7 @@ CtPtr ProtocolV2::read_frame_segment() {
   rx_buffer_t rx_buffer;
   uint16_t align = rx_frame_asm.get_segment_align(seg_idx);
   try {
-    rx_buffer = buffer::ptr_node::create(buffer::create_aligned(
+    rx_buffer = ceph::buffer::ptr_node::create(ceph::buffer::create_aligned(
         onwire_len, align));
   } catch (const ceph::buffer::bad_alloc&) {
     // Catching because of potential issues with satisfying alignment.
@@ -1246,6 +1276,10 @@ CtPtr ProtocolV2::handle_frame_payload() {
       return handle_message_ack(payload);
     case Tag::WAIT:
       return handle_wait(payload);
+    case Tag::COMPRESSION_REQUEST:
+      return handle_compression_request(payload);
+    case Tag::COMPRESSION_DONE:
+      return handle_compression_done(payload);
     default:
       ceph_abort();
   }
@@ -1301,11 +1335,9 @@ CtPtr ProtocolV2::handle_read_frame_epilogue_main(rx_buffer_t &&buffer, int r)
 }
 
 CtPtr ProtocolV2::_handle_read_frame_epilogue_main() {
-  bool aborted;
+  bool ok = false;
   try {
-    rx_frame_asm.disassemble_first_segment(rx_preamble, rx_segments_data[0]);
-    aborted = !rx_frame_asm.disassemble_remaining_segments(
-        rx_segments_data.data(), rx_epilogue);
+    ok = rx_frame_asm.disassemble_segments(rx_preamble, rx_segments_data.data(), rx_epilogue);
   } catch (FrameError& e) {
     ldout(cct, 1) << __func__ << " " << e.what() << dendl;
     return _fault();
@@ -1317,7 +1349,7 @@ CtPtr ProtocolV2::_handle_read_frame_epilogue_main() {
   // we do have a mechanism that allows transmitter to start sending message
   // and abort after putting entire data field on wire. This will be used by
   // the kernel client to avoid unnecessary buffering.
-  if (aborted) {
+  if (!ok) {
     reset_throttle();
     state = READY;
     return CONTINUE(read_frame);
@@ -1329,11 +1361,6 @@ CtPtr ProtocolV2::handle_message() {
   ldout(cct, 20) << __func__ << dendl;
   ceph_assert(state == THROTTLE_DONE);
 
-#if defined(WITH_EVENTTRACE)
-  utime_t ltt_recv_stamp = ceph_clock_now();
-#endif
-  recv_stamp = ceph_clock_now();
-
   const size_t cur_msg_size = get_current_msg_size();
   auto msg_frame = MessageFrame::Decode(rx_segments_data);
 
@@ -1356,16 +1383,16 @@ CtPtr ProtocolV2::handle_message() {
                          current_header.type,
                          current_header.priority,
                          current_header.version,
-                         init_le32(msg_frame.front_len()),
-                         init_le32(msg_frame.middle_len()),
-                         init_le32(msg_frame.data_len()),
+                         ceph_le32(msg_frame.front_len()),
+                         ceph_le32(msg_frame.middle_len()),
+                         ceph_le32(msg_frame.data_len()),
                          current_header.data_off,
                          peer_name,
                          current_header.compat_version,
                          current_header.reserved,
-                         init_le32(0)};
-  ceph_msg_footer footer{init_le32(0), init_le32(0),
-	                 init_le32(0), init_le64(0), current_header.flags};
+                         ceph_le32(0)};
+  ceph_msg_footer footer{ceph_le32(0), ceph_le32(0),
+	                 ceph_le32(0), ceph_le64(0), current_header.flags};
 
   Message *message = decode_message(cct, 0, header, footer,
       msg_frame.front(),
@@ -1422,7 +1449,7 @@ CtPtr ProtocolV2::handle_message() {
       message->get_type() == CEPH_MSG_OSD_OPREPLY) {
     utime_t ltt_processed_stamp = ceph_clock_now();
     double usecs_elapsed =
-        (ltt_processed_stamp.to_nsec() - ltt_recv_stamp.to_nsec()) / 1000;
+      ((double)(ltt_processed_stamp.to_nsec() - recv_stamp.to_nsec())) / 1000;
     ostringstream buf;
     if (message->get_type() == CEPH_MSG_OSD_OP)
       OID_ELAPSED_WITH_MSG(message, usecs_elapsed, "TIME_TO_DECODE_OSD_OP",
@@ -1459,6 +1486,10 @@ CtPtr ProtocolV2::handle_message() {
   connection->logger->inc(l_msgr_recv_messages);
   connection->logger->inc(l_msgr_recv_bytes,
                           rx_frame_asm.get_frame_onwire_len());
+  if (session_stream_handlers.rx) {
+    connection->logger->inc(l_msgr_recv_encrypted_bytes,
+                            rx_frame_asm.get_frame_onwire_len());
+  }
 
   messenger->ms_fast_preprocess(message);
   fast_dispatch_time = ceph::mono_clock::now();
@@ -1513,7 +1544,7 @@ CtPtr ProtocolV2::throttle_message() {
                    << "/" << connection->policy.throttler_messages->get_max()
                    << dendl;
     if (!connection->policy.throttler_messages->get_or_fail()) {
-      ldout(cct, 10) << __func__ << " wants 1 message from policy throttle "
+      ldout(cct, 1) << __func__ << " wants 1 message from policy throttle "
                      << connection->policy.throttler_messages->get_current()
                      << "/" << connection->policy.throttler_messages->get_max()
                      << " failed, just wait." << dendl;
@@ -1543,7 +1574,7 @@ CtPtr ProtocolV2::throttle_bytes() {
                      << connection->policy.throttler_bytes->get_current() << "/"
                      << connection->policy.throttler_bytes->get_max() << dendl;
       if (!connection->policy.throttler_bytes->get_or_fail(cur_msg_size)) {
-        ldout(cct, 10) << __func__ << " wants " << cur_msg_size
+        ldout(cct, 1) << __func__ << " wants " << cur_msg_size
                        << " bytes from policy throttler "
                        << connection->policy.throttler_bytes->get_current()
                        << "/" << connection->policy.throttler_bytes->get_max()
@@ -1571,7 +1602,7 @@ CtPtr ProtocolV2::throttle_dispatch_queue() {
   if (cur_msg_size) {
     if (!connection->dispatch_queue->dispatch_throttler.get_or_fail(
             cur_msg_size)) {
-      ldout(cct, 10)
+      ldout(cct, 1)
           << __func__ << " wants " << cur_msg_size
           << " bytes from dispatch throttle "
           << connection->dispatch_queue->dispatch_throttler.get_current() << "/"
@@ -1686,8 +1717,8 @@ CtPtr ProtocolV2::send_auth_request(std::vector<uint32_t> &allowed_methods) {
   ldout(cct, 20) << __func__ << " peer_type " << (int)connection->peer_type
 		 << " auth_client " << messenger->auth_client << dendl;
 
-  bufferlist bl;
-  vector<uint32_t> preferred_modes;
+  ceph::bufferlist bl;
+  std::vector<uint32_t> preferred_modes;
   auto am = auth_meta;
   connection->lock.unlock();
   int r = messenger->auth_client->get_auth_request(
@@ -1825,6 +1856,29 @@ CtPtr ProtocolV2::handle_auth_done(ceph::bufferlist &payload)
 }
 
 CtPtr ProtocolV2::finish_client_auth() {
+  if (HAVE_MSGR2_FEATURE(peer_supported_features, COMPRESSION)) {
+    return send_compression_request();
+  }
+
+  return start_session_connect();
+}
+
+CtPtr ProtocolV2::finish_server_auth() {
+  // server had sent AuthDone and client responded with correct pre-auth
+  // signature. 
+  // We can start conditioanl msgr protocol
+  if (HAVE_MSGR2_FEATURE(peer_supported_features, COMPRESSION)) {
+    state = COMPRESSION_ACCEPTING;
+  } else {
+    // No msgr protocol features to process
+    // we can start accepting new sessions/reconnects.
+    state = SESSION_ACCEPTING;
+  }
+
+  return CONTINUE(read_frame);
+}
+
+CtPtr ProtocolV2::start_session_connect() {
   if (!server_cookie) {
     ceph_assert(connect_seq == 0);
     state = SESSION_CONNECTING;
@@ -2084,6 +2138,40 @@ CtPtr ProtocolV2::handle_server_ident(ceph::bufferlist &payload)
   return ready();
 }
 
+CtPtr ProtocolV2::send_compression_request() {
+  state = COMPRESSION_CONNECTING;
+
+  const entity_type_t peer_type = connection->get_peer_type();
+  comp_meta.con_mode =
+    static_cast<Compressor::CompressionMode>(
+      messenger->comp_registry.get_mode(peer_type, auth_meta->is_mode_secure()));
+  const auto preferred_methods = messenger->comp_registry.get_methods(peer_type);
+  auto comp_req_frame = CompressionRequestFrame::Encode(comp_meta.is_compress(), preferred_methods);
+
+  INTERCEPT(19);
+  return WRITE(comp_req_frame, "compression request", read_frame);
+}
+
+CtPtr ProtocolV2::handle_compression_done(ceph::bufferlist &payload) {
+  if (state != COMPRESSION_CONNECTING) {
+    lderr(cct) << __func__ << " state changed!" << dendl;
+    return _fault();
+  }
+
+  auto response = CompressionDoneFrame::Decode(payload);
+  ldout(cct, 10) << __func__ << " CompressionDoneFrame(is_compress=" << response.is_compress()
+		 << ", method=" << response.method() << ")" << dendl;
+
+  comp_meta.con_method = static_cast<Compressor::CompressionAlgorithm>(response.method());
+  if (comp_meta.is_compress() != response.is_compress()) {
+    comp_meta.con_mode = Compressor::COMP_NONE;
+  }
+  session_compression_handlers = ceph::compression::onwire::rxtx_t::create_handler_pair(
+    cct, comp_meta, messenger->comp_registry.get_min_compression_size(connection->get_peer_type()));
+
+  return start_session_connect();
+}
+
 /* Server Protocol Methods */
 
 CtPtr ProtocolV2::start_server_banner_exchange() {
@@ -2145,12 +2233,12 @@ CtPtr ProtocolV2::_auth_bad_method(int r)
   return WRITE(bad_method, "bad auth method", read_frame);
 }
 
-CtPtr ProtocolV2::_handle_auth_request(bufferlist& auth_payload, bool more)
+CtPtr ProtocolV2::_handle_auth_request(ceph::bufferlist& auth_payload, bool more)
 {
   if (!messenger->auth_server) {
     return _fault();
   }
-  bufferlist reply;
+  ceph::bufferlist reply;
   auto am = auth_meta;
   connection->lock.unlock();
   int r = messenger->auth_server->handle_auth_request(
@@ -2247,10 +2335,8 @@ CtPtr ProtocolV2::handle_auth_signature(ceph::bufferlist &payload)
   }
 
   if (state == AUTH_ACCEPTING_SIGN) {
-    // server had sent AuthDone and client responded with correct pre-auth
-    // signature. we can start accepting new sessions/reconnects.
-    state = SESSION_ACCEPTING;
-    return CONTINUE(read_frame);
+    // this happened on server side
+    return finish_server_auth();
   } else if (state == AUTH_CONNECTING_SIGN) {
     // this happened at client side
     return finish_client_auth();
@@ -2524,7 +2610,7 @@ CtPtr ProtocolV2::handle_reconnect(ceph::bufferlist &payload)
 CtPtr ProtocolV2::handle_existing_connection(const AsyncConnectionRef& existing) {
   ldout(cct, 20) << __func__ << " existing=" << existing << dendl;
 
-  std::lock_guard<std::mutex> l(existing->lock);
+  std::unique_lock<std::mutex> l(existing->lock);
 
   ProtocolV2 *exproto = dynamic_cast<ProtocolV2 *>(existing->protocol.get());
   if (!exproto) {
@@ -2535,6 +2621,7 @@ CtPtr ProtocolV2::handle_existing_connection(const AsyncConnectionRef& existing)
   if (exproto->state == CLOSED) {
     ldout(cct, 1) << __func__ << " existing " << existing << " already closed."
                   << dendl;
+    l.unlock();
     return send_server_ident();
   }
 
@@ -2564,6 +2651,7 @@ CtPtr ProtocolV2::handle_existing_connection(const AsyncConnectionRef& existing)
         << dendl;
     existing->protocol->stop();
     existing->dispatch_queue->queue_reset(existing.get());
+    l.unlock();
     return send_server_ident();
   }
 
@@ -2642,14 +2730,11 @@ CtPtr ProtocolV2::reuse_connection(const AsyncConnectionRef& existing,
   exproto->pre_auth.enabled = false;
 
   if (!reconnecting) {
-    exproto->peer_supported_features = peer_supported_features;
-    exproto->tx_frame_asm.set_is_rev1(tx_frame_asm.get_is_rev1());
-    exproto->rx_frame_asm.set_is_rev1(rx_frame_asm.get_is_rev1());
-
     exproto->client_cookie = client_cookie;
     exproto->peer_name = peer_name;
     exproto->connection_features = connection_features;
     existing->set_features(connection_features);
+    exproto->peer_supported_features = peer_supported_features;
   }
   exproto->peer_global_seq = peer_global_seq;
 
@@ -2661,7 +2746,9 @@ CtPtr ProtocolV2::reuse_connection(const AsyncConnectionRef& existing,
   // this happens in the event center's thread as there should be
   // no user outside its boundaries (simlarly to e.g. outgoing_bl).
   auto temp_stream_handlers = std::move(session_stream_handlers);
+  auto temp_compression_handlers = std::move(session_compression_handlers);
   exproto->auth_meta = auth_meta;
+  exproto->comp_meta = comp_meta;
 
   ldout(messenger->cct, 5) << __func__ << " stop myself to swap existing"
                            << dendl;
@@ -2690,7 +2777,11 @@ CtPtr ProtocolV2::reuse_connection(const AsyncConnectionRef& existing,
         new_worker,
         new_center,
         exproto,
-        temp_stream_handlers=std::move(temp_stream_handlers)
+        reconnecting=reconnecting,
+        tx_is_rev1=tx_frame_asm.get_is_rev1(),
+        rx_is_rev1=rx_frame_asm.get_is_rev1(),
+        temp_stream_handlers=std::move(temp_stream_handlers),
+        temp_compression_handlers=std::move(temp_compression_handlers)
       ](ConnectedSocket &cs) mutable {
         // we need to delete time event in original thread
         {
@@ -2705,6 +2796,11 @@ CtPtr ProtocolV2::reuse_connection(const AsyncConnectionRef& existing,
           existing->outgoing_bl.clear();
           existing->open_write = false;
           exproto->session_stream_handlers = std::move(temp_stream_handlers);
+          exproto->session_compression_handlers = std::move(temp_compression_handlers);
+          if (!reconnecting) {
+            exproto->tx_frame_asm.set_is_rev1(tx_is_rev1);
+            exproto->rx_frame_asm.set_is_rev1(rx_is_rev1);
+          }
           existing->write_lock.unlock();
           if (exproto->state == NONE) {
             existing->shutdown_socket();
@@ -2892,3 +2988,46 @@ CtPtr ProtocolV2::send_reconnect_ok() {
 
   return WRITE(reconnect_ok, "reconnect ok", server_ready);
 }
+
+
+CtPtr ProtocolV2::handle_compression_request(ceph::bufferlist &payload) {
+  if (state != COMPRESSION_ACCEPTING) {
+    lderr(cct) << __func__ << " state changed!" << dendl;
+    return _fault();
+  }
+
+  auto request = CompressionRequestFrame::Decode(payload);
+  ldout(cct, 10) << __func__ << " CompressionRequestFrame(is_compress=" << request.is_compress()
+		 << ", preferred_methods=" << request.preferred_methods() << ")" << dendl;
+
+  const int peer_type = connection->get_peer_type();
+  if (Compressor::CompressionMode mode = messenger->comp_registry.get_mode(
+        peer_type, auth_meta->is_mode_secure());
+      mode != Compressor::COMP_NONE && request.is_compress()) {
+    comp_meta.con_method = messenger->comp_registry.pick_method(peer_type, request.preferred_methods());
+    ldout(cct, 10) << __func__ << " Compressor(pick_method=" 
+                   << Compressor::get_comp_alg_name(comp_meta.get_method())
+                   << ")" << dendl;
+    if (comp_meta.con_method != Compressor::COMP_ALG_NONE) {
+      comp_meta.con_mode = mode;
+    }
+  } else {
+    comp_meta.con_method = Compressor::COMP_ALG_NONE;
+  }
+  
+  auto response = CompressionDoneFrame::Encode(comp_meta.is_compress(), comp_meta.get_method());
+
+  INTERCEPT(20);
+  return WRITE(response, "compression done", finish_compression);
+}
+
+CtPtr ProtocolV2::finish_compression() {
+  // TODO: having a possibility to check whether we're server or client could
+  // allow reusing finish_compression().
+  
+  session_compression_handlers = ceph::compression::onwire::rxtx_t::create_handler_pair(
+    cct, comp_meta, messenger->comp_registry.get_min_compression_size(connection->get_peer_type()));
+
+  state = SESSION_ACCEPTING;
+  return CONTINUE(read_frame);
+}
diff --git a/src/msg/async/ProtocolV2.h b/src/msg/async/ProtocolV2.h
index d9a49d0e9d9..6441866fea4 100644
--- a/src/msg/async/ProtocolV2.h
+++ b/src/msg/async/ProtocolV2.h
@@ -6,6 +6,8 @@
 
 #include "Protocol.h"
 #include "crypto_onwire.h"
+#include "compression_meta.h"
+#include "compression_onwire.h"
 #include "frames_v2.h"
 
 class ProtocolV2 : public Protocol {
@@ -17,6 +19,7 @@ private:
     HELLO_CONNECTING,
     AUTH_CONNECTING,
     AUTH_CONNECTING_SIGN,
+    COMPRESSION_CONNECTING,
     SESSION_CONNECTING,
     SESSION_RECONNECTING,
     START_ACCEPT,
@@ -25,6 +28,7 @@ private:
     AUTH_ACCEPTING,
     AUTH_ACCEPTING_MORE,
     AUTH_ACCEPTING_SIGN,
+    COMPRESSION_ACCEPTING,
     SESSION_ACCEPTING,
     READY,
     THROTTLE_MESSAGE,
@@ -44,6 +48,7 @@ private:
                                       "HELLO_CONNECTING",
                                       "AUTH_CONNECTING",
                                       "AUTH_CONNECTING_SIGN",
+                                      "COMPRESSION_CONNECTING",
                                       "SESSION_CONNECTING",
                                       "SESSION_RECONNECTING",
                                       "START_ACCEPT",
@@ -52,6 +57,7 @@ private:
                                       "AUTH_ACCEPTING",
                                       "AUTH_ACCEPTING_MORE",
                                       "AUTH_ACCEPTING_SIGN",
+                                      "COMPRESSION_ACCEPTING",
                                       "SESSION_ACCEPTING",
                                       "READY",
                                       "THROTTLE_MESSAGE",
@@ -67,7 +73,9 @@ private:
 
   // TODO: move into auth_meta?
   ceph::crypto::onwire::rxtx_t session_stream_handlers;
-
+  ceph::compression::onwire::rxtx_t session_compression_handlers;
+  
+private:
   entity_name_t peer_name;
   State state;
   uint64_t peer_supported_features;  // CEPH_MSGR2_FEATURE_*
@@ -114,7 +122,8 @@ private:
   bool keepalive;
   bool write_in_progress = false;
 
-  ostream &_conn_prefix(std::ostream *_dout);
+  CompConnectionMeta comp_meta;
+  std::ostream& _conn_prefix(std::ostream *_dout);
   void run_continuation(Ct<ProtocolV2> *pcontinuation);
   void run_continuation(Ct<ProtocolV2> &continuation);
 
@@ -126,7 +135,7 @@ private:
 			F &frame);
   Ct<ProtocolV2> *write(const std::string &desc,
                         CONTINUATION_TYPE<ProtocolV2> &next,
-                        bufferlist &buffer);
+                        ceph::bufferlist &buffer);
 
   template <class F>
   bool append_frame(F& frame);
@@ -143,6 +152,7 @@ private:
   out_queue_entry_t _get_next_outgoing();
   ssize_t write_message(Message *m, bool more);
   void handle_message_ack(uint64_t seq);
+  void reset_compression();
 
   CONTINUATION_DECL(ProtocolV2, _wait_for_peer_banner);
   READ_BPTR_HANDLER_CONTINUATION_DECL(ProtocolV2, _handle_peer_banner);
@@ -162,10 +172,12 @@ private:
   CONTINUATION_DECL(ProtocolV2, throttle_message);
   CONTINUATION_DECL(ProtocolV2, throttle_bytes);
   CONTINUATION_DECL(ProtocolV2, throttle_dispatch_queue);
+  CONTINUATION_DECL(ProtocolV2, finish_compression);
 
   Ct<ProtocolV2> *read_frame();
   Ct<ProtocolV2> *finish_auth();
   Ct<ProtocolV2> *finish_client_auth();
+  Ct<ProtocolV2> *finish_server_auth();
   Ct<ProtocolV2> *handle_read_frame_preamble_main(rx_buffer_t &&buffer, int r);
   Ct<ProtocolV2> *read_frame_segment();
   Ct<ProtocolV2> *handle_read_frame_segment(rx_buffer_t &&rx_buffer, int r);
@@ -174,6 +186,7 @@ private:
   Ct<ProtocolV2> *_handle_read_frame_epilogue_main();
   Ct<ProtocolV2> *handle_read_frame_dispatch();
   Ct<ProtocolV2> *handle_frame_payload();
+  Ct<ProtocolV2> *finish_compression();
 
   Ct<ProtocolV2> *ready();
 
@@ -181,7 +194,6 @@ private:
   Ct<ProtocolV2> *throttle_message();
   Ct<ProtocolV2> *throttle_bytes();
   Ct<ProtocolV2> *throttle_dispatch_queue();
-  Ct<ProtocolV2> *read_message_data_prepare();
 
   Ct<ProtocolV2> *handle_keepalive2(ceph::bufferlist &payload);
   Ct<ProtocolV2> *handle_keepalive2_ack(ceph::bufferlist &payload);
@@ -222,6 +234,7 @@ private:
   Ct<ProtocolV2> *handle_auth_reply_more(ceph::bufferlist &payload);
   Ct<ProtocolV2> *handle_auth_done(ceph::bufferlist &payload);
   Ct<ProtocolV2> *handle_auth_signature(ceph::bufferlist &payload);
+  Ct<ProtocolV2> *start_session_connect();
   Ct<ProtocolV2> *send_client_ident();
   Ct<ProtocolV2> *send_reconnect();
   Ct<ProtocolV2> *handle_ident_missing_features(ceph::bufferlist &payload);
@@ -231,6 +244,9 @@ private:
   Ct<ProtocolV2> *handle_wait(ceph::bufferlist &payload);
   Ct<ProtocolV2> *handle_reconnect_ok(ceph::bufferlist &payload);
   Ct<ProtocolV2> *handle_server_ident(ceph::bufferlist &payload);
+  Ct<ProtocolV2> *send_compression_request();
+  Ct<ProtocolV2> *handle_compression_done(ceph::bufferlist &payload);
+
 
   // Server Protocol
   CONTINUATION_DECL(ProtocolV2, start_server_banner_exchange);
@@ -241,7 +257,7 @@ private:
   Ct<ProtocolV2> *post_server_banner_exchange();
   Ct<ProtocolV2> *handle_auth_request(ceph::bufferlist &payload);
   Ct<ProtocolV2> *handle_auth_request_more(ceph::bufferlist &payload);
-  Ct<ProtocolV2> *_handle_auth_request(bufferlist& auth_payload, bool more);
+  Ct<ProtocolV2> *_handle_auth_request(ceph::bufferlist& auth_payload, bool more);
   Ct<ProtocolV2> *_auth_bad_method(int r);
   Ct<ProtocolV2> *handle_client_ident(ceph::bufferlist &payload);
   Ct<ProtocolV2> *handle_ident_missing_features_write(int r);
@@ -252,6 +268,7 @@ private:
   Ct<ProtocolV2> *send_server_ident();
   Ct<ProtocolV2> *send_reconnect_ok();
   Ct<ProtocolV2> *server_ready();
+  Ct<ProtocolV2> *handle_compression_request(ceph::bufferlist &payload);
 
   size_t get_current_msg_size() const;
 };
diff --git a/src/msg/async/Stack.cc b/src/msg/async/Stack.cc
index eb5b628a79e..94a1bba5363 100644
--- a/src/msg/async/Stack.cc
+++ b/src/msg/async/Stack.cc
@@ -34,13 +34,10 @@
 #undef dout_prefix
 #define dout_prefix *_dout << "stack "
 
-std::function<void ()> NetworkStack::add_thread(unsigned worker_id)
+std::function<void ()> NetworkStack::add_thread(Worker* w)
 {
-  Worker *w = workers[worker_id];
   return [this, w]() {
-      char tp_name[16];
-      sprintf(tp_name, "msgr-worker-%u", w->id);
-      ceph_pthread_setname(pthread_self(), tp_name);
+      rename_thread(w->id);
       const unsigned EventMaxWaitUs = 30000000;
       w->center.set_owner();
       ldout(cct, 10) << __func__ << " starting" << dendl;
@@ -63,67 +60,54 @@ std::function<void ()> NetworkStack::add_thread(unsigned worker_id)
   };
 }
 
-std::shared_ptr<NetworkStack> NetworkStack::create(CephContext *c, const string &t)
+std::shared_ptr<NetworkStack> NetworkStack::create(CephContext *c,
+						   const std::string &t)
 {
+  std::shared_ptr<NetworkStack> stack = nullptr;
+
   if (t == "posix")
-    return std::make_shared<PosixNetworkStack>(c, t);
+    stack.reset(new PosixNetworkStack(c));
 #ifdef HAVE_RDMA
   else if (t == "rdma")
-    return std::make_shared<RDMAStack>(c, t);
+    stack.reset(new RDMAStack(c));
 #endif
 #ifdef HAVE_DPDK
   else if (t == "dpdk")
-    return std::make_shared<DPDKStack>(c, t);
+    stack.reset(new DPDKStack(c));
 #endif
 
-  lderr(c) << __func__ << " ms_async_transport_type " << t <<
+  if (stack == nullptr) {
+    lderr(c) << __func__ << " ms_async_transport_type " << t <<
     " is not supported! " << dendl;
-  ceph_abort();
-  return nullptr;
-}
-
-Worker* NetworkStack::create_worker(CephContext *c, const string &type, unsigned worker_id)
-{
-  if (type == "posix")
-    return new PosixWorker(c, worker_id);
-#ifdef HAVE_RDMA
-  else if (type == "rdma")
-    return new RDMAWorker(c, worker_id);
-#endif
-#ifdef HAVE_DPDK
-  else if (type == "dpdk")
-    return new DPDKWorker(c, worker_id);
-#endif
-
-  lderr(c) << __func__ << " ms_async_transport_type " << type <<
-    " is not supported! " << dendl;
-  ceph_abort();
-  return nullptr;
-}
-
-NetworkStack::NetworkStack(CephContext *c, const string &t): type(t), started(false), cct(c)
-{
-  ceph_assert(cct->_conf->ms_async_op_threads > 0);
-
-  const int InitEventNumber = 5000;
-  num_workers = cct->_conf->ms_async_op_threads;
+    ceph_abort();
+    return nullptr;
+  }
+  
+  unsigned num_workers = c->_conf->ms_async_op_threads;
+  ceph_assert(num_workers > 0);
   if (num_workers >= EventCenter::MAX_EVENTCENTER) {
-    ldout(cct, 0) << __func__ << " max thread limit is "
+    ldout(c, 0) << __func__ << " max thread limit is "
                   << EventCenter::MAX_EVENTCENTER << ", switching to this now. "
                   << "Higher thread values are unnecessary and currently unsupported."
                   << dendl;
     num_workers = EventCenter::MAX_EVENTCENTER;
   }
-
+  const int InitEventNumber = 5000;
   for (unsigned worker_id = 0; worker_id < num_workers; ++worker_id) {
-    Worker *w = create_worker(cct, type, worker_id);
-    int ret = w->center.init(InitEventNumber, worker_id, type);
+    Worker *w = stack->create_worker(c, worker_id);
+    int ret = w->center.init(InitEventNumber, worker_id, t);
     if (ret)
       throw std::system_error(-ret, std::generic_category());
-    workers.push_back(w);
+    stack->workers.push_back(w);
   }
+
+  return stack;
 }
 
+NetworkStack::NetworkStack(CephContext *c)
+  : cct(c)
+{}
+
 void NetworkStack::start()
 {
   std::unique_lock<decltype(pool_spin)> lk(pool_spin);
@@ -132,17 +116,17 @@ void NetworkStack::start()
     return ;
   }
 
-  for (unsigned i = 0; i < num_workers; ++i) {
-    if (workers[i]->is_init())
+  for (Worker* worker : workers) {
+    if (worker->is_init())
       continue;
-    std::function<void ()> thread = add_thread(i);
-    spawn_worker(i, std::move(thread));
+    spawn_worker(add_thread(worker));
   }
   started = true;
   lk.unlock();
 
-  for (unsigned i = 0; i < num_workers; ++i)
-    workers[i]->wait_for_init();
+  for (Worker* worker : workers) {
+    worker->wait_for_init();
+  }
 }
 
 Worker* NetworkStack::get_worker()
@@ -157,10 +141,10 @@ Worker* NetworkStack::get_worker()
   // find worker with least references
   // tempting case is returning on references == 0, but in reality
   // this will happen so rarely that there's no need for special case.
-  for (unsigned i = 0; i < num_workers; ++i) {
-    unsigned worker_load = workers[i]->references.load();
+  for (Worker* worker : workers) {
+    unsigned worker_load = worker->references.load();
     if (worker_load < min_load) {
-      current_best = workers[i];
+      current_best = worker;
       min_load = worker_load;
     }
   }
@@ -174,10 +158,11 @@ Worker* NetworkStack::get_worker()
 void NetworkStack::stop()
 {
   std::lock_guard lk(pool_spin);
-  for (unsigned i = 0; i < num_workers; ++i) {
-    workers[i]->done = true;
-    workers[i]->center.wakeup();
-    join_worker(i);
+  unsigned i = 0;
+  for (Worker* worker : workers) {
+    worker->done = true;
+    worker->center.wakeup();
+    join_worker(i++);
   }
   started = false;
 }
@@ -206,10 +191,10 @@ void NetworkStack::drain()
   ldout(cct, 30) << __func__ << " started." << dendl;
   pthread_t cur = pthread_self();
   pool_spin.lock();
-  C_drain drain(num_workers);
-  for (unsigned i = 0; i < num_workers; ++i) {
-    ceph_assert(cur != workers[i]->center.get_owner());
-    workers[i]->center.dispatch_event_external(EventCallbackRef(&drain));
+  C_drain drain(get_num_worker());
+  for (Worker* worker : workers) {
+    ceph_assert(cur != worker->center.get_owner());
+    worker->center.dispatch_event_external(EventCallbackRef(&drain));
   }
   pool_spin.unlock();
   drain.wait();
diff --git a/src/msg/async/Stack.h b/src/msg/async/Stack.h
index 37a33163d6b..376a87c7268 100644
--- a/src/msg/async/Stack.h
+++ b/src/msg/async/Stack.h
@@ -28,10 +28,11 @@ class ConnectedSocketImpl {
   virtual ~ConnectedSocketImpl() {}
   virtual int is_connected() = 0;
   virtual ssize_t read(char*, size_t) = 0;
-  virtual ssize_t send(bufferlist &bl, bool more) = 0;
+  virtual ssize_t send(ceph::buffer::list &bl, bool more) = 0;
   virtual void shutdown() = 0;
   virtual void close() = 0;
   virtual int fd() const = 0;
+  virtual void set_priority(int sd, int prio, int domain) = 0;
 };
 
 class ConnectedSocket;
@@ -96,7 +97,7 @@ class ConnectedSocket {
   /// Gets the output stream.
   ///
   /// Gets an object that sends data to the remote endpoint.
-  ssize_t send(bufferlist &bl, bool more) {
+  ssize_t send(ceph::buffer::list &bl, bool more) {
     return _csi->send(bl, more);
   }
   /// Disables output to the socket.
@@ -123,6 +124,10 @@ class ConnectedSocket {
     return _csi->fd();
   }
 
+  void set_priority(int sd, int prio, int domain) {
+    _csi->set_priority(sd, prio, domain);
+  }
+
   explicit operator bool() const {
     return _csi.get();
   }
@@ -203,6 +208,9 @@ enum {
   l_msgr_send_messages_queue_lat,
   l_msgr_handle_ack_lat,
 
+  l_msgr_recv_encrypted_bytes,
+  l_msgr_send_encrypted_bytes,
+
   l_msgr_last,
 };
 
@@ -246,6 +254,9 @@ class Worker {
     plb.add_time_avg(l_msgr_send_messages_queue_lat, "msgr_send_messages_queue_lat", "Network sent messages lat");
     plb.add_time_avg(l_msgr_handle_ack_lat, "msgr_handle_ack_lat", "Connection handle ack lat");
 
+    plb.add_u64_counter(l_msgr_recv_encrypted_bytes, "msgr_recv_encrypted_bytes", "Network received encrypted bytes", NULL, 0, unit_t(UNIT_BYTES));
+    plb.add_u64_counter(l_msgr_send_encrypted_bytes, "msgr_send_encrypted_bytes", "Network sent encrypted bytes", NULL, 0, unit_t(UNIT_BYTES));
+
     perf_logger = plb.create_perf_counters();
     cct->get_perfcounters_collection()->add(perf_logger);
   }
@@ -293,18 +304,24 @@ class Worker {
 };
 
 class NetworkStack {
-  std::string type;
-  unsigned num_workers = 0;
   ceph::spinlock pool_spin;
   bool started = false;
 
-  std::function<void ()> add_thread(unsigned i);
+  std::function<void ()> add_thread(Worker* w);
+
+  virtual Worker* create_worker(CephContext *c, unsigned i) = 0;
+  virtual void rename_thread(unsigned id) {
+    static constexpr int TASK_COMM_LEN = 16;
+    char tp_name[TASK_COMM_LEN];
+    sprintf(tp_name, "msgr-worker-%u", id);
+    ceph_pthread_setname(pthread_self(), tp_name);
+  }
 
  protected:
   CephContext *cct;
-  vector<Worker*> workers;
+  std::vector<Worker*> workers;
 
-  explicit NetworkStack(CephContext *c, const string &t);
+  explicit NetworkStack(CephContext *c);
  public:
   NetworkStack(const NetworkStack &) = delete;
   NetworkStack& operator=(const NetworkStack &) = delete;
@@ -314,10 +331,8 @@ class NetworkStack {
   }
 
   static std::shared_ptr<NetworkStack> create(
-          CephContext *c, const string &type);
+    CephContext *c, const std::string &type);
 
-  static Worker* create_worker(
-          CephContext *c, const string &t, unsigned i);
   // backend need to override this method if backend doesn't support shared
   // listen table.
   // For example, posix backend has in kernel global listen table. If one
@@ -335,11 +350,11 @@ class NetworkStack {
   }
   void drain();
   unsigned get_num_worker() const {
-    return num_workers;
+    return workers.size();
   }
 
   // direct is used in tests only
-  virtual void spawn_worker(unsigned i, std::function<void ()> &&) = 0;
+  virtual void spawn_worker(std::function<void ()> &&) = 0;
   virtual void join_worker(unsigned i) = 0;
 
   virtual bool is_ready() { return true; };
diff --git a/src/msg/async/compression_meta.h b/src/msg/async/compression_meta.h
new file mode 100644
index 00000000000..404e04bec65
--- /dev/null
+++ b/src/msg/async/compression_meta.h
@@ -0,0 +1,21 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+
+#include "compressor/Compressor.h"
+
+struct CompConnectionMeta {
+  TOPNSPC::Compressor::CompressionMode con_mode =
+    TOPNSPC::Compressor::COMP_NONE;  // negotiated mode
+  TOPNSPC::Compressor::CompressionAlgorithm con_method =
+    TOPNSPC::Compressor::COMP_ALG_NONE; // negotiated method
+
+  bool is_compress() const {
+    return con_mode != TOPNSPC::Compressor::COMP_NONE;
+  }
+  TOPNSPC::Compressor::CompressionAlgorithm get_method() const {
+    return con_method;
+  }
+  TOPNSPC::Compressor::CompressionMode get_mode() const {
+    return con_mode;
+  }
+};
diff --git a/src/msg/async/compression_onwire.cc b/src/msg/async/compression_onwire.cc
new file mode 100644
index 00000000000..9e6d07cfd19
--- /dev/null
+++ b/src/msg/async/compression_onwire.cc
@@ -0,0 +1,86 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+
+#include "compression_onwire.h"
+#include "compression_meta.h"
+#include "common/dout.h"
+
+#define dout_subsys ceph_subsys_ms
+
+namespace ceph::compression::onwire {
+
+rxtx_t rxtx_t::create_handler_pair(
+    CephContext* ctx,
+    const CompConnectionMeta& comp_meta,
+    std::uint64_t compress_min_size)
+{
+  if (comp_meta.is_compress()) {
+     CompressorRef compressor = Compressor::create(ctx, comp_meta.get_method());
+    if (compressor) {
+      return {std::make_unique<RxHandler>(ctx, compressor),
+	      std::make_unique<TxHandler>(ctx, compressor,
+					  comp_meta.get_mode(),
+					  compress_min_size)};
+    }
+  }
+  return {};
+}
+
+std::optional<ceph::bufferlist> TxHandler::compress(const ceph::bufferlist &input)
+{
+  if (m_init_onwire_size < m_min_size) {
+    ldout(m_cct, 20) << __func__ 
+		     << " discovered frame that is smaller than threshold, aborting compression"
+		     << dendl;
+    return {};
+  }
+
+  m_compress_potential -= input.length();
+
+  ceph::bufferlist out;
+  if (input.length() == 0) {
+    ldout(m_cct, 20) << __func__ 
+		     << " discovered an empty segment, skipping compression without aborting"
+		     << dendl;
+    out.clear();
+    return out;
+  }
+
+  std::optional<int32_t> compressor_message;
+  if (m_compressor->compress(input, out, compressor_message)) {
+    return {};
+  } else {
+    ldout(m_cct, 20) << __func__ << " uncompressed.length()=" << input.length()
+                     << " compressed.length()=" << out.length() << dendl;
+    m_onwire_size += out.length();
+    return out;
+  }
+}
+
+std::optional<ceph::bufferlist> RxHandler::decompress(const ceph::bufferlist &input)
+{
+  ceph::bufferlist out;
+  if (input.length() == 0) {
+    ldout(m_cct, 20) << __func__
+		     << " discovered an empty segment, skipping decompression without aborting"
+		     << dendl;
+    out.clear();
+    return out;
+  }
+
+  std::optional<int32_t> compressor_message;
+  if (m_compressor->decompress(input, out, compressor_message)) {
+    return {};
+  } else {
+    ldout(m_cct, 20) << __func__ << " compressed.length()=" << input.length()
+                     << " uncompressed.length()=" << out.length() << dendl;
+    return out;
+  }
+}
+
+void TxHandler::done()
+{
+  ldout(m_cct, 25) << __func__ << " compression ratio=" << get_ratio() << dendl;
+}
+
+} // namespace ceph::compression::onwire
diff --git a/src/msg/async/compression_onwire.h b/src/msg/async/compression_onwire.h
new file mode 100644
index 00000000000..dcd6d26c4ca
--- /dev/null
+++ b/src/msg/async/compression_onwire.h
@@ -0,0 +1,104 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+
+#ifndef CEPH_COMPRESSION_ONWIRE_H
+#define CEPH_COMPRESSION_ONWIRE_H
+
+#include <optional>
+
+#include "compressor/Compressor.h"
+#include "include/buffer.h"
+
+class CompConnectionMeta;
+
+namespace ceph::compression::onwire {
+  using Compressor = TOPNSPC::Compressor;
+  using CompressorRef = TOPNSPC::CompressorRef;
+
+  class Handler {
+  public:
+    Handler(CephContext* const cct, CompressorRef compressor)
+      : m_cct(cct), m_compressor(compressor) {}
+
+  protected:
+    CephContext* const m_cct;
+    CompressorRef m_compressor;
+  };
+
+  class RxHandler final : private Handler {
+  public:
+    RxHandler(CephContext* const cct, CompressorRef compressor)
+      : Handler(cct, compressor) {}
+    ~RxHandler() {};
+
+    /**
+     * Decompresses a bufferlist 
+     *
+     * @param input compressed bufferlist
+     * @param out decompressed bufferlist
+     *
+     * @returns true on success, false on failure
+     */
+    std::optional<ceph::bufferlist> decompress(const ceph::bufferlist &input);
+  };
+
+  class TxHandler final : private Handler {
+  public:
+    TxHandler(CephContext* const cct, CompressorRef compressor, int mode, std::uint64_t min_size)
+      : Handler(cct, compressor),
+	m_min_size(min_size),
+	m_mode(static_cast<Compressor::CompressionMode>(mode))
+    {}
+    ~TxHandler() {}
+
+    void reset_handler(int num_segments, uint64_t size) {
+      m_init_onwire_size = size;
+      m_compress_potential = size;
+      m_onwire_size = 0;
+    }
+
+    void done();
+
+    /**
+     * Compresses a bufferlist 
+     *
+     * @param input bufferlist to compress
+     * @param out compressed bufferlist
+     *
+     * @returns true on success, false on failure
+     */
+    std::optional<ceph::bufferlist> compress(const ceph::bufferlist &input);
+
+    double get_ratio() const {
+      return get_initial_size() / (double) get_final_size();
+    }
+
+    uint64_t get_initial_size() const {
+      return m_init_onwire_size;
+    } 
+
+    uint64_t get_final_size() const {
+      return m_onwire_size;
+    }
+
+  private:
+    uint64_t m_min_size; 
+    Compressor::CompressionMode m_mode;
+
+    uint64_t m_init_onwire_size;
+    uint64_t m_onwire_size;
+    uint64_t m_compress_potential;
+  };
+
+  struct rxtx_t {
+    std::unique_ptr<RxHandler> rx;
+    std::unique_ptr<TxHandler> tx;
+
+    static rxtx_t create_handler_pair(
+      CephContext* ctx,
+      const CompConnectionMeta& comp_meta,
+      std::uint64_t compress_min_size);
+  };
+}
+
+#endif // CEPH_COMPRESSION_ONWIRE_H
diff --git a/src/msg/async/crypto_onwire.cc b/src/msg/async/crypto_onwire.cc
index 4e42340603e..615820b35ba 100644
--- a/src/msg/async/crypto_onwire.cc
+++ b/src/msg/async/crypto_onwire.cc
@@ -68,8 +68,8 @@ public:
   }
 
   ~AES128GCM_OnWireTxHandler() override {
-    ::ceph::crypto::zeroize_for_security(&nonce, sizeof(nonce));
-    ::ceph::crypto::zeroize_for_security(&initial_nonce, sizeof(initial_nonce));
+    ::TOPNSPC::crypto::zeroize_for_security(&nonce, sizeof(nonce));
+    ::TOPNSPC::crypto::zeroize_for_security(&initial_nonce, sizeof(initial_nonce));
   }
 
   void reset_tx_handler(const uint32_t* first, const uint32_t* last) override;
@@ -162,7 +162,6 @@ ceph::bufferlist AES128GCM_OnWireTxHandler::authenticated_encrypt_final()
 
 // RX PART
 class AES128GCM_OnWireRxHandler : public ceph::crypto::onwire::RxHandler {
-  CephContext* const cct;
   std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)> ectx;
   nonce_t nonce;
   bool new_nonce_format;  // 64-bit counter?
@@ -173,8 +172,7 @@ public:
 			    const key_t& key,
 			    const nonce_t& nonce,
 			    bool new_nonce_format)
-    : cct(cct),
-      ectx(EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free),
+    : ectx(EVP_CIPHER_CTX_new(), EVP_CIPHER_CTX_free),
       nonce(nonce), new_nonce_format(new_nonce_format) {
     ceph_assert_always(ectx);
     ceph_assert_always(key.size() * CHAR_BIT == 128);
@@ -191,7 +189,7 @@ public:
   }
 
   ~AES128GCM_OnWireRxHandler() override {
-    ::ceph::crypto::zeroize_for_security(&nonce, sizeof(nonce));
+    ::TOPNSPC::crypto::zeroize_for_security(&nonce, sizeof(nonce));
   }
 
   std::uint32_t get_extra_size_at_final() override {
diff --git a/src/msg/async/dpdk/ARP.cc b/src/msg/async/dpdk/ARP.cc
index dedc9e3c7aa..f73eed40c28 100644
--- a/src/msg/async/dpdk/ARP.cc
+++ b/src/msg/async/dpdk/ARP.cc
@@ -48,9 +48,9 @@ arp::arp(interface* netif):
     )
 {}
 
-Tub<l3_protocol::l3packet> arp::get_packet()
+std::optional<l3_protocol::l3packet> arp::get_packet()
 {
-  Tub<l3_protocol::l3packet> p;
+  std::optional<l3_protocol::l3packet> p;
   if (!_packetq.empty()) {
     p = std::move(_packetq.front());
     _packetq.pop_front();
diff --git a/src/msg/async/dpdk/ARP.h b/src/msg/async/dpdk/ARP.h
index 5456956480a..e2f6dfe98fe 100644
--- a/src/msg/async/dpdk/ARP.h
+++ b/src/msg/async/dpdk/ARP.h
@@ -85,7 +85,7 @@ class arp {
   ethernet_address l2self() { return _netif->hw_address(); }
   int process_packet(Packet p, ethernet_address from);
   bool forward(forward_hash& out_hash_data, Packet& p, size_t off);
-  Tub<l3_protocol::l3packet> get_packet();
+  std::optional<l3_protocol::l3packet> get_packet();
   template <class l3_proto>
   friend class arp_for;
 };
diff --git a/src/msg/async/dpdk/DPDK.cc b/src/msg/async/dpdk/DPDK.cc
index ff496788810..a10c6ec96ae 100644
--- a/src/msg/async/dpdk/DPDK.cc
+++ b/src/msg/async/dpdk/DPDK.cc
@@ -29,6 +29,7 @@
 #include <rte_eal.h>
 #include <rte_pci.h>
 #include <rte_ethdev.h>
+#include <rte_ether.h>
 #include <rte_cycles.h>
 #include <rte_memzone.h>
 
@@ -54,10 +55,6 @@ void* as_cookie(struct rte_pktmbuf_pool_private& p) {
   return &p;
 };
 
-#ifndef MARKER
-typedef void    *MARKER[0];   /**< generic marker for a point in a structure */
-#endif
-
 /******************* Net device related constatns *****************************/
 static constexpr uint16_t default_ring_size      = 512;
 
@@ -235,9 +232,11 @@ int DPDKDevice::init_port_start()
     } else if (_dev_info.hash_key_size == 52) {
       _rss_key = default_rsskey_52bytes;
     } else if (_dev_info.hash_key_size != 0) {
-      rte_exit(EXIT_FAILURE,
-               "Port %d: We support only 40 or 52 bytes RSS hash keys, %d bytes key requested",
-               _port_idx, _dev_info.hash_key_size);
+      lderr(cct) << "Port " << int(_port_idx)
+	         << ": We support only 40 or 52 bytes RSS hash keys, "
+	         << int(_dev_info.hash_key_size) << " bytes key requested"
+	         << dendl;
+      return -EINVAL;
     } else {
       _rss_key = default_rsskey_40bytes;
       _dev_info.hash_key_size = 40;
@@ -311,7 +310,10 @@ int DPDKDevice::init_port_start()
   }
 
   // TSO is supported starting from DPDK v1.8
-  if (_dev_info.tx_offload_capa & DEV_TX_OFFLOAD_TCP_TSO) {
+  // TSO is abnormal in some DPDK versions (eg.dpdk-20.11-3.e18.aarch64), try
+  // disable TSO by ms_dpdk_enable_tso=false
+  if ((_dev_info.tx_offload_capa & DEV_TX_OFFLOAD_TCP_TSO) &&
+       cct->_conf.get_val<bool>("ms_dpdk_enable_tso")) {
     ldout(cct, 1) << __func__ << " TSO is supported" << dendl;
     _hw_features.tx_tso = 1;
   }
@@ -393,6 +395,23 @@ not_supported:
   ldout(cct, 1) << __func__ << " port " << int(_port_idx) << ": changing HW FC settings is not supported" << dendl;
 }
 
+class XstatSocketHook : public AdminSocketHook {
+  DPDKDevice *dev;
+ public:
+  explicit XstatSocketHook(DPDKDevice *dev) : dev(dev) {}
+  int call(std::string_view prefix, const cmdmap_t& cmdmap,
+           Formatter *f,
+           std::ostream& ss,
+           bufferlist& out) override {
+    if (prefix == "show_pmd_stats") {
+      dev->nic_stats_dump(f);
+    } else if (prefix == "show_pmd_xstats") {
+      dev->nic_xstats_dump(f);
+    }
+    return 0;
+  }
+};
+
 int DPDKDevice::init_port_fini()
 {
   // Changing FC requires HW reset, so set it before the port is initialized.
@@ -413,6 +432,14 @@ int DPDKDevice::init_port_fini()
   }
 
   ldout(cct, 5) << __func__ << " created DPDK device" << dendl;
+  AdminSocket *admin_socket = cct->get_admin_socket();
+  dfx_hook = std::make_unique<XstatSocketHook>(this);
+  int r = admin_socket->register_command("show_pmd_stats", dfx_hook.get(),
+                                         "show pmd stats statistics");
+  ceph_assert(r == 0);
+  r = admin_socket->register_command("show_pmd_xstats", dfx_hook.get(),
+                                   "show pmd xstats statistics");
+  ceph_assert(r == 0);
   return 0;
 }
 
@@ -467,7 +494,7 @@ void DPDKQueuePair::configure_proxies(const std::map<unsigned, float>& cpu_weigh
     return;
   }
   register_packet_provider([this] {
-    Tub<Packet> p;
+    std::optional<Packet> p;
     if (!_proxy_packetq.empty()) {
       p = std::move(_proxy_packetq.front());
       _proxy_packetq.pop_front();
@@ -645,6 +672,92 @@ DPDKQueuePair::DPDKQueuePair(CephContext *c, EventCenter *cen, DPDKDevice* dev,
     device_stat_time_fd = center->create_time_event(1000*1000, new C_handle_dev_stats(this));
 }
 
+void DPDKDevice::nic_stats_dump(Formatter *f)
+{
+  static uint64_t prev_pkts_rx[RTE_MAX_ETHPORTS];
+  static uint64_t prev_pkts_tx[RTE_MAX_ETHPORTS];
+  static uint64_t prev_cycles[RTE_MAX_ETHPORTS];
+  size_t tx_fragments = 0;
+  size_t rx_fragments = 0;
+  size_t tx_free_cnt = 0;
+  size_t rx_free_cnt = 0;
+
+  for (auto &qp: _queues) {
+    tx_fragments += qp->perf_logger->get(l_dpdk_qp_tx_fragments);
+    rx_fragments += qp->perf_logger->get(l_dpdk_qp_rx_fragments);
+    tx_free_cnt += qp->_tx_buf_factory.ring_size();
+    rx_free_cnt += rte_mempool_avail_count(qp->_pktmbuf_pool_rx);
+  }
+  struct rte_eth_stats stats;
+  rte_eth_stats_get(_port_idx, &stats);
+  f->open_object_section("RX");
+  f->dump_unsigned("in_packets", stats.ipackets);
+  f->dump_unsigned("recv_packets", rx_fragments);
+  f->dump_unsigned("in_bytes", stats.ibytes);
+  f->dump_unsigned("missed", stats.imissed);
+  f->dump_unsigned("errors", stats.ierrors);
+  f->close_section();
+
+  f->open_object_section("TX");
+  f->dump_unsigned("out_packets", stats.opackets);
+  f->dump_unsigned("send_packets", tx_fragments);
+  f->dump_unsigned("out_bytes", stats.obytes);
+  f->dump_unsigned("errors", stats.oerrors);
+  f->close_section();
+
+  f->open_object_section("stats");
+  f->dump_unsigned("RX_nombuf", stats.rx_nombuf);
+  f->dump_unsigned("RX_avail_mbufs", rx_free_cnt);
+  f->dump_unsigned("TX_avail_mbufs", tx_free_cnt);
+
+  uint64_t diff_cycles = prev_cycles[_port_idx];
+  prev_cycles[_port_idx] = rte_rdtsc();
+  if (diff_cycles > 0) {
+    diff_cycles = prev_cycles[_port_idx] - diff_cycles;
+  }
+
+  uint64_t diff_pkts_rx = (stats.ipackets > prev_pkts_rx[_port_idx]) ?
+	         (stats.ipackets - prev_pkts_rx[_port_idx]) : 0;
+  uint64_t diff_pkts_tx = (stats.opackets > prev_pkts_tx[_port_idx]) ?
+	         (stats.opackets - prev_pkts_tx[_port_idx]) : 0;
+  prev_pkts_rx[_port_idx] = stats.ipackets;
+  prev_pkts_tx[_port_idx] = stats.opackets;
+  uint64_t mpps_rx = diff_cycles > 0 ? diff_pkts_rx * rte_get_tsc_hz() / diff_cycles : 0;
+  uint64_t mpps_tx = diff_cycles > 0 ? diff_pkts_tx * rte_get_tsc_hz() / diff_cycles : 0;
+  f->dump_unsigned("Rx_pps", mpps_rx);
+  f->dump_unsigned("Tx_pps", mpps_tx);
+  f->close_section();
+}
+
+void DPDKDevice::nic_xstats_dump(Formatter *f)
+{
+  // Get count
+  int cnt_xstats = rte_eth_xstats_get_names(_port_idx, NULL, 0);
+  if (cnt_xstats < 0) {
+    ldout(cct, 1) << "Error: Cannot get count of xstats" << dendl;
+    return;
+  }
+ 
+  // Get id-name lookup table
+  std::vector<struct rte_eth_xstat_name> xstats_names(cnt_xstats);
+  if (cnt_xstats != rte_eth_xstats_get_names(_port_idx, xstats_names.data(), cnt_xstats)) {
+    ldout(cct, 1) << "Error: Cannot get xstats lookup" << dendl;
+    return;
+  }
+
+  // Get stats themselves
+  std::vector<struct rte_eth_xstat> xstats(cnt_xstats);
+  if (cnt_xstats != rte_eth_xstats_get(_port_idx, xstats.data(), cnt_xstats)) {
+    ldout(cct, 1) << "Error: Unable to get xstats" << dendl;
+    return;
+  }
+  f->open_object_section("xstats");
+  for (int i = 0; i < cnt_xstats; i++){
+    f->dump_unsigned(xstats_names[i].name, xstats[i].value);
+  }
+  f->close_section();
+}
+
 void DPDKQueuePair::handle_stats()
 {
   ldout(cct, 20) << __func__ << " started." << dendl;
@@ -716,7 +829,7 @@ bool DPDKQueuePair::poll_tx() {
   return false;
 }
 
-inline Tub<Packet> DPDKQueuePair::from_mbuf_lro(rte_mbuf* m)
+inline std::optional<Packet> DPDKQueuePair::from_mbuf_lro(rte_mbuf* m)
 {
   _frags.clear();
   _bufs.clear();
@@ -736,7 +849,7 @@ inline Tub<Packet> DPDKQueuePair::from_mbuf_lro(rte_mbuf* m)
       _frags.begin(), _frags.end(), make_deleter(std::move(del)));
 }
 
-inline Tub<Packet> DPDKQueuePair::from_mbuf(rte_mbuf* m)
+inline std::optional<Packet> DPDKQueuePair::from_mbuf(rte_mbuf* m)
 {
   _rx_free_pkts.push_back(m);
   _num_rx_free_segs += m->nb_segs;
@@ -824,7 +937,7 @@ void DPDKQueuePair::process_packets(
     struct rte_mbuf *m = bufs[i];
     offload_info oi;
 
-    Tub<Packet> p = from_mbuf(m);
+    std::optional<Packet> p = from_mbuf(m);
 
     // Drop the packet if translation above has failed
     if (!p) {
@@ -1027,14 +1140,14 @@ void DPDKQueuePair::tx_buf::set_cluster_offload_info(const Packet& p, const DPDK
   if (oi.needs_ip_csum) {
     head->ol_flags |= PKT_TX_IP_CKSUM;
     // TODO: Take a VLAN header into an account here
-    head->l2_len = sizeof(struct ether_hdr);
+    head->l2_len = sizeof(struct rte_ether_hdr);
     head->l3_len = oi.ip_hdr_len;
   }
   if (qp.port().get_hw_features().tx_csum_l4_offload) {
     if (oi.protocol == ip_protocol_num::tcp) {
       head->ol_flags |= PKT_TX_TCP_CKSUM;
       // TODO: Take a VLAN header into an account here
-      head->l2_len = sizeof(struct ether_hdr);
+      head->l2_len = sizeof(struct rte_ether_hdr);
       head->l3_len = oi.ip_hdr_len;
 
       if (oi.tso_seg_size) {
@@ -1253,7 +1366,7 @@ std::unique_ptr<DPDKDevice> create_dpdk_net_device(
 {
   // Check that we have at least one DPDK-able port
   if (rte_eth_dev_count_avail() == 0) {
-    rte_exit(EXIT_FAILURE, "No Ethernet ports - bye\n");
+    ceph_assert(false && "No Ethernet ports - bye\n");
   } else {
     ldout(cct, 10) << __func__ << " ports number: " << int(rte_eth_dev_count_avail()) << dendl;
   }
diff --git a/src/msg/async/dpdk/DPDK.h b/src/msg/async/dpdk/DPDK.h
index 78a1a076932..ec1d707ffcc 100644
--- a/src/msg/async/dpdk/DPDK.h
+++ b/src/msg/async/dpdk/DPDK.h
@@ -23,17 +23,19 @@
 #ifndef CEPH_DPDK_DEV_H
 #define CEPH_DPDK_DEV_H
 
-#include <memory>
 #include <functional>
+#include <memory>
+#include <optional>
 #include <rte_config.h>
 #include <rte_common.h>
 #include <rte_ethdev.h>
+#include <rte_ether.h>
 #include <rte_malloc.h>
 #include <rte_version.h>
 
 #include "include/page.h"
-#include "common/Tub.h"
 #include "common/perf_counters.h"
+#include "common/admin_socket.h"
 #include "msg/async/Event.h"
 #include "const.h"
 #include "circular_buffer.h"
@@ -43,7 +45,6 @@
 #include "net.h"
 #include "toeplitz.h"
 
-
 struct free_deleter {
   void operator()(void* p) { ::free(p); }
 };
@@ -85,8 +86,13 @@ enum {
 class DPDKDevice;
 class DPDKWorker;
 
+
+#ifndef MARKER
+typedef void    *MARKER[0];   /**< generic marker for a point in a structure */
+#endif
+
 class DPDKQueuePair {
-  using packet_provider_type = std::function<Tub<Packet> ()>;
+  using packet_provider_type = std::function<std::optional<Packet> ()>;
  public:
   void configure_proxies(const std::map<unsigned, float>& cpu_weights);
   // build REdirection TAble for cpu_weights map: target cpu -> weight
@@ -347,7 +353,7 @@ class DPDKQueuePair {
    public:
     tx_buf(tx_buf_factory& fc) : _fc(fc) {
 
-      _buf_physaddr = _mbuf.buf_physaddr;
+      _buf_physaddr = _mbuf.buf_iova;
       _data_off     = _mbuf.data_off;
     }
 
@@ -360,7 +366,7 @@ class DPDKQueuePair {
 
       // Set the mbuf to point to our data
       _mbuf.buf_addr           = va;
-      _mbuf.buf_physaddr       = pa;
+      _mbuf.buf_iova           = pa;
       _mbuf.data_off           = 0;
       _is_zc                   = true;
     }
@@ -378,14 +384,14 @@ class DPDKQueuePair {
         // to call the "packet"'s destructor and reset the
         // "optional" state to "nonengaged".
         //
-        _p.destroy();
+        _p.reset();
 
       } else if (!_is_zc) {
         return;
       }
 
       // Restore the rte_mbuf fields we trashed in set_zc_info()
-      _mbuf.buf_physaddr = _buf_physaddr;
+      _mbuf.buf_iova     = _buf_physaddr;
       _mbuf.buf_addr     = rte_mbuf_to_baddr(&_mbuf);
       _mbuf.data_off     = _data_off;
 
@@ -410,7 +416,7 @@ class DPDKQueuePair {
    private:
     struct rte_mbuf _mbuf;
     MARKER private_start;
-    Tub<Packet> _p;
+    std::optional<Packet> _p;
     phys_addr_t _buf_physaddr;
     uint16_t _data_off;
     // TRUE if underlying mbuf has been used in the zero-copy flow
@@ -473,6 +479,10 @@ class DPDKQueuePair {
       _ring.push_back(buf);
     }
 
+    unsigned ring_size() const {
+      return _ring.size();
+    }
+
     bool gc() {
       for (int cnt = 0; cnt < gc_count; ++cnt) {
         auto tx_buf_p = get_one_completed();
@@ -530,7 +540,7 @@ class DPDKQueuePair {
   }
 
   void rx_start() {
-    _rx_poller.construct(this);
+    _rx_poller.emplace(this);
   }
 
   uint32_t send(circular_buffer<Packet>& pb) {
@@ -612,7 +622,7 @@ class DPDKQueuePair {
     // actual data buffer.
     //
     m->buf_addr      = (char*)data - RTE_PKTMBUF_HEADROOM;
-    m->buf_physaddr  = rte_mem_virt2phy(data) - RTE_PKTMBUF_HEADROOM;
+    m->buf_iova      = rte_mem_virt2iova(data) - RTE_PKTMBUF_HEADROOM;
     return true;
   }
 
@@ -642,7 +652,7 @@ class DPDKQueuePair {
    * @return a "optional" object representing the newly received data if in an
    *         "engaged" state or an error if in a "disengaged" state.
    */
-  Tub<Packet> from_mbuf(rte_mbuf* m);
+  std::optional<Packet> from_mbuf(rte_mbuf* m);
 
   /**
    * Transform an LRO rte_mbuf cluster into the "packet" object.
@@ -651,12 +661,12 @@ class DPDKQueuePair {
    * @return a "optional" object representing the newly received LRO packet if
    *         in an "engaged" state or an error if in a "disengaged" state.
    */
-  Tub<Packet> from_mbuf_lro(rte_mbuf* m);
+  std::optional<Packet> from_mbuf_lro(rte_mbuf* m);
 
  private:
   CephContext *cct;
   std::vector<packet_provider_type> _pkt_providers;
-  Tub<std::array<uint8_t, 128>> _sw_reta;
+  std::optional<std::array<uint8_t, 128>> _sw_reta;
   circular_buffer<Packet> _proxy_packetq;
   stream<Packet> _rx_stream;
   circular_buffer<Packet> _tx_packetq;
@@ -717,7 +727,7 @@ class DPDKQueuePair {
       return qp->poll_rx_once();
     }
   };
-  Tub<DPDKRXPoller> _rx_poller;
+  std::optional<DPDKRXPoller> _rx_poller;
   class DPDKTXGCPoller : public EventCenter::Poller {
     DPDKQueuePair *qp;
 
@@ -753,6 +763,7 @@ class DPDKDevice {
   struct rte_flow *_flow = nullptr;
   bool _is_i40e_device = false;
   bool _is_vmxnet3_device = false;
+  std::unique_ptr<AdminSocketHook> dfx_hook;
 
  public:
   rte_eth_dev_info _dev_info = {};
@@ -764,6 +775,8 @@ class DPDKDevice {
    */
   int init_port_fini();
 
+  void nic_stats_dump(Formatter *f);
+  void nic_xstats_dump(Formatter *f);
  private:
   /**
    * Port initialization consists of 3 main stages:
@@ -806,9 +819,9 @@ class DPDKDevice {
     /* now initialise the port we will use */
     int ret = init_port_start();
     if (ret != 0) {
-      rte_exit(EXIT_FAILURE, "Cannot initialise port %u\n", _port_idx);
+      ceph_assert(false && "Cannot initialise port\n");
     }
-    string name(std::string("port") + std::to_string(port_idx));
+    std::string name(std::string("port") + std::to_string(port_idx));
     PerfCountersBuilder plb(cct, name, l_dpdk_dev_first, l_dpdk_dev_last);
 
     plb.add_u64_counter(l_dpdk_dev_rx_mcast, "dpdk_device_receive_multicast_packets", "DPDK received multicast packets");
@@ -824,6 +837,8 @@ class DPDKDevice {
   }
 
   ~DPDKDevice() {
+    cct->get_admin_socket()->unregister_commands(dfx_hook.get());
+    dfx_hook.reset();
     if (_flow)
        rte_flow_destroy(_port_idx, _flow, nullptr);
     rte_eth_dev_stop(_port_idx);
@@ -839,7 +854,7 @@ class DPDKDevice {
     return sub;
   }
   ethernet_address hw_address() {
-    struct ether_addr mac;
+    struct rte_ether_addr mac;
     rte_eth_macaddr_get(_port_idx, &mac);
 
     return mac.addr_bytes;
@@ -849,7 +864,8 @@ class DPDKDevice {
   }
   const rss_key_type& rss_key() const { return _rss_key; }
   uint16_t hw_queues_count() { return _num_queues; }
-  std::unique_ptr<DPDKQueuePair> init_local_queue(CephContext *c, EventCenter *center, string hugepages, uint16_t qid) {
+  std::unique_ptr<DPDKQueuePair> init_local_queue(CephContext *c,
+      EventCenter *center, std::string hugepages, uint16_t qid) {
     std::unique_ptr<DPDKQueuePair> qp;
     qp = std::unique_ptr<DPDKQueuePair>(new DPDKQueuePair(c, center, this, qid));
     return qp;
diff --git a/src/msg/async/dpdk/DPDKStack.cc b/src/msg/async/dpdk/DPDKStack.cc
index 9a73dac5db1..1543a530df9 100644
--- a/src/msg/async/dpdk/DPDKStack.cc
+++ b/src/msg/async/dpdk/DPDKStack.cc
@@ -142,11 +142,12 @@ void DPDKWorker::initialize()
   }
 }
 
-using AvailableIPAddress = std::tuple<string, string, string>;
+using AvailableIPAddress = std::tuple<std::string, std::string, std::string>;
 static bool parse_available_address(
-        const string &ips, const string &gates, const string &masks, vector<AvailableIPAddress> &res)
+        const std::string &ips, const std::string &gates,
+	const std::string &masks, std::vector<AvailableIPAddress> &res)
 {
-  vector<string> ip_vec, gate_vec, mask_vec;
+  std::vector<std::string> ip_vec, gate_vec, mask_vec;
   string_to_vec(ip_vec, ips);
   string_to_vec(gate_vec, gates);
   string_to_vec(mask_vec, masks);
@@ -159,7 +160,7 @@ static bool parse_available_address(
   return true;
 }
 
-static bool match_available_address(const vector<AvailableIPAddress> &avails,
+static bool match_available_address(const std::vector<AvailableIPAddress> &avails,
                                     const entity_addr_t &ip, int &res)
 {
   for (size_t i = 0; i < avails.size(); ++i) {
@@ -178,7 +179,7 @@ static bool match_available_address(const vector<AvailableIPAddress> &avails,
 DPDKWorker::Impl::Impl(CephContext *cct, unsigned i, EventCenter *c, std::shared_ptr<DPDKDevice> dev)
     : id(i), _netif(cct, dev, c), _dev(dev), _inet(cct, c, &_netif)
 {
-  vector<AvailableIPAddress> tuples;
+  std::vector<AvailableIPAddress> tuples;
   bool parsed = parse_available_address(cct->_conf.get_val<std::string>("ms_dpdk_host_ipv4_addr"),
                                         cct->_conf.get_val<std::string>("ms_dpdk_gateway_ipv4_addr"),
                                         cct->_conf.get_val<std::string>("ms_dpdk_netmask_ipv4_addr"), tuples);
@@ -242,29 +243,30 @@ int DPDKWorker::connect(const entity_addr_t &addr, const SocketOptions &opts, Co
   return r;
 }
 
-void DPDKStack::spawn_worker(unsigned i, std::function<void ()> &&func)
+void DPDKStack::spawn_worker(std::function<void ()> &&func)
 {
   // create a extra master thread
   //
-  funcs[i] = std::move(func);
+  funcs.push_back(std::move(func));
   int r = 0;
-  r = dpdk::eal::init(cct);
+  r = eal.start();
   if (r < 0) {
-    lderr(cct) << __func__ << " init dpdk rte failed, r=" << r << dendl;
+    lderr(cct) << __func__ << " start dpdk rte failed, r=" << r << dendl;
     ceph_abort();
   }
-  // if dpdk::eal::init already called by NVMEDevice, we will select 1..n
+  // if eal.start already called by NVMEDevice, we will select 1..n
   // cores
-  ceph_assert(rte_lcore_count() >= i + 1);
+  unsigned nr_worker = funcs.size();
+  ceph_assert(rte_lcore_count() >= nr_worker);
   unsigned core_id;
-  int j = i;
   RTE_LCORE_FOREACH_SLAVE(core_id) {
-    if (i-- == 0) {
+    if (--nr_worker == 0) {
       break;
     }
   }
-  dpdk::eal::execute_on_master([&]() {
-    r = rte_eal_remote_launch(dpdk_thread_adaptor, static_cast<void*>(&funcs[j]), core_id);
+  void *adapted_func = static_cast<void*>(&funcs.back());
+  eal.execute_on_master([adapted_func, core_id, this]() {
+    int r = rte_eal_remote_launch(dpdk_thread_adaptor, adapted_func, core_id);
     if (r < 0) {
       lderr(cct) << __func__ << " remote launch failed, r=" << r << dendl;
       ceph_abort();
@@ -274,7 +276,9 @@ void DPDKStack::spawn_worker(unsigned i, std::function<void ()> &&func)
 
 void DPDKStack::join_worker(unsigned i)
 {
-  dpdk::eal::execute_on_master([&]() {
+  eal.execute_on_master([&]() {
     rte_eal_wait_lcore(i+1);
   });
+  if (i+1 == get_num_worker())
+    eal.stop();
 }
diff --git a/src/msg/async/dpdk/DPDKStack.h b/src/msg/async/dpdk/DPDKStack.h
index 37626bee492..3f64f566990 100644
--- a/src/msg/async/dpdk/DPDKStack.h
+++ b/src/msg/async/dpdk/DPDKStack.h
@@ -16,15 +16,16 @@
 #define CEPH_MSG_DPDKSTACK_H
 
 #include <functional>
+#include <optional>
 
 #include "common/ceph_context.h"
-#include "common/Tub.h"
 
 #include "msg/async/Stack.h"
 #include "net.h"
 #include "const.h"
 #include "IP.h"
 #include "Packet.h"
+#include "dpdk_rte.h"
 
 class interface;
 
@@ -46,6 +47,7 @@ class DPDKServerSocketImpl : public ServerSocketImpl {
   virtual int fd() const override {
     return _listener.fd();
   }
+  virtual void set_priority(int sd, int prio, int domain) override {}
 };
 
 // NativeConnectedSocketImpl
@@ -54,8 +56,8 @@ class NativeConnectedSocketImpl : public ConnectedSocketImpl {
   typename Protocol::connection _conn;
   uint32_t _cur_frag = 0;
   uint32_t _cur_off = 0;
-  Tub<Packet> _buf;
-  Tub<bufferptr> _cache_ptr;
+  std::optional<Packet> _buf;
+  std::optional<bufferptr> _cache_ptr;
 
  public:
   explicit NativeConnectedSocketImpl(typename Protocol::connection conn)
@@ -72,10 +74,10 @@ class NativeConnectedSocketImpl : public ConnectedSocketImpl {
     size_t off = 0;
     while (left > 0) {
       if (!_cache_ptr) {
-        _cache_ptr.construct();
+        _cache_ptr.emplace();
         r = zero_copy_read(*_cache_ptr);
         if (r <= 0) {
-          _cache_ptr.destroy();
+          _cache_ptr.reset();
           if (r == -EAGAIN)
             break;
           return r;
@@ -85,7 +87,7 @@ class NativeConnectedSocketImpl : public ConnectedSocketImpl {
         _cache_ptr->copy_out(0, _cache_ptr->length(), buf+off);
         left -= _cache_ptr->length();
         off += _cache_ptr->length();
-        _cache_ptr.destroy();
+        _cache_ptr.reset();
       } else {
         _cache_ptr->copy_out(0, left, buf+off);
         _cache_ptr->set_offset(_cache_ptr->offset() + left);
@@ -118,7 +120,7 @@ private:
     if (++_cur_frag == _buf->nr_frags()) {
       _cur_frag = 0;
       _cur_off = 0;
-      _buf.destroy();
+      _buf.reset();
     } else {
       _cur_off += f.size;
     }
@@ -246,16 +248,25 @@ class DPDKWorker : public Worker {
   friend class DPDKServerSocketImpl<tcp4>;
 };
 
+using namespace dpdk;
 class DPDKStack : public NetworkStack {
-  vector<std::function<void()> > funcs;
+  std::vector<std::function<void()> > funcs;
+
+  virtual Worker* create_worker(CephContext *c, unsigned worker_id) override {
+    return new DPDKWorker(c, worker_id);
+  }
+  virtual void rename_thread(unsigned id) override {}
+
  public:
-  explicit DPDKStack(CephContext *cct, const string &t): NetworkStack(cct, t) {
-    funcs.resize(cct->_conf->ms_async_max_op_threads);
+  explicit DPDKStack(CephContext *cct): NetworkStack(cct), eal(cct) {
+    funcs.reserve(cct->_conf->ms_async_op_threads);
   }
   virtual bool support_local_listen_table() const override { return true; }
 
-  virtual void spawn_worker(unsigned i, std::function<void ()> &&func) override;
+  virtual void spawn_worker(std::function<void ()> &&func) override;
   virtual void join_worker(unsigned i) override;
+ private:
+  dpdk::eal eal;
 };
 
 #endif
diff --git a/src/msg/async/dpdk/EventDPDK.cc b/src/msg/async/dpdk/EventDPDK.cc
index 5d291716c71..a38ddcc99b0 100644
--- a/src/msg/async/dpdk/EventDPDK.cc
+++ b/src/msg/async/dpdk/EventDPDK.cc
@@ -67,7 +67,7 @@ int DPDKDriver::resize_events(int newsize)
 	return 0;
 }
 
-int DPDKDriver::event_wait(vector<FiredFileEvent> &fired_events, struct timeval *tvp)
+int DPDKDriver::event_wait(std::vector<FiredFileEvent> &fired_events, struct timeval *tvp)
 {
 	int num_events = 512;
 	int events[num_events];
diff --git a/src/msg/async/dpdk/EventDPDK.h b/src/msg/async/dpdk/EventDPDK.h
index 541c2210e01..ccf2cd28d47 100644
--- a/src/msg/async/dpdk/EventDPDK.h
+++ b/src/msg/async/dpdk/EventDPDK.h
@@ -33,7 +33,7 @@ class DPDKDriver : public EventDriver {
   int add_event(int fd, int cur_mask, int add_mask) override;
   int del_event(int fd, int cur_mask, int del_mask) override;
   int resize_events(int newsize) override;
-  int event_wait(vector<FiredFileEvent> &fired_events, struct timeval *tp) override;
+  int event_wait(std::vector<FiredFileEvent> &fired_events, struct timeval *tp) override;
   bool need_wakeup() override { return false; }
 };
 
diff --git a/src/msg/async/dpdk/IP.cc b/src/msg/async/dpdk/IP.cc
index fab534bb25b..0bfb21b1682 100644
--- a/src/msg/async/dpdk/IP.cc
+++ b/src/msg/async/dpdk/IP.cc
@@ -333,7 +333,7 @@ void ipv4::send(ipv4_address to, ip_protocol_num proto_num,
   }
 }
 
-Tub<l3_protocol::l3packet> ipv4::get_packet() {
+std::optional<l3_protocol::l3packet> ipv4::get_packet() {
   // _packetq will be mostly empty here unless it hold remnants of previously
   // fragmented packet
   if (_packetq.empty()) {
@@ -350,7 +350,7 @@ Tub<l3_protocol::l3packet> ipv4::get_packet() {
     }
   }
 
-  Tub<l3_protocol::l3packet> p;
+  std::optional<l3_protocol::l3packet> p;
   if (!_packetq.empty()) {
     p = std::move(_packetq.front());
     _packetq.pop_front();
diff --git a/src/msg/async/dpdk/IP.h b/src/msg/async/dpdk/IP.h
index 1fc60658235..e0e62f1228c 100644
--- a/src/msg/async/dpdk/IP.h
+++ b/src/msg/async/dpdk/IP.h
@@ -60,7 +60,7 @@ struct ipv4_traits {
     ethernet_address e_dst;
     ip_protocol_num proto_num;
   };
-  using packet_provider_type = std::function<Tub<l4packet> ()>;
+  using packet_provider_type = std::function<std::optional<l4packet> ()>;
   static void tcp_pseudo_header_checksum(checksummer& csum, ipv4_address src, ipv4_address dst, uint16_t len) {
     csum.sum_many(src.ip, dst.ip, uint8_t(0), uint8_t(ip_protocol_num::tcp), len);
   }
@@ -131,7 +131,7 @@ class icmp {
   explicit icmp(CephContext *c, inet_type& inet)
       : cct(c), _inet(inet), _queue_space(c, "DPDK::icmp::_queue_space", 212992) {
     _inet.register_packet_provider([this] {
-      Tub<ipv4_traits::l4packet> l4p;
+      std::optional<ipv4_traits::l4packet> l4p;
       if (!_packetq.empty()) {
         l4p = std::move(_packetq.front());
         _packetq.pop_front();
@@ -213,7 +213,7 @@ class ipv4 {
  private:
   interface* _netif;
   std::vector<ipv4_traits::packet_provider_type> _pkt_providers;
-  Tub<uint64_t> frag_timefd;
+  std::optional<uint64_t> frag_timefd;
   EventCallbackRef frag_handler;
   arp _global_arp;
   arp_for<ipv4> _arp;
@@ -251,7 +251,7 @@ class ipv4 {
  private:
   int handle_received_packet(Packet p, ethernet_address from);
   bool forward(forward_hash& out_hash_data, Packet& p, size_t off);
-  Tub<l3_protocol::l3packet> get_packet();
+  std::optional<l3_protocol::l3packet> get_packet();
   bool in_my_netmask(ipv4_address a) const {
     return !((a.ip ^ _host_address.ip) & _netmask.ip);
   }
@@ -262,11 +262,11 @@ class ipv4 {
   }
   void frag_arm(utime_t now) {
     auto tp = now + _frag_timeout;
-    frag_timefd.construct(center->create_time_event(tp.to_nsec() / 1000, frag_handler));
+    frag_timefd = center->create_time_event(tp.to_nsec() / 1000, frag_handler);
   }
   void frag_arm() {
     auto now = ceph_clock_now();
-    frag_timefd.construct(center->create_time_event(now.to_nsec() / 1000, frag_handler));
+    frag_timefd = center->create_time_event(now.to_nsec() / 1000, frag_handler);
   }
 
  public:
diff --git a/src/msg/async/dpdk/Packet.h b/src/msg/async/dpdk/Packet.h
index f929da31786..2aa65f6e1ed 100644
--- a/src/msg/async/dpdk/Packet.h
+++ b/src/msg/async/dpdk/Packet.h
@@ -28,7 +28,6 @@
 #include <iosfwd>
 
 #include "include/types.h"
-#include "common/Tub.h"
 #include "common/deleter.h"
 #include "msg/async/Event.h"
 
@@ -49,7 +48,7 @@ struct offload_info {
   bool reassembled = false;
   uint16_t tso_seg_size = 0;
   // HW stripped VLAN header (CPU order)
-  Tub<uint16_t> vlan_tci;
+  std::optional<uint16_t> vlan_tci;
 };
 
 // Zero-copy friendly packet class
@@ -97,7 +96,7 @@ class Packet {
     uint16_t _nr_frags = 0;
     uint16_t _allocated_frags;
     offload_info _offload_info;
-    Tub<uint32_t> rss_hash;
+    std::optional<uint32_t> rss_hash;
     char data[internal_data_size]; // only frags[0] may use
     unsigned headroom = internal_data_size; // in data
     // FIXME: share data/frags space
@@ -122,7 +121,7 @@ class Packet {
       n->_nr_frags = old->_nr_frags;
       n->headroom = old->headroom;
       n->_offload_info = old->_offload_info;
-      n->rss_hash.construct(old->rss_hash);
+      n->rss_hash = old->rss_hash;
       std::copy(old->frags, old->frags + old->_nr_frags, n->frags);
       old->copy_internal_fragment_to(n.get());
       return n;
@@ -268,11 +267,11 @@ public:
       _impl = impl::allocate_if_needed(std::move(_impl), extra);
     }
   }
-  Tub<uint32_t> rss_hash() {
+  std::optional<uint32_t> rss_hash() {
     return _impl->rss_hash;
   }
   void set_rss_hash(uint32_t hash) {
-    _impl->rss_hash.construct(hash);
+    _impl->rss_hash = hash;
   }
 private:
   void linearize(size_t at_frag, size_t desired_size);
diff --git a/src/msg/async/dpdk/TCP.cc b/src/msg/async/dpdk/TCP.cc
index 26f29e10f75..86c80487c46 100644
--- a/src/msg/async/dpdk/TCP.cc
+++ b/src/msg/async/dpdk/TCP.cc
@@ -222,7 +222,7 @@ void tcp<InetTraits>::respond_with_reset(tcp_hdr* rth, ipaddr local_ip, ipaddr f
 #undef dout_prefix
 #define dout_prefix _prefix(_dout)
 template<typename InetTraits>
-ostream& tcp<InetTraits>::tcb::_prefix(std::ostream *_dout) {
+std::ostream& tcp<InetTraits>::tcb::_prefix(std::ostream *_dout) {
   return *_dout << "tcp " << _local_ip << ":" << _local_port << " -> " << _foreign_ip << ":" << _foreign_port
                 << " tcb(" << this << " fd=" << fd << " s=" << _state << ").";
 }
diff --git a/src/msg/async/dpdk/TCP.h b/src/msg/async/dpdk/TCP.h
index a0104fb44f4..cf76d3279c0 100644
--- a/src/msg/async/dpdk/TCP.h
+++ b/src/msg/async/dpdk/TCP.h
@@ -234,7 +234,7 @@ class tcp {
    public:
     C_handle_delayed_ack(tcb *t): tc(t) { }
     void do_request(uint64_t r) {
-      tc->_delayed_ack_fd.destroy();
+      tc->_delayed_ack_fd.reset();
       tc->_nr_full_seg_received = 0;
       tc->output();
     }
@@ -246,7 +246,7 @@ class tcp {
    public:
     C_handle_retransmit(tcb *t): tc(t) { }
     void do_request(uint64_t r) {
-      tc->retransmit_fd.destroy();
+      tc->retransmit_fd.reset();
       tc->retransmit();
     }
   };
@@ -257,7 +257,7 @@ class tcp {
    public:
     C_handle_persist(tcb *t): tc(t) { }
     void do_request(uint64_t r) {
-      tc->persist_fd.destroy();
+      tc->persist_fd.reset();
       tc->persist();
     }
   };
@@ -364,7 +364,7 @@ class tcp {
     int16_t _errno = 1;
     tcp_option _option;
     EventCallbackRef delayed_ack_event;
-    Tub<uint64_t> _delayed_ack_fd;
+    std::optional<uint64_t> _delayed_ack_fd;
     // Retransmission timeout
     std::chrono::microseconds _rto{1000*1000};
     std::chrono::microseconds _persist_time_out{1000*1000};
@@ -374,10 +374,10 @@ class tcp {
     static constexpr std::chrono::microseconds _rto_clk_granularity{1000};
     static constexpr uint16_t _max_nr_retransmit{5};
     EventCallbackRef retransmit_event;
-    Tub<uint64_t> retransmit_fd;
+    std::optional<uint64_t> retransmit_fd;
     EventCallbackRef persist_event;
     EventCallbackRef all_data_ack_event;
-    Tub<uint64_t> persist_fd;
+    std::optional<uint64_t> persist_fd;
     uint16_t _nr_full_seg_received = 0;
     struct isn_secret {
       // 512 bits secretkey for ISN generating
@@ -395,7 +395,7 @@ class tcp {
    public:
     // callback
     void close_final_cleanup();
-    ostream& _prefix(std::ostream *_dout);
+    std::ostream& _prefix(std::ostream *_dout);
 
    public:
     tcb(tcp& t, connid id);
@@ -407,13 +407,13 @@ class tcp {
     bool is_all_data_acked();
     int send(Packet p);
     void connect();
-    Tub<Packet> read();
+    std::optional<Packet> read();
     void close();
     void remove_from_tcbs() {
       auto id = connid{_local_ip, _foreign_ip, _local_port, _foreign_port};
       _tcp._tcbs.erase(id);
     }
-    Tub<typename InetTraits::l4packet> get_packet();
+    std::optional<typename InetTraits::l4packet> get_packet();
     void output() {
       if (!_poll_active) {
         _poll_active = true;
@@ -473,23 +473,23 @@ class tcp {
     void start_retransmit_timer() {
       if (retransmit_fd)
         center->delete_time_event(*retransmit_fd);
-      retransmit_fd.construct(center->create_time_event(_rto.count(), retransmit_event));
+      retransmit_fd.emplace(center->create_time_event(_rto.count(), retransmit_event));
     };
     void stop_retransmit_timer() {
       if (retransmit_fd) {
         center->delete_time_event(*retransmit_fd);
-        retransmit_fd.destroy();
+        retransmit_fd.reset();
       }
     };
     void start_persist_timer() {
       if (persist_fd)
         center->delete_time_event(*persist_fd);
-      persist_fd.construct(center->create_time_event(_persist_time_out.count(), persist_event));
+      persist_fd.emplace(center->create_time_event(_persist_time_out.count(), persist_event));
     };
     void stop_persist_timer() {
       if (persist_fd) {
         center->delete_time_event(*persist_fd);
-        persist_fd.destroy();
+        persist_fd.reset();
       }
     };
     void persist();
@@ -659,7 +659,7 @@ class tcp {
     int send(Packet p) {
       return _tcb->send(std::move(p));
     }
-    Tub<Packet> read() {
+    std::optional<Packet> read() {
       return _tcb->read();
     }
     int16_t get_errno() const {
@@ -685,7 +685,7 @@ class tcp {
     uint16_t _port;
     int _fd = -1;
     int16_t _errno;
-    queue<connection> _q;
+    std::queue<connection> _q;
     size_t _q_max_length;
 
    private:
@@ -711,8 +711,8 @@ class tcp {
       _fd = _tcp.manager.get_eventfd();
       return 0;
     }
-    Tub<connection> accept() {
-      Tub<connection> c;
+    std::optional<connection> accept() {
+      std::optional<connection> c;
       if (!_q.empty()) {
         c = std::move(_q.front());
         _q.pop();
@@ -772,7 +772,7 @@ tcp<InetTraits>::tcp(CephContext *c, inet_type& inet, EventCenter *cen)
       _e(_rd()), _queue_space(cct, "DPDK::tcp::queue_space", 81920) {
   int tcb_polled = 0u;
   _inet.register_packet_provider([this, tcb_polled] () mutable {
-    Tub<typename InetTraits::l4packet> l4p;
+    std::optional<typename InetTraits::l4packet> l4p;
     auto c = _poll_tcbs.size();
     if (!_packetq.empty() && (!(tcb_polled % 128) || c == 0)) {
       l4p = std::move(_packetq.front());
@@ -1220,12 +1220,12 @@ bool tcp<InetTraits>::tcb::is_all_data_acked() {
 }
 
 template <typename InetTraits>
-Tub<Packet> tcp<InetTraits>::tcb::read() {
-  Tub<Packet> p;
+std::optional<Packet> tcp<InetTraits>::tcb::read() {
+  std::optional<Packet> p;
   if (_rcv.data.empty())
     return p;
 
-  p.construct();
+  p.emplace();
   for (auto&& q : _rcv.data) {
     p->append(std::move(q));
   }
@@ -1282,7 +1282,7 @@ bool tcp<InetTraits>::tcb::should_send_ack(uint16_t seg_len) {
     _nr_full_seg_received = 0;
     if (_delayed_ack_fd) {
       center->delete_time_event(*_delayed_ack_fd);
-      _delayed_ack_fd.destroy();
+      _delayed_ack_fd.reset();
     }
     return true;
   }
@@ -1293,7 +1293,7 @@ bool tcp<InetTraits>::tcb::should_send_ack(uint16_t seg_len) {
       _nr_full_seg_received = 0;
       if (_delayed_ack_fd) {
         center->delete_time_event(*_delayed_ack_fd);
-        _delayed_ack_fd.destroy();
+        _delayed_ack_fd.reset();
       }
       return true;
     }
@@ -1307,7 +1307,7 @@ bool tcp<InetTraits>::tcb::should_send_ack(uint16_t seg_len) {
   // If the timer is not armed, schedule a delayed ACK.
   // The maximum delayed ack timer allowed by RFC1122 is 500ms, most
   // implementations use 200ms.
-  _delayed_ack_fd.construct(center->create_time_event(200*1000, delayed_ack_event));
+  _delayed_ack_fd.emplace(center->create_time_event(200*1000, delayed_ack_event));
   return false;
 }
 
@@ -1315,7 +1315,7 @@ template <typename InetTraits>
 void tcp<InetTraits>::tcb::clear_delayed_ack() {
   if (_delayed_ack_fd) {
     center->delete_time_event(*_delayed_ack_fd);
-    _delayed_ack_fd.destroy();
+    _delayed_ack_fd.reset();
   }
 }
 
@@ -1452,13 +1452,13 @@ tcp_sequence tcp<InetTraits>::tcb::get_isn() {
 }
 
 template <typename InetTraits>
-Tub<typename InetTraits::l4packet> tcp<InetTraits>::tcb::get_packet() {
+std::optional<typename InetTraits::l4packet> tcp<InetTraits>::tcb::get_packet() {
   _poll_active = false;
   if (_packetq.empty()) {
     output_one();
   }
 
-  Tub<typename InetTraits::l4packet> p;
+  std::optional<typename InetTraits::l4packet> p;
   if (in_state(CLOSED)) {
     return p;
   }
diff --git a/src/msg/async/dpdk/UserspaceEvent.cc b/src/msg/async/dpdk/UserspaceEvent.cc
index 282dcef12f6..e0c57fd9bd9 100644
--- a/src/msg/async/dpdk/UserspaceEvent.cc
+++ b/src/msg/async/dpdk/UserspaceEvent.cc
@@ -33,9 +33,9 @@ int UserspaceEventManager::get_eventfd()
     fds.resize(fd + 1);
   }
 
-  Tub<UserspaceFDImpl> &impl = fds[fd];
+  std::optional<UserspaceFDImpl> &impl = fds[fd];
   ceph_assert(!impl);
-  impl.construct();
+  impl.emplace();
   ldout(cct, 20) << __func__ << " fd=" << fd << dendl;
   return fd;
 }
@@ -46,7 +46,7 @@ int UserspaceEventManager::notify(int fd, int mask)
   if ((size_t)fd >= fds.size())
     return -ENOENT;
 
-  Tub<UserspaceFDImpl> &impl = fds[fd];
+  std::optional<UserspaceFDImpl> &impl = fds[fd];
   if (!impl)
     return -ENOENT;
 
@@ -77,7 +77,7 @@ void UserspaceEventManager::close(int fd)
   if ((size_t)fd >= fds.size())
     return ;
 
-  Tub<UserspaceFDImpl> &impl = fds[fd];
+  std::optional<UserspaceFDImpl> &impl = fds[fd];
   if (!impl)
     return ;
 
@@ -93,7 +93,7 @@ void UserspaceEventManager::close(int fd)
     }
     waiting_fds[impl->waiting_idx] = -1;
   }
-  impl.destroy();
+  impl.reset();
 }
 
 int UserspaceEventManager::poll(int *events, int *masks, int num_events, struct timeval *tp)
@@ -109,7 +109,7 @@ int UserspaceEventManager::poll(int *events, int *masks, int num_events, struct
       continue;
 
     events[count] = fd;
-    Tub<UserspaceFDImpl> &impl = fds[fd];
+    std::optional<UserspaceFDImpl> &impl = fds[fd];
     ceph_assert(impl);
     masks[count] = impl->listening_mask & impl->activating_mask;
     ceph_assert(masks[count]);
diff --git a/src/msg/async/dpdk/UserspaceEvent.h b/src/msg/async/dpdk/UserspaceEvent.h
index 7e89517df87..49308aca439 100644
--- a/src/msg/async/dpdk/UserspaceEvent.h
+++ b/src/msg/async/dpdk/UserspaceEvent.h
@@ -20,12 +20,12 @@
 #include <errno.h>
 #include <string.h>
 
-#include <vector>
 #include <list>
+#include <optional>
+#include <vector>
 
 #include "include/ceph_assert.h"
 #include "include/int_types.h"
-#include "common/Tub.h"
 
 class CephContext;
 
@@ -41,7 +41,7 @@ class UserspaceEventManager {
   CephContext *cct;
   int max_fd = 0;
   uint32_t max_wait_idx = 0;
-  std::vector<Tub<UserspaceFDImpl> > fds;
+  std::vector<std::optional<UserspaceFDImpl> > fds;
   std::vector<int> waiting_fds;
   std::list<uint32_t> unused_fds;
 
@@ -56,7 +56,7 @@ class UserspaceEventManager {
     if ((size_t)fd >= fds.size())
       return -ENOENT;
 
-    Tub<UserspaceFDImpl> &impl = fds[fd];
+    std::optional<UserspaceFDImpl> &impl = fds[fd];
     if (!impl)
       return -ENOENT;
 
@@ -74,7 +74,7 @@ class UserspaceEventManager {
     if ((size_t)fd >= fds.size())
       return -ENOENT;
 
-    Tub<UserspaceFDImpl> &impl = fds[fd];
+    std::optional<UserspaceFDImpl> &impl = fds[fd];
     if (!impl)
       return -ENOENT;
 
diff --git a/src/msg/async/dpdk/dpdk_rte.cc b/src/msg/async/dpdk/dpdk_rte.cc
index 96cf896f823..1b110c939b3 100644
--- a/src/msg/async/dpdk/dpdk_rte.cc
+++ b/src/msg/async/dpdk/dpdk_rte.cc
@@ -23,6 +23,8 @@
 #include <rte_ethdev.h>
 #include <rte_version.h>
 
+#include "include/str_map.h"
+
 #include "DPDK.h"
 #include "dpdk_rte.h"
 
@@ -34,12 +36,6 @@ namespace dpdk {
     return v;
   }
 
-  bool eal::initialized = false;
-  std::thread eal::t;
-  std::mutex eal::lock;
-  std::condition_variable eal::cond;
-  std::list<std::function<void()>> eal::funcs;
-
   static int bitcount(unsigned long long n)
   {
     return std::bitset<CHAR_BIT * sizeof(n)>{n}.count();
@@ -75,31 +71,33 @@ namespace dpdk {
     return count;
   }
 
-  int eal::init(CephContext *c)
+  bool eal::rte_initialized = false;
+
+  int eal::start()
   {
     if (initialized) {
       return 1;
     }
 
     bool done = false;
-    auto coremask = c->_conf.get_val<std::string>("ms_dpdk_coremask");
+    auto coremask = cct->_conf.get_val<std::string>("ms_dpdk_coremask");
     int coremaskbit = coremask_bitcount(coremask.c_str());
 
     if (coremaskbit <= 0
-        || static_cast<uint64_t>(coremaskbit) < c->_conf->ms_async_op_threads)
+        || static_cast<uint64_t>(coremaskbit) < cct->_conf->ms_async_op_threads)
       return -EINVAL;
 
     t = std::thread([&]() {
       // TODO: Inherit these from the app parameters - "opts"
       std::vector<std::vector<char>> args {
-          string2vector(string("ceph")),
-          string2vector("-c"), string2vector(c->_conf.get_val<std::string>("ms_dpdk_coremask")),
-          string2vector("-n"), string2vector(c->_conf->ms_dpdk_memory_channel),
+          string2vector("ceph"),
+          string2vector("-c"), string2vector(cct->_conf.get_val<std::string>("ms_dpdk_coremask")),
+          string2vector("-n"), string2vector(cct->_conf->ms_dpdk_memory_channel),
       };
 
-      Tub<std::string> hugepages_path;
-      if (!c->_conf->ms_dpdk_hugepages.empty()) {
-        hugepages_path.construct(c->_conf->ms_dpdk_hugepages);
+      std::optional<std::string> hugepages_path;
+      if (!cct->_conf->ms_dpdk_hugepages.empty()) {
+        hugepages_path.emplace(cct->_conf->ms_dpdk_hugepages);
       }
 
       // If "hugepages" is not provided and DPDK PMD drivers mode is requested -
@@ -123,13 +121,21 @@ namespace dpdk {
 
         args.push_back(string2vector("-m"));
         args.push_back(string2vector(size_MB_str.str()));
-      } else if (!c->_conf->ms_dpdk_pmd.empty()) {
+      } else if (!cct->_conf->ms_dpdk_pmd.empty()) {
         args.push_back(string2vector("--no-huge"));
       }
 
+      for_each_pair(cct->_conf.get_val<std::string>("ms_dpdk_devs_allowlist"), " ",
+		    [&args] (std::string_view key, std::string_view val) {
+		      args.push_back(string2vector(std::string(key)));
+		      if (!val.empty()) {
+                        args.push_back(string2vector(std::string(val)));
+                      }
+		    });
+
       std::string rte_file_prefix;
       rte_file_prefix = "rte_";
-      rte_file_prefix += c->_conf->name.to_str();
+      rte_file_prefix += cct->_conf->name.to_str();
       args.push_back(string2vector("--file-prefix"));
       args.push_back(string2vector(rte_file_prefix));
 
@@ -138,31 +144,35 @@ namespace dpdk {
       for (auto&& a: args) {
         cargs.push_back(a.data());
       }
-      /* initialise the EAL for all */
-      int ret = rte_eal_init(cargs.size(), cargs.data());
-      if (ret < 0)
-        return ret;
+      if (!rte_initialized) {
+        /* initialise the EAL for all */
+        int ret = rte_eal_init(cargs.size(), cargs.data());
+	if (ret < 0) {
+          std::unique_lock locker(lock);
+          done = true;
+          cond.notify_all();
+          return ret;
+	}
+        rte_initialized = true;
+      }
 
-      std::unique_lock<std::mutex> l(lock);
+      std::unique_lock locker(lock);
       initialized = true;
       done = true;
       cond.notify_all();
-      while (true) {
+      while (!stopped) {
+        cond.wait(locker, [this] { return !funcs.empty() || stopped; });
         if (!funcs.empty()) {
           auto f = std::move(funcs.front());
           funcs.pop_front();
           f();
           cond.notify_all();
-        } else {
-          cond.wait(l);
         }
       }
     });
-    t.detach();
-    std::unique_lock<std::mutex> l(lock);
-    while (!done)
-      cond.wait(l);
-    return 0;
+    std::unique_lock locker(lock);
+    cond.wait(locker, [&] { return done; });
+    return initialized ? 0 : -EIO;
   }
 
   size_t eal::mem_size(int num_cpus)
@@ -182,4 +192,13 @@ namespace dpdk {
     return memsize;
   }
 
+  void eal::stop()
+  {
+    assert(initialized);
+    assert(!stopped);
+    stopped = true;
+    cond.notify_all();
+    t.join();
+  }
+
 } // namespace dpdk
diff --git a/src/msg/async/dpdk/dpdk_rte.h b/src/msg/async/dpdk/dpdk_rte.h
index 4aa83899492..6784af6d4fa 100644
--- a/src/msg/async/dpdk/dpdk_rte.h
+++ b/src/msg/async/dpdk/dpdk_rte.h
@@ -46,12 +46,10 @@ namespace dpdk {
 class eal {
  public:
   using cpuset = std::bitset<RTE_MAX_LCORE>;
-
-  static std::mutex lock;
-  static std::condition_variable cond;
-  static std::list<std::function<void()>> funcs;
-  static int init(CephContext *c);
-  static void execute_on_master(std::function<void()> &&f) {
+  explicit eal(CephContext *cct) : cct(cct) {}
+  int start();
+  void stop();
+  void execute_on_master(std::function<void()> &&f) {
     bool done = false;
     std::unique_lock<std::mutex> l(lock);
     funcs.emplace_back([&]() { f(); done = true; });
@@ -65,9 +63,16 @@ class eal {
    *
    * @return
    */
-  static size_t mem_size(int num_cpus);
-  static bool initialized;
-  static std::thread t;
+  size_t mem_size(int num_cpus);
+  static bool rte_initialized;
+ private:
+  CephContext *cct;
+  bool initialized = false;
+  bool stopped = false;
+  std::thread t;
+  std::mutex lock;
+  std::condition_variable cond;
+  std::list<std::function<void()>> funcs;
 };
 
 } // namespace dpdk
diff --git a/src/msg/async/dpdk/net.cc b/src/msg/async/dpdk/net.cc
index 6e361f182d1..c429c426cfc 100644
--- a/src/msg/async/dpdk/net.cc
+++ b/src/msg/async/dpdk/net.cc
@@ -52,7 +52,7 @@ interface::interface(CephContext *cct, std::shared_ptr<DPDKDevice> dev, EventCen
   auto idx = 0u;
   unsigned qid = center->get_id();
   dev->queue_for_cpu(center->get_id()).register_packet_provider([this, idx, qid] () mutable {
-    Tub<Packet> p;
+    std::optional<Packet> p;
     for (size_t i = 0; i < _pkt_providers.size(); i++) {
       auto l3p = _pkt_providers[idx++]();
       if (idx == _pkt_providers.size())
diff --git a/src/msg/async/dpdk/net.h b/src/msg/async/dpdk/net.h
index 63f0422b72c..1966f847c94 100644
--- a/src/msg/async/dpdk/net.h
+++ b/src/msg/async/dpdk/net.h
@@ -80,7 +80,7 @@ class l3_protocol {
     ethernet_address to;
     Packet p;
   };
-  using packet_provider_type = std::function<Tub<l3packet> ()>;
+  using packet_provider_type = std::function<std::optional<l3packet> ()>;
 
  private:
   interface* _netif;
diff --git a/src/msg/async/frames_v2.cc b/src/msg/async/frames_v2.cc
index 8fdded42d87..e0c41fdb64c 100644
--- a/src/msg/async/frames_v2.cc
+++ b/src/msg/async/frames_v2.cc
@@ -72,6 +72,8 @@ void FrameAssembler::fill_preamble(Tag tag,
     preamble.segments[i].alignment = m_descs[i].align;
   }
   preamble.num_segments = m_descs.size();
+  preamble.flags = m_flags;  
+
   preamble.crc = ceph_crc32c(
       0, reinterpret_cast<const unsigned char*>(&preamble),
       sizeof(preamble) - sizeof(preamble.crc));
@@ -106,7 +108,7 @@ bufferlist FrameAssembler::asm_crc_rev0(const preamble_block_t& preamble,
   frame_bl.append(reinterpret_cast<const char*>(&preamble), sizeof(preamble));
   for (size_t i = 0; i < m_descs.size(); i++) {
     ceph_assert(segment_bls[i].length() == m_descs[i].logical_len);
-    epilogue.crc_values[i] = segment_bls[i].crc32c(-1);
+    epilogue.crc_values[i] = m_with_data_crc ? segment_bls[i].crc32c(-1) : 0;
     if (segment_bls[i].length() > 0) {
       frame_bl.claim_append(segment_bls[i]);
     }
@@ -159,7 +161,7 @@ bufferlist FrameAssembler::asm_crc_rev1(const preamble_block_t& preamble,
 
   ceph_assert(segment_bls[0].length() == m_descs[0].logical_len);
   if (segment_bls[0].length() > 0) {
-    uint32_t crc = segment_bls[0].crc32c(-1);
+    uint32_t crc = m_with_data_crc ? segment_bls[0].crc32c(-1) : 0;
     frame_bl.claim_append(segment_bls[0]);
     encode(crc, frame_bl);
   }
@@ -169,7 +171,8 @@ bufferlist FrameAssembler::asm_crc_rev1(const preamble_block_t& preamble,
 
   for (size_t i = 1; i < m_descs.size(); i++) {
     ceph_assert(segment_bls[i].length() == m_descs[i].logical_len);
-    epilogue.crc_values[i - 1] = segment_bls[i].crc32c(-1);
+    epilogue.crc_values[i - 1] =
+            m_with_data_crc ? segment_bls[i].crc32c(-1) : 0;
     if (segment_bls[i].length() > 0) {
       frame_bl.claim_append(segment_bls[i]);
     }
@@ -206,8 +209,7 @@ bufferlist FrameAssembler::asm_secure_rev1(const preamble_block_t& preamble,
   if (segment_bls[0].length() > 0) {
     m_crypto->tx->reset_tx_handler({segment_bls[0].length()});
     m_crypto->tx->authenticated_encrypt_update(segment_bls[0]);
-    auto tmp = m_crypto->tx->authenticated_encrypt_final();
-    frame_bl.claim_append(tmp);
+    frame_bl.claim_append(m_crypto->tx->authenticated_encrypt_final());
   }
   if (m_descs.size() == 1) {
     return frame_bl;  // no epilogue if only one segment
@@ -234,20 +236,24 @@ bufferlist FrameAssembler::asm_secure_rev1(const preamble_block_t& preamble,
     }
   }
   m_crypto->tx->authenticated_encrypt_update(epilogue_bl);
-  auto tmp = m_crypto->tx->authenticated_encrypt_final();
-  frame_bl.claim_append(tmp);
+  frame_bl.claim_append(m_crypto->tx->authenticated_encrypt_final());
   return frame_bl;
 }
 
 bufferlist FrameAssembler::assemble_frame(Tag tag, bufferlist segment_bls[],
                                           const uint16_t segment_aligns[],
-                                          size_t segment_count) {
+                                          size_t segment_count) {  
+  m_flags = 0;
   m_descs.resize(calc_num_segments(segment_bls, segment_count));
   for (size_t i = 0; i < m_descs.size(); i++) {
     m_descs[i].logical_len = segment_bls[i].length();
     m_descs[i].align = segment_aligns[i];
   }
 
+  if (m_compression->tx) {   
+    asm_compress(segment_bls);
+  }
+
   preamble_block_t preamble;
   fill_preamble(tag, preamble);
 
@@ -319,6 +325,12 @@ Tag FrameAssembler::disassemble_preamble(bufferlist& preamble_bl) {
     m_descs[i].logical_len = preamble->segments[i].length;
     m_descs[i].align = preamble->segments[i].alignment;
   }
+
+  m_flags = preamble->flags;
+  // If frame has been compressed, 
+  // we need to make sure the compression handler has been setup
+  ceph_assert_always(!is_compressed() || m_compression->rx);
+
   return static_cast<Tag>(preamble->tag);
 }
 
@@ -330,7 +342,9 @@ bool FrameAssembler::disasm_all_crc_rev0(bufferlist segment_bls[],
 
   for (size_t i = 0; i < m_descs.size(); i++) {
     ceph_assert(segment_bls[i].length() == m_descs[i].logical_len);
-    check_segment_crc(segment_bls[i], epilogue->crc_values[i]);
+    if (m_with_data_crc) {
+      check_segment_crc(segment_bls[i], epilogue->crc_values[i]);
+    }
   }
   return !(epilogue->late_flags & FRAME_LATE_FLAG_ABORTED);
 }
@@ -363,7 +377,9 @@ void FrameAssembler::disasm_first_crc_rev1(bufferlist& preamble_bl,
     uint32_t expected_crc;
     decode(expected_crc, it);
     segment_bl.splice(m_descs[0].logical_len, FRAME_CRC_SIZE);
-    check_segment_crc(segment_bl, expected_crc);
+    if (m_with_data_crc) {
+      check_segment_crc(segment_bl, expected_crc);
+    }
   } else {
     ceph_assert(segment_bl.length() == 0);
   }
@@ -377,7 +393,9 @@ bool FrameAssembler::disasm_remaining_crc_rev1(bufferlist segment_bls[],
 
   for (size_t i = 1; i < m_descs.size(); i++) {
     ceph_assert(segment_bls[i].length() == m_descs[i].logical_len);
-    check_segment_crc(segment_bls[i], epilogue->crc_values[i - 1]);
+    if (m_with_data_crc) {
+      check_segment_crc(segment_bls[i], epilogue->crc_values[i - 1]);
+    }
   }
   return check_epilogue_late_status(epilogue->late_status);
 }
@@ -396,7 +414,7 @@ void FrameAssembler::disasm_first_secure_rev1(bufferlist& preamble_bl,
     segment_bl.swap(tmp);
     preamble_bl.splice(sizeof(preamble_block_t), FRAME_PREAMBLE_INLINE_SIZE,
                        &segment_bl);
-    segment_bl.claim_append(tmp);
+    segment_bl.claim_append(std::move(tmp));
   } else {
     ceph_assert(segment_bl.length() == 0);
     preamble_bl.splice(sizeof(preamble_block_t), FRAME_PREAMBLE_INLINE_SIZE,
@@ -425,6 +443,19 @@ bool FrameAssembler::disasm_remaining_secure_rev1(
   return check_epilogue_late_status(epilogue->late_status);
 }
 
+bool FrameAssembler::disassemble_segments(bufferlist& preamble_bl, 
+  bufferlist segments_bls[], bufferlist& epilogue_bl) const {
+  disassemble_first_segment(preamble_bl, segments_bls[0]);
+  if (disassemble_remaining_segments(segments_bls, epilogue_bl)) {
+    if (is_compressed()) {
+      disassemble_decompress(segments_bls);
+    }
+    return true;
+  }
+
+  return false;
+}
+
 void FrameAssembler::disassemble_first_segment(bufferlist& preamble_bl,
                                                bufferlist& segment_bl) const {
   ceph_assert(!m_descs.empty());
@@ -447,15 +478,15 @@ bool FrameAssembler::disassemble_remaining_segments(
       // no epilogue if only one segment
       ceph_assert(epilogue_bl.length() == 0);
       return true;
-    }
-    if (m_crypto->rx) {
+    } else if (m_crypto->rx) {
       return disasm_remaining_secure_rev1(segment_bls, epilogue_bl);
+    } else {
+      return disasm_remaining_crc_rev1(segment_bls, epilogue_bl);
     }
-    return disasm_remaining_crc_rev1(segment_bls, epilogue_bl);
-  }
-  if (m_crypto->rx) {
+  } else if (m_crypto->rx) {
     return disasm_all_secure_rev0(segment_bls, epilogue_bl);
-  }
+  } 
+  
   return disasm_all_crc_rev0(segment_bls, epilogue_bl);
 }
 
@@ -471,8 +502,49 @@ std::ostream& operator<<(std::ostream& os, const FrameAssembler& frame_asm) {
   }
   os << "rev1=" << frame_asm.m_is_rev1
      << " rx=" << frame_asm.m_crypto->rx.get()
-     << " tx=" << frame_asm.m_crypto->tx.get();
+     << " tx=" << frame_asm.m_crypto->tx.get()
+     << " comp rx=" << frame_asm.m_compression->rx.get()
+     << " comp tx=" << frame_asm.m_compression->tx.get()
+     << " compressed=" << frame_asm.is_compressed();
   return os;
 }
 
+void FrameAssembler::asm_compress(bufferlist segment_bls[]) {
+  std::array<bufferlist, MAX_NUM_SEGMENTS> compressed;
+
+  m_compression->tx->reset_handler(m_descs.size(), get_frame_logical_len());
+
+  bool abort = false;
+  for (size_t i = 0; (i < m_descs.size()) && !abort; i++) {
+      auto out = m_compression->tx->compress(segment_bls[i]);
+      if (!out) {
+        abort = true;
+      } else {
+        compressed[i] = std::move(*out);
+      }
+  }
+
+  if (!abort) {
+    m_compression->tx->done();
+
+    for (size_t i = 0; i < m_descs.size(); i++) {
+      segment_bls[i].swap(compressed[i]);
+      m_descs[i].logical_len = segment_bls[i].length();
+    }
+
+    m_flags |= FRAME_EARLY_DATA_COMPRESSED;
+  }
+}
+
+void FrameAssembler::disassemble_decompress(bufferlist segment_bls[]) const {
+  for (size_t i = 0; i < m_descs.size(); i++) {
+    auto out = m_compression->rx->decompress(segment_bls[i]);
+    if (!out) {
+      throw FrameError("Segment decompression failed");
+    } else {
+      segment_bls[i] = std::move(*out);
+    }
+  }
+}
+
 }  // namespace ceph::msgr::v2
diff --git a/src/msg/async/frames_v2.h b/src/msg/async/frames_v2.h
index 5ce4a4fcc55..9431d6e2db3 100644
--- a/src/msg/async/frames_v2.h
+++ b/src/msg/async/frames_v2.h
@@ -4,6 +4,7 @@
 #include "include/types.h"
 #include "common/Clock.h"
 #include "crypto_onwire.h"
+#include "compression_onwire.h"
 #include <array>
 #include <iosfwd>
 #include <utility>
@@ -55,7 +56,9 @@ enum class Tag : __u8 {
   MESSAGE,
   KEEPALIVE2,
   KEEPALIVE2_ACK,
-  ACK
+  ACK,
+  COMPRESSION_REQUEST,
+  COMPRESSION_DONE
 };
 
 struct segment_t {
@@ -102,7 +105,9 @@ struct preamble_block_t {
   __u8 num_segments;
 
   segment_t segments[MAX_NUM_SEGMENTS];
-  __u8 _reserved[2];
+
+  __u8 flags;
+  __u8 _reserved;
 
   // CRC32 for this single preamble block.
   ceph_le32 crc;
@@ -169,6 +174,12 @@ static constexpr uint32_t FRAME_PREAMBLE_WITH_INLINE_SIZE =
 #define FRAME_LATE_STATUS_RESERVED_FALSE  0xe0
 #define FRAME_LATE_STATUS_RESERVED_MASK   0xf0
 
+// For msgr 2.1, FRAME_EARLY_X flags are sent as part of epilogue.
+//
+// This flag indicates whether frame segments have been compressed by 
+// sender, and used in segments' disassemblig phase. 
+#define FRAME_EARLY_DATA_COMPRESSED       0X1
+
 struct FrameError : std::runtime_error {
   using runtime_error::runtime_error;
 };
@@ -176,11 +187,14 @@ struct FrameError : std::runtime_error {
 class FrameAssembler {
 public:
   // crypto must be non-null
-  FrameAssembler(const ceph::crypto::onwire::rxtx_t* crypto, bool is_rev1)
-      : m_crypto(crypto), m_is_rev1(is_rev1) {}
+  FrameAssembler(const ceph::crypto::onwire::rxtx_t* crypto, bool is_rev1, 
+    bool with_data_crc, const ceph::compression::onwire::rxtx_t* compression)
+      : m_crypto(crypto), m_is_rev1(is_rev1), m_with_data_crc(with_data_crc),
+        m_compression(compression) {}
 
   void set_is_rev1(bool is_rev1) {
     m_descs.clear();
+    m_flags = 0;
     m_is_rev1 = is_rev1;
   }
 
@@ -299,6 +313,40 @@ public:
 
   Tag disassemble_preamble(bufferlist& preamble_bl);
 
+  bool disassemble_segments(bufferlist& preamble_bl, 
+                            bufferlist segments_bls[], 
+                            bufferlist& epilogue_bl) const;
+
+private:
+  struct segment_desc_t {
+    uint32_t logical_len;
+    uint16_t align;
+  };
+
+  uint32_t get_segment_padded_len(size_t seg_idx) const {
+    return p2roundup<uint32_t>(m_descs[seg_idx].logical_len,
+                               CRYPTO_BLOCK_SIZE);
+  }
+
+  uint32_t get_auth_tag_len() const {
+    return m_crypto->rx->get_extra_size_at_final();
+  }
+
+  bool is_compressed() const { 
+    return m_flags & FRAME_EARLY_DATA_COMPRESSED; 
+  }
+
+  void asm_compress(bufferlist segment_bls[]);
+
+  bufferlist asm_crc_rev0(const preamble_block_t& preamble,
+                          bufferlist segment_bls[]) const;
+  bufferlist asm_secure_rev0(const preamble_block_t& preamble,
+                             bufferlist segment_bls[]) const;
+  bufferlist asm_crc_rev1(const preamble_block_t& preamble,
+                          bufferlist segment_bls[]) const;
+  bufferlist asm_secure_rev1(const preamble_block_t& preamble,
+                             bufferlist segment_bls[]) const;
+
   // Like msgr1, and unlike msgr2.0, msgr2.1 allows interpreting the
   // first segment before reading in the rest of the frame.
   //
@@ -312,6 +360,7 @@ public:
   //   user-provided buffers
   // - read in epilogue
   // - call disassemble_remaining_segments()
+  // - call disasm_all_decompress()
   //
   // For msgr2.0 (set_is_rev1(false)), disassemble_first_segment() is
   // a noop.  To accomodate, disassemble_remaining_segments() always
@@ -321,6 +370,7 @@ public:
   // - read in all segments
   // - read in epilogue
   // - call disassemble_remaining_segments()
+  // - call disasm_all_decompress()
   //
   // disassemble_remaining_segments() returns true if the frame is
   // ready for dispatching, or false if it was aborted by the sender
@@ -329,30 +379,7 @@ public:
                                  bufferlist& segment_bl) const;
   bool disassemble_remaining_segments(bufferlist segment_bls[],
                                       bufferlist& epilogue_bl) const;
-
-private:
-  struct segment_desc_t {
-    uint32_t logical_len;
-    uint16_t align;
-  };
-
-  uint32_t get_segment_padded_len(size_t seg_idx) const {
-    return p2roundup<uint32_t>(m_descs[seg_idx].logical_len,
-                               CRYPTO_BLOCK_SIZE);
-  }
-
-  uint32_t get_auth_tag_len() const {
-    return m_crypto->rx->get_extra_size_at_final();
-  }
-
-  bufferlist asm_crc_rev0(const preamble_block_t& preamble,
-                          bufferlist segment_bls[]) const;
-  bufferlist asm_secure_rev0(const preamble_block_t& preamble,
-                             bufferlist segment_bls[]) const;
-  bufferlist asm_crc_rev1(const preamble_block_t& preamble,
-                          bufferlist segment_bls[]) const;
-  bufferlist asm_secure_rev1(const preamble_block_t& preamble,
-                             bufferlist segment_bls[]) const;
+  void disassemble_decompress(bufferlist segment_bls[]) const;
 
   bool disasm_all_crc_rev0(bufferlist segment_bls[],
                            bufferlist& epilogue_bl) const;
@@ -372,8 +399,11 @@ private:
                                   const FrameAssembler& frame_asm);
 
   boost::container::static_vector<segment_desc_t, MAX_NUM_SEGMENTS> m_descs;
+  __u8 m_flags;
   const ceph::crypto::onwire::rxtx_t* m_crypto;
   bool m_is_rev1;  // msgr2.1?
+  bool m_with_data_crc;
+  const ceph::compression::onwire::rxtx_t* m_compression;
 };
 
 template <class T, uint16_t... SegmentAlignmentVs>
@@ -495,14 +525,14 @@ protected:
 
 struct AuthRequestFrame : public ControlFrame<AuthRequestFrame,
                                               uint32_t, // auth method
-                                              vector<uint32_t>, // preferred modes
+                                              std::vector<uint32_t>, // preferred modes
                                               bufferlist> { // auth payload
   static const Tag tag = Tag::AUTH_REQUEST;
   using ControlFrame::Encode;
   using ControlFrame::Decode;
 
   inline uint32_t &method() { return get_val<0>(); }
-  inline vector<uint32_t> &preferred_modes() { return get_val<1>(); }
+  inline std::vector<uint32_t> &preferred_modes() { return get_val<1>(); }
   inline bufferlist &auth_payload() { return get_val<2>(); }
 
 protected:
@@ -837,6 +867,34 @@ protected:
   using Frame::Frame;
 };
 
+struct CompressionRequestFrame : public ControlFrame<CompressionRequestFrame,
+                                              bool, // is compress
+                                              std::vector<uint32_t>> { // preferred methods
+  static const Tag tag = Tag::COMPRESSION_REQUEST;
+  using ControlFrame::Encode;
+  using ControlFrame::Decode;
+
+  inline bool &is_compress() { return get_val<0>(); }
+  inline std::vector<uint32_t> &preferred_methods() { return get_val<1>(); }
+
+protected:
+  using ControlFrame::ControlFrame;
+};
+
+struct CompressionDoneFrame : public ControlFrame<CompressionDoneFrame,
+                                           bool, // is compress
+                                           uint32_t> { // method
+  static const Tag tag = Tag::COMPRESSION_DONE;
+  using ControlFrame::Encode;
+  using ControlFrame::Decode;
+
+  inline bool &is_compress() { return get_val<0>(); }
+  inline uint32_t &method() { return get_val<1>(); }
+
+protected:
+  using ControlFrame::ControlFrame;
+};
+
 } // namespace ceph::msgr::v2
 
 #endif // _MSG_ASYNC_FRAMES_V2_
diff --git a/src/msg/async/net_handler.cc b/src/msg/async/net_handler.cc
index 2b4e646d559..862c834bc8d 100644
--- a/src/msg/async/net_handler.cc
+++ b/src/msg/async/net_handler.cc
@@ -39,7 +39,7 @@ int NetHandler::create_socket(int domain, bool reuse_addr)
   int r = 0;
 
   if ((s = socket_cloexec(domain, SOCK_STREAM, 0)) == -1) {
-    r = errno;
+    r = ceph_sock_errno();
     lderr(cct) << __func__ << " couldn't create socket " << cpp_strerror(r) << dendl;
     return -r;
   }
@@ -49,11 +49,11 @@ int NetHandler::create_socket(int domain, bool reuse_addr)
    * will be able to close/open sockets a zillion of times */
   if (reuse_addr) {
     int on = 1;
-    if (::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
-      r = errno;
+    if (::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (SOCKOPT_VAL_TYPE)&on, sizeof(on)) == -1) {
+      r = ceph_sock_errno();
       lderr(cct) << __func__ << " setsockopt SO_REUSEADDR failed: "
                  << strerror(r) << dendl;
-      close(s);
+      compat_closesocket(s);
       return -r;
     }
   }
@@ -64,22 +64,32 @@ int NetHandler::create_socket(int domain, bool reuse_addr)
 
 int NetHandler::set_nonblock(int sd)
 {
-  int flags;
   int r = 0;
+#ifdef _WIN32
+  ULONG mode = 1;
+  r = ioctlsocket(sd, FIONBIO, &mode);
+  if (r) {
+    lderr(cct) << __func__ << " ioctlsocket(FIONBIO) failed: " << r
+                           << " " << WSAGetLastError() << dendl;
+    return -r;
+  }
+#else
+  int flags;
 
   /* Set the socket nonblocking.
    * Note that fcntl(2) for F_GETFL and F_SETFL can't be
    * interrupted by a signal. */
   if ((flags = fcntl(sd, F_GETFL)) < 0 ) {
-    r = errno;
+    r = ceph_sock_errno();
     lderr(cct) << __func__ << " fcntl(F_GETFL) failed: " << cpp_strerror(r) << dendl;
     return -r;
   }
   if (fcntl(sd, F_SETFL, flags | O_NONBLOCK) < 0) {
-    r = errno;
+    r = ceph_sock_errno();
     lderr(cct) << __func__ << " fcntl(F_SETFL,O_NONBLOCK): " << cpp_strerror(r) << dendl;
     return -r;
   }
+#endif
 
   return 0;
 }
@@ -90,16 +100,16 @@ int NetHandler::set_socket_options(int sd, bool nodelay, int size)
   // disable Nagle algorithm?
   if (nodelay) {
     int flag = 1;
-    r = ::setsockopt(sd, IPPROTO_TCP, TCP_NODELAY, (char*)&flag, sizeof(flag));
+    r = ::setsockopt(sd, IPPROTO_TCP, TCP_NODELAY, (SOCKOPT_VAL_TYPE)&flag, sizeof(flag));
     if (r < 0) {
-      r = errno;
+      r = ceph_sock_errno();
       ldout(cct, 0) << "couldn't set TCP_NODELAY: " << cpp_strerror(r) << dendl;
     }
   }
   if (size) {
-    r = ::setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (void*)&size, sizeof(size));
+    r = ::setsockopt(sd, SOL_SOCKET, SO_RCVBUF, (SOCKOPT_VAL_TYPE)&size, sizeof(size));
     if (r < 0)  {
-      r = errno;
+      r = ceph_sock_errno();
       ldout(cct, 0) << "couldn't set SO_RCVBUF to " << size << ": " << cpp_strerror(r) << dendl;
     }
   }
@@ -107,9 +117,9 @@ int NetHandler::set_socket_options(int sd, bool nodelay, int size)
   // block ESIGPIPE
 #ifdef CEPH_USE_SO_NOSIGPIPE
   int val = 1;
-  r = ::setsockopt(sd, SOL_SOCKET, SO_NOSIGPIPE, (void*)&val, sizeof(val));
+  r = ::setsockopt(sd, SOL_SOCKET, SO_NOSIGPIPE, (SOCKOPT_VAL_TYPE)&val, sizeof(val));
   if (r) {
-    r = errno;
+    r = ceph_sock_errno();
     ldout(cct,0) << "couldn't set SO_NOSIGPIPE: " << cpp_strerror(r) << dendl;
   }
 #endif
@@ -127,10 +137,10 @@ void NetHandler::set_priority(int sd, int prio, int domain)
   int iptos = IPTOS_CLASS_CS6;
   switch (domain) {
   case AF_INET:
-    r = ::setsockopt(sd, IPPROTO_IP, IP_TOS, &iptos, sizeof(iptos));
+    r = ::setsockopt(sd, IPPROTO_IP, IP_TOS, (SOCKOPT_VAL_TYPE)&iptos, sizeof(iptos));
     break;
   case AF_INET6:
-    r = ::setsockopt(sd, IPPROTO_IPV6, IPV6_TCLASS, &iptos, sizeof(iptos));
+    r = ::setsockopt(sd, IPPROTO_IPV6, IPV6_TCLASS, (SOCKOPT_VAL_TYPE)&iptos, sizeof(iptos));
     break;
   default:
     lderr(cct) << "couldn't set ToS of unknown family (" << domain << ")"
@@ -138,7 +148,7 @@ void NetHandler::set_priority(int sd, int prio, int domain)
     return;
   }
   if (r < 0) {
-    r = errno;
+    r = ceph_sock_errno();
     ldout(cct,0) << "couldn't set TOS to " << iptos
 		 << ": " << cpp_strerror(r) << dendl;
   }
@@ -147,9 +157,9 @@ void NetHandler::set_priority(int sd, int prio, int domain)
   // setsockopt(IPTOS_CLASS_CS6) sets the priority of the socket as 0.
   // See http://goo.gl/QWhvsD and http://goo.gl/laTbjT
   // We need to call setsockopt(SO_PRIORITY) after it.
-  r = ::setsockopt(sd, SOL_SOCKET, SO_PRIORITY, &prio, sizeof(prio));
+  r = ::setsockopt(sd, SOL_SOCKET, SO_PRIORITY, (SOCKOPT_VAL_TYPE)&prio, sizeof(prio));
   if (r < 0) {
-    r = errno;
+    r = ceph_sock_errno();
     ldout(cct, 0) << __func__ << " couldn't set SO_PRIORITY to " << prio
 		  << ": " << cpp_strerror(r) << dendl;
   }
@@ -168,7 +178,7 @@ int NetHandler::generic_connect(const entity_addr_t& addr, const entity_addr_t &
   if (nonblock) {
     ret = set_nonblock(s);
     if (ret < 0) {
-      close(s);
+      compat_closesocket(s);
       return ret;
     }
   }
@@ -181,9 +191,9 @@ int NetHandler::generic_connect(const entity_addr_t& addr, const entity_addr_t &
       addr.set_port(0);
       ret = ::bind(s, addr.get_sockaddr(), addr.get_sockaddr_len());
       if (ret < 0) {
-        ret = errno;
+        ret = ceph_sock_errno();
         ldout(cct, 2) << __func__ << " client bind error " << ", " << cpp_strerror(ret) << dendl;
-        close(s);
+        compat_closesocket(s);
         return -ret;
       }
     }
@@ -191,12 +201,13 @@ int NetHandler::generic_connect(const entity_addr_t& addr, const entity_addr_t &
 
   ret = ::connect(s, addr.get_sockaddr(), addr.get_sockaddr_len());
   if (ret < 0) {
-    ret = errno;
-    if (errno == EINPROGRESS && nonblock)
+    ret = ceph_sock_errno();
+    // Windows can return WSAEWOULDBLOCK (converted to EAGAIN).
+    if ((ret == EINPROGRESS || ret == EAGAIN) && nonblock)
       return s;
 
     ldout(cct, 10) << __func__ << " connect: " << cpp_strerror(ret) << dendl;
-    close(s);
+    compat_closesocket(s);
     return -ret;
   }
 
@@ -208,10 +219,11 @@ int NetHandler::reconnect(const entity_addr_t &addr, int sd)
   int r = 0;
   int ret = ::connect(sd, addr.get_sockaddr(), addr.get_sockaddr_len());
 
-  if (ret < 0 && errno != EISCONN) {
-    r = errno;
-    ldout(cct, 10) << __func__ << " reconnect: " << strerror(r) << dendl;
-    if (r == EINPROGRESS || r == EALREADY)
+  if (ret < 0 && ceph_sock_errno() != EISCONN) {
+    r = ceph_sock_errno();
+    ldout(cct, 10) << __func__ << " reconnect: " << r
+                   << " " << strerror(r) << dendl;
+    if (r == EINPROGRESS || r == EALREADY || r == EAGAIN)
       return 1;
     return -r;
   }
diff --git a/src/msg/async/rdma/Infiniband.cc b/src/msg/async/rdma/Infiniband.cc
index e2c06229f41..52323f948c6 100644
--- a/src/msg/async/rdma/Infiniband.cc
+++ b/src/msg/async/rdma/Infiniband.cc
@@ -579,7 +579,7 @@ int Infiniband::CompletionChannel::init()
                           << cpp_strerror(errno) << dendl;
     return -1;
   }
-  int rc = NetHandler(cct).set_nonblock(channel->fd);
+  int rc = ceph::NetHandler(cct).set_nonblock(channel->fd);
   if (rc < 0) {
     ibv_destroy_comp_channel(channel);
     return -1;
@@ -1062,7 +1062,7 @@ void Infiniband::init()
   device->binding_port(cct, port_num);
   ib_physical_port = device->active_port->get_port_num();
   pd = new ProtectionDomain(cct, device);
-  ceph_assert(NetHandler(cct).set_nonblock(device->ctxt->async_fd) == 0);
+  ceph_assert(ceph::NetHandler(cct).set_nonblock(device->ctxt->async_fd) == 0);
 
   support_srq = cct->_conf->ms_async_rdma_support_srq;
   if (support_srq) {
diff --git a/src/msg/async/rdma/Infiniband.h b/src/msg/async/rdma/Infiniband.h
index 3af89f304fe..f18442e4e69 100644
--- a/src/msg/async/rdma/Infiniband.h
+++ b/src/msg/async/rdma/Infiniband.h
@@ -251,6 +251,9 @@ class Infiniband {
         return c >= base && c < end;
       }
 
+      bool is_valid_chunk(const Chunk* c) const {
+        return c >= chunk_base && c < chunk_base + num_chunk;
+      }
       MemoryManager& manager;
       uint32_t buffer_size;
       uint32_t num_chunk = 0;
@@ -346,6 +349,7 @@ class Infiniband {
     void return_tx(std::vector<Chunk*> &chunks);
     int get_send_buffers(std::vector<Chunk*> &c, size_t bytes);
     bool is_tx_buffer(const char* c) { return send->is_my_buffer(c); }
+    bool is_valid_chunk(const Chunk* c) { return send->is_valid_chunk(c); }
     Chunk *get_tx_chunk_by_buffer(const char *c) {
       return send->get_chunk_by_buffer(c);
     }
@@ -549,7 +553,7 @@ class Infiniband {
     uint32_t     max_recv_wr;
     uint32_t     q_key;
     bool dead;
-    vector<Chunk*> recv_queue;
+    std::vector<Chunk*> recv_queue;
     ceph::mutex lock = ceph::make_mutex("queue_pair_lock");
   };
 
diff --git a/src/msg/async/rdma/RDMAConnectedSocketImpl.cc b/src/msg/async/rdma/RDMAConnectedSocketImpl.cc
index c897f94f4d5..6c79dc54f31 100644
--- a/src/msg/async/rdma/RDMAConnectedSocketImpl.cc
+++ b/src/msg/async/rdma/RDMAConnectedSocketImpl.cc
@@ -47,8 +47,8 @@ class C_handle_connection_read : public EventCallback {
 #undef dout_prefix
 #define dout_prefix *_dout << " RDMAConnectedSocketImpl "
 
-RDMAConnectedSocketImpl::RDMAConnectedSocketImpl(CephContext *cct, shared_ptr<Infiniband> &ib,
-                                                 shared_ptr<RDMADispatcher>& rdma_dispatcher,
+RDMAConnectedSocketImpl::RDMAConnectedSocketImpl(CephContext *cct, std::shared_ptr<Infiniband> &ib,
+                                                 std::shared_ptr<RDMADispatcher>& rdma_dispatcher,
                                                  RDMAWorker *w)
   : cct(cct), connected(0), error(0), ib(ib),
     dispatcher(rdma_dispatcher), worker(w),
@@ -58,6 +58,10 @@ RDMAConnectedSocketImpl::RDMAConnectedSocketImpl(CephContext *cct, shared_ptr<In
 {
   if (!cct->_conf->ms_async_rdma_cm) {
     qp = ib->create_queue_pair(cct, dispatcher->get_tx_cq(), dispatcher->get_rx_cq(), IBV_QPT_RC, NULL);
+    if (!qp) {
+      lderr(cct) << __func__ << " queue pair create failed" << dendl;
+      return;
+    }
     local_qpn = qp->get_local_qp_number();
     notify_fd = eventfd(0, EFD_CLOEXEC|EFD_NONBLOCK);
     dispatcher->register_qp(qp, this);
@@ -129,7 +133,7 @@ int RDMAConnectedSocketImpl::activate()
 int RDMAConnectedSocketImpl::try_connect(const entity_addr_t& peer_addr, const SocketOptions &opts) {
   ldout(cct, 20) << __func__ << " nonblock:" << opts.nonblock << ", nodelay:"
                  << opts.nodelay << ", rbuf_size: " << opts.rcbuf_size << dendl;
-  NetHandler net(cct);
+  ceph::NetHandler net(cct);
 
   // we construct a socket to transport ib sync message
   // but we shouldn't block in tcp connecting
@@ -337,7 +341,7 @@ ssize_t RDMAConnectedSocketImpl::read_buffers(char* buf, size_t len)
   return read_size;
 }
 
-ssize_t RDMAConnectedSocketImpl::send(bufferlist &bl, bool more)
+ssize_t RDMAConnectedSocketImpl::send(ceph::buffer::list &bl, bool more)
 {
   if (error) {
     if (!active)
@@ -440,7 +444,7 @@ ssize_t RDMAConnectedSocketImpl::submit(bool more)
   if (total_copied == 0)
     return -EAGAIN;
   ceph_assert(total_copied <= pending_bl.length());
-  bufferlist swapped;
+  ceph::buffer::list swapped;
   if (total_copied < pending_bl.length()) {
     worker->perf_logger->inc(l_msgr_rdma_tx_parital_mem);
     pending_bl.splice(total_copied, pending_bl.length() - total_copied, &swapped);
@@ -463,7 +467,7 @@ ssize_t RDMAConnectedSocketImpl::submit(bool more)
 int RDMAConnectedSocketImpl::post_work_request(std::vector<Chunk*> &tx_buffers)
 {
   ldout(cct, 20) << __func__ << " QP: " << local_qpn << " " << tx_buffers[0] << dendl;
-  vector<Chunk*>::iterator current_buffer = tx_buffers.begin();
+  auto current_buffer = tx_buffers.begin();
   ibv_sge isge[tx_buffers.size()];
   uint32_t current_sge = 0;
   ibv_send_wr iswr[tx_buffers.size()];
@@ -569,6 +573,11 @@ void RDMAConnectedSocketImpl::close()
   active = false;
 }
 
+void RDMAConnectedSocketImpl::set_priority(int sd, int prio, int domain) {
+    ceph::NetHandler net(cct);
+    net.set_priority(sd, prio, domain);
+}
+
 void RDMAConnectedSocketImpl::fault()
 {
   ldout(cct, 1) << __func__ << " tcp fd " << tcp_fd << dendl;
diff --git a/src/msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc b/src/msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc
index d55ced3c53f..606dbd2817c 100644
--- a/src/msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc
+++ b/src/msg/async/rdma/RDMAIWARPConnectedSocketImpl.cc
@@ -7,8 +7,8 @@
 #define TIMEOUT_MS 3000
 #define RETRY_COUNT 7
 
-RDMAIWARPConnectedSocketImpl::RDMAIWARPConnectedSocketImpl(CephContext *cct, shared_ptr<Infiniband>& ib,
-                                                           shared_ptr<RDMADispatcher>& rdma_dispatcher,
+RDMAIWARPConnectedSocketImpl::RDMAIWARPConnectedSocketImpl(CephContext *cct, std::shared_ptr<Infiniband>& ib,
+                                                           std::shared_ptr<RDMADispatcher>& rdma_dispatcher,
                                                            RDMAWorker *w, RDMACMInfo *info)
   : RDMAConnectedSocketImpl(cct, ib, rdma_dispatcher, w), cm_con_handler(new C_handle_cm_connection(this))
 {
diff --git a/src/msg/async/rdma/RDMAIWARPServerSocketImpl.cc b/src/msg/async/rdma/RDMAIWARPServerSocketImpl.cc
index e4a170ee8be..0500b4420f9 100644
--- a/src/msg/async/rdma/RDMAIWARPServerSocketImpl.cc
+++ b/src/msg/async/rdma/RDMAIWARPServerSocketImpl.cc
@@ -8,8 +8,8 @@
 #define dout_prefix *_dout << " RDMAIWARPServerSocketImpl "
 
 RDMAIWARPServerSocketImpl::RDMAIWARPServerSocketImpl(
-  CephContext *cct, shared_ptr<Infiniband>& ib,
-  shared_ptr<RDMADispatcher>& rdma_dispatcher, RDMAWorker *w,
+  CephContext *cct, std::shared_ptr<Infiniband>& ib,
+  std::shared_ptr<RDMADispatcher>& rdma_dispatcher, RDMAWorker *w,
   entity_addr_t& a, unsigned addr_slot)
   : RDMAServerSocketImpl(cct, ib, rdma_dispatcher, w, a, addr_slot)
 {
diff --git a/src/msg/async/rdma/RDMAServerSocketImpl.cc b/src/msg/async/rdma/RDMAServerSocketImpl.cc
index cc85832eddd..665faa9311c 100644
--- a/src/msg/async/rdma/RDMAServerSocketImpl.cc
+++ b/src/msg/async/rdma/RDMAServerSocketImpl.cc
@@ -25,8 +25,8 @@
 #define dout_prefix *_dout << " RDMAServerSocketImpl "
 
 RDMAServerSocketImpl::RDMAServerSocketImpl(
-  CephContext *cct, shared_ptr<Infiniband>& ib,
-  shared_ptr<RDMADispatcher>& rdma_dispatcher,
+  CephContext *cct, std::shared_ptr<Infiniband>& ib,
+  std::shared_ptr<RDMADispatcher>& rdma_dispatcher,
   RDMAWorker *w, entity_addr_t& a, unsigned slot)
   : ServerSocketImpl(a.get_type(), slot),
     cct(cct), net(cct), server_setup_socket(-1), ib(ib),
@@ -113,6 +113,13 @@ int RDMAServerSocketImpl::accept(ConnectedSocket *sock, const SocketOptions &opt
   RDMAConnectedSocketImpl* server;
   //Worker* w = dispatcher->get_stack()->get_worker();
   server = new RDMAConnectedSocketImpl(cct, ib, dispatcher, dynamic_cast<RDMAWorker*>(w));
+  if (!server->get_qp()) {
+    lderr(cct) << __func__ << " server->qp is null" << dendl;
+    // cann't use delete server here, destructor will fail.
+    server->cleanup();
+    ::close(sd);
+    return -1;
+  }
   server->set_accept_fd(sd);
   ldout(cct, 20) << __func__ << " accepted a new QP, tcp_fd: " << sd << dendl;
   std::unique_ptr<RDMAConnectedSocketImpl> csi(server);
diff --git a/src/msg/async/rdma/RDMAStack.cc b/src/msg/async/rdma/RDMAStack.cc
index b68aeb1a8ef..12db599d684 100644
--- a/src/msg/async/rdma/RDMAStack.cc
+++ b/src/msg/async/rdma/RDMAStack.cc
@@ -23,7 +23,6 @@
 #include "include/compat.h"
 #include "common/Cycles.h"
 #include "common/deleter.h"
-#include "common/Tub.h"
 #include "RDMAStack.h"
 
 #define dout_subsys ceph_subsys_ms
@@ -40,7 +39,7 @@ RDMADispatcher::~RDMADispatcher()
   ceph_assert(dead_queue_pairs.empty());
 }
 
-RDMADispatcher::RDMADispatcher(CephContext* c, shared_ptr<Infiniband>& ib)
+RDMADispatcher::RDMADispatcher(CephContext* c, std::shared_ptr<Infiniband>& ib)
   : cct(c), ib(ib)
 {
   PerfCountersBuilder plb(cct, "AsyncMessenger::RDMADispatcher", l_msgr_rdma_dispatcher_first, l_msgr_rdma_dispatcher_last);
@@ -178,8 +177,9 @@ void RDMADispatcher::handle_async_event()
           } else {
              conn->fault();
              if (qp) {
-                if (!cct->_conf->ms_async_rdma_cm)
-                enqueue_dead_qp(qpn);
+                if (!cct->_conf->ms_async_rdma_cm) {
+                  enqueue_dead_qp_lockless(qpn);
+                }
              }
           }
         }
@@ -413,9 +413,8 @@ Infiniband::QueuePair* RDMADispatcher::get_qp(uint32_t qp)
   return get_qp_lockless(qp);
 }
 
-void RDMADispatcher::enqueue_dead_qp(uint32_t qpn)
+void RDMADispatcher::enqueue_dead_qp_lockless(uint32_t qpn)
 {
-  std::lock_guard l{lock};
   auto it = qp_conns.find(qpn);
   if (it == qp_conns.end()) {
     lderr(cct) << __func__ << " QP [" << qpn << "] is not registered." << dendl;
@@ -427,6 +426,12 @@ void RDMADispatcher::enqueue_dead_qp(uint32_t qpn)
   --num_qp_conn;
 }
 
+void RDMADispatcher::enqueue_dead_qp(uint32_t qpn)
+{
+  std::lock_guard l{lock};
+  enqueue_dead_qp_lockless(qpn);
+}
+
 void RDMADispatcher::schedule_qp_destroy(uint32_t qpn)
 {
   std::lock_guard l{lock};
@@ -539,7 +544,7 @@ void RDMADispatcher::handle_tx_event(ibv_wc *cqe, int n)
     //TX completion may come either from
     // 1) regular send message, WCE wr_id points to chunk
     // 2) 'fin' message, wr_id points to the QP
-    if (ib->get_memory_manager()->is_tx_buffer(chunk->buffer)) {
+    if (ib->get_memory_manager()->is_valid_chunk(chunk)) {
       tx_chunks.push_back(chunk);
     } else if (reinterpret_cast<QueuePair*>(response->wr_id)->get_local_qp_number() == response->qp_num ) {
       ldout(cct, 1) << __func__ << " sending of the disconnect msg completed" << dendl;
@@ -772,18 +777,11 @@ void RDMAWorker::handle_pending_message()
   dispatcher->notify_pending_workers();
 }
 
-RDMAStack::RDMAStack(CephContext *cct, const string &t)
-  : NetworkStack(cct, t), ib(make_shared<Infiniband>(cct)),
-    rdma_dispatcher(make_shared<RDMADispatcher>(cct, ib))
+RDMAStack::RDMAStack(CephContext *cct)
+  : NetworkStack(cct), ib(std::make_shared<Infiniband>(cct)),
+    rdma_dispatcher(std::make_shared<RDMADispatcher>(cct, ib))
 {
   ldout(cct, 20) << __func__ << " constructing RDMAStack..." << dendl;
-
-  unsigned num = get_num_worker();
-  for (unsigned i = 0; i < num; ++i) {
-    RDMAWorker* w = dynamic_cast<RDMAWorker*>(get_worker(i));
-    w->set_dispatcher(rdma_dispatcher);
-    w->set_ib(ib);
-  }
   ldout(cct, 20) << " creating RDMAStack:" << this << " with dispatcher:" << rdma_dispatcher.get() << dendl;
 }
 
@@ -794,10 +792,17 @@ RDMAStack::~RDMAStack()
   }
 }
 
-void RDMAStack::spawn_worker(unsigned i, std::function<void ()> &&func)
+Worker* RDMAStack::create_worker(CephContext *c, unsigned worker_id)
+{
+  auto w = new RDMAWorker(c, worker_id);
+  w->set_dispatcher(rdma_dispatcher);
+  w->set_ib(ib);
+  return w;
+}
+
+void RDMAStack::spawn_worker(std::function<void ()> &&func)
 {
-  threads.resize(i+1);
-  threads[i] = std::thread(func);
+  threads.emplace_back(std::move(func));
 }
 
 void RDMAStack::join_worker(unsigned i)
diff --git a/src/msg/async/rdma/RDMAStack.h b/src/msg/async/rdma/RDMAStack.h
index 45a043d2e23..a36fd5fb7f9 100644
--- a/src/msg/async/rdma/RDMAStack.h
+++ b/src/msg/async/rdma/RDMAStack.h
@@ -40,7 +40,7 @@ class RDMADispatcher {
 
   std::thread t;
   CephContext *cct;
-  shared_ptr<Infiniband> ib;
+  std::shared_ptr<Infiniband> ib;
   Infiniband::CompletionQueue* tx_cq = nullptr;
   Infiniband::CompletionQueue* rx_cq = nullptr;
   Infiniband::CompletionChannel *tx_cc = nullptr, *rx_cc = nullptr;
@@ -76,12 +76,13 @@ class RDMADispatcher {
     ceph::make_mutex("RDMADispatcher::for worker pending list");
   // fixme: lockfree
   std::list<RDMAWorker*> pending_workers;
-  void enqueue_dead_qp(uint32_t qp);
+  void enqueue_dead_qp_lockless(uint32_t qp);
+  void enqueue_dead_qp(uint32_t qpn);
 
  public:
   PerfCounters *perf_logger;
 
-  explicit RDMADispatcher(CephContext* c, shared_ptr<Infiniband>& ib);
+  explicit RDMADispatcher(CephContext* c, std::shared_ptr<Infiniband>& ib);
   virtual ~RDMADispatcher();
   void handle_async_event();
 
@@ -120,10 +121,10 @@ class RDMAWorker : public Worker {
   typedef Infiniband::MemoryManager::Chunk Chunk;
   typedef Infiniband::MemoryManager MemoryManager;
   typedef std::vector<Chunk*>::iterator ChunkIter;
-  shared_ptr<Infiniband> ib;
+  std::shared_ptr<Infiniband> ib;
   EventCallbackRef tx_handler;
   std::list<RDMAConnectedSocketImpl*> pending_sent_conns;
-  shared_ptr<RDMADispatcher> dispatcher;
+  std::shared_ptr<RDMADispatcher> dispatcher;
   ceph::mutex lock = ceph::make_mutex("RDMAWorker::lock");
 
   class C_handle_cq_tx : public EventCallback {
@@ -150,8 +151,8 @@ class RDMAWorker : public Worker {
     pending_sent_conns.remove(o);
   }
   void handle_pending_message();
-  void set_dispatcher(shared_ptr<RDMADispatcher>& dispatcher) { this->dispatcher = dispatcher; }
-  void set_ib(shared_ptr<Infiniband> &ib) {this->ib = ib;}
+  void set_dispatcher(std::shared_ptr<RDMADispatcher>& dispatcher) { this->dispatcher = dispatcher; }
+  void set_ib(std::shared_ptr<Infiniband> &ib) {this->ib = ib;}
   void notify_worker() {
     center.dispatch_event_external(tx_handler);
   }
@@ -178,12 +179,12 @@ class RDMAConnectedSocketImpl : public ConnectedSocketImpl {
   uint32_t local_qpn = 0;
   int connected;
   int error;
-  shared_ptr<Infiniband> ib;
-  shared_ptr<RDMADispatcher> dispatcher;
+  std::shared_ptr<Infiniband> ib;
+  std::shared_ptr<RDMADispatcher> dispatcher;
   RDMAWorker* worker;
   std::vector<Chunk*> buffers;
   int notify_fd = -1;
-  bufferlist pending_bl;
+  ceph::buffer::list pending_bl;
 
   ceph::mutex lock = ceph::make_mutex("RDMAConnectedSocketImpl::lock");
   std::vector<ibv_wc> wc;
@@ -204,8 +205,8 @@ class RDMAConnectedSocketImpl : public ConnectedSocketImpl {
       const decltype(std::cbegin(pending_bl.buffers()))& end);
 
  public:
-  RDMAConnectedSocketImpl(CephContext *cct, shared_ptr<Infiniband>& ib,
-      shared_ptr<RDMADispatcher>& rdma_dispatcher, RDMAWorker *w);
+  RDMAConnectedSocketImpl(CephContext *cct, std::shared_ptr<Infiniband>& ib,
+			  std::shared_ptr<RDMADispatcher>& rdma_dispatcher, RDMAWorker *w);
   virtual ~RDMAConnectedSocketImpl();
 
   void pass_wc(std::vector<ibv_wc> &&v);
@@ -213,14 +214,16 @@ class RDMAConnectedSocketImpl : public ConnectedSocketImpl {
   virtual int is_connected() override { return connected; }
 
   virtual ssize_t read(char* buf, size_t len) override;
-  virtual ssize_t send(bufferlist &bl, bool more) override;
+  virtual ssize_t send(ceph::buffer::list &bl, bool more) override;
   virtual void shutdown() override;
   virtual void close() override;
   virtual int fd() const override { return notify_fd; }
+  virtual void set_priority(int sd, int prio, int domain) override;
   void fault();
   const char* get_qp_state() { return Infiniband::qp_state_string(qp->get_state()); }
   uint32_t get_peer_qpn () const { return peer_qpn; }
   uint32_t get_local_qpn () const { return local_qpn; }
+  Infiniband::QueuePair* get_qp () const { return qp; }
   ssize_t submit(bool more);
   int activate();
   void fin();
@@ -249,8 +252,9 @@ enum RDMA_CM_STATUS {
 
 class RDMAIWARPConnectedSocketImpl : public RDMAConnectedSocketImpl {
   public:
-    RDMAIWARPConnectedSocketImpl(CephContext *cct, shared_ptr<Infiniband>& ib,
-        shared_ptr<RDMADispatcher>& rdma_dispatcher, RDMAWorker *w, RDMACMInfo *info = nullptr);
+  RDMAIWARPConnectedSocketImpl(CephContext *cct, std::shared_ptr<Infiniband>& ib,
+			       std::shared_ptr<RDMADispatcher>& rdma_dispatcher,
+			       RDMAWorker *w, RDMACMInfo *info = nullptr);
     ~RDMAIWARPConnectedSocketImpl();
     virtual int try_connect(const entity_addr_t&, const SocketOptions &opt) override;
     virtual void close() override;
@@ -283,16 +287,16 @@ class RDMAIWARPConnectedSocketImpl : public RDMAConnectedSocketImpl {
 class RDMAServerSocketImpl : public ServerSocketImpl {
   protected:
     CephContext *cct;
-    NetHandler net;
+    ceph::NetHandler net;
     int server_setup_socket;
-    shared_ptr<Infiniband> ib;
-    shared_ptr<RDMADispatcher> dispatcher;
+    std::shared_ptr<Infiniband> ib;
+    std::shared_ptr<RDMADispatcher> dispatcher;
     RDMAWorker *worker;
     entity_addr_t sa;
 
  public:
-  RDMAServerSocketImpl(CephContext *cct, shared_ptr<Infiniband>& ib,
-                       shared_ptr<RDMADispatcher>& rdma_dispatcher,
+  RDMAServerSocketImpl(CephContext *cct, std::shared_ptr<Infiniband>& ib,
+                       std::shared_ptr<RDMADispatcher>& rdma_dispatcher,
 		       RDMAWorker *w, entity_addr_t& a, unsigned slot);
 
   virtual int listen(entity_addr_t &sa, const SocketOptions &opt);
@@ -304,8 +308,8 @@ class RDMAServerSocketImpl : public ServerSocketImpl {
 class RDMAIWARPServerSocketImpl : public RDMAServerSocketImpl {
   public:
     RDMAIWARPServerSocketImpl(
-      CephContext *cct, shared_ptr<Infiniband>& ib,
-      shared_ptr<RDMADispatcher>& rdma_dispatcher,
+      CephContext *cct, std::shared_ptr<Infiniband>& ib,
+      std::shared_ptr<RDMADispatcher>& rdma_dispatcher,
       RDMAWorker* w, entity_addr_t& addr, unsigned addr_slot);
     virtual int listen(entity_addr_t &sa, const SocketOptions &opt) override;
     virtual int accept(ConnectedSocket *s, const SocketOptions &opts, entity_addr_t *out, Worker *w) override;
@@ -316,19 +320,21 @@ class RDMAIWARPServerSocketImpl : public RDMAServerSocketImpl {
 };
 
 class RDMAStack : public NetworkStack {
-  vector<std::thread> threads;
+  std::vector<std::thread> threads;
   PerfCounters *perf_counter;
-  shared_ptr<Infiniband> ib;
-  shared_ptr<RDMADispatcher> rdma_dispatcher;
+  std::shared_ptr<Infiniband> ib;
+  std::shared_ptr<RDMADispatcher> rdma_dispatcher;
 
   std::atomic<bool> fork_finished = {false};
 
+  virtual Worker* create_worker(CephContext *c, unsigned worker_id) override;
+
  public:
-  explicit RDMAStack(CephContext *cct, const string &t);
+  explicit RDMAStack(CephContext *cct);
   virtual ~RDMAStack();
   virtual bool nonblock_connect_need_writable_event() const override { return false; }
 
-  virtual void spawn_worker(unsigned i, std::function<void ()> &&func) override;
+  virtual void spawn_worker(std::function<void ()> &&func) override;
   virtual void join_worker(unsigned i) override;
   virtual bool is_ready() override { return fork_finished.load(); };
   virtual void ready() override { fork_finished = true; };
diff --git a/src/msg/compressor_registry.cc b/src/msg/compressor_registry.cc
new file mode 100644
index 00000000000..80b155fbdf8
--- /dev/null
+++ b/src/msg/compressor_registry.cc
@@ -0,0 +1,126 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+
+#include "compressor_registry.h"
+#include "common/dout.h"
+
+#define dout_subsys ceph_subsys_ms
+#undef dout_prefix
+#define dout_prefix *_dout << "CompressorRegistry(" << this << ") "
+
+CompressorRegistry::CompressorRegistry(CephContext *cct)
+  : cct(cct)
+{
+  cct->_conf.add_observer(this);
+}
+
+CompressorRegistry::~CompressorRegistry()
+{
+  cct->_conf.remove_observer(this);
+}
+
+const char** CompressorRegistry::get_tracked_conf_keys() const
+{
+  static const char *keys[] = {
+    "ms_osd_compress_mode",
+    "ms_osd_compression_algorithm",
+    "ms_osd_compress_min_size",
+    "ms_compress_secure",
+    nullptr
+  };
+  return keys;
+}
+
+void CompressorRegistry::handle_conf_change(
+  const ConfigProxy& conf,
+  const std::set<std::string>& changed)
+{
+  std::scoped_lock l(lock);
+  _refresh_config();
+}
+
+std::vector<uint32_t> CompressorRegistry::_parse_method_list(const std::string& s)
+{
+  std::vector<uint32_t> methods;
+
+  for_each_substr(s, ";,= \t", [&] (auto method) {
+    ldout(cct,20) << "adding algorithm method: " << method << dendl;
+
+    auto alg_type = Compressor::get_comp_alg_type(method);
+    if (alg_type) {
+      methods.push_back(*alg_type);
+    } else {
+      ldout(cct,5) << "WARNING: unknown algorithm method " << method << dendl;
+    }
+  });
+
+  if (methods.empty()) {
+    methods.push_back(Compressor::COMP_ALG_NONE);
+  }
+  ldout(cct,20) << __func__ << " " << s << " -> " << methods << dendl;
+
+  return methods;
+}
+
+void CompressorRegistry::_refresh_config()
+{
+  auto c_mode = Compressor::get_comp_mode_type(cct->_conf.get_val<std::string>("ms_osd_compress_mode"));
+
+  if (c_mode) {
+    ms_osd_compress_mode = *c_mode;
+  } else {
+    ldout(cct,1) << __func__ << " failed to identify ms_osd_compress_mode " 
+      << ms_osd_compress_mode << dendl;
+
+    ms_osd_compress_mode = Compressor::COMP_NONE;
+  }
+
+  ms_osd_compression_methods = _parse_method_list(cct->_conf.get_val<std::string>("ms_osd_compression_algorithm"));
+  ms_osd_compress_min_size = cct->_conf.get_val<std::uint64_t>("ms_osd_compress_min_size");
+
+  ms_compress_secure = cct->_conf.get_val<bool>("ms_compress_secure");
+
+  ldout(cct,10) << __func__ << " ms_osd_compression_mode " << ms_osd_compress_mode
+    << " ms_osd_compression_methods " << ms_osd_compression_methods
+    << " ms_osd_compress_above_min_size " << ms_osd_compress_min_size
+    << " ms_compress_secure " << ms_compress_secure
+    << dendl;
+}
+
+Compressor::CompressionAlgorithm
+CompressorRegistry::pick_method(uint32_t peer_type,
+                                const std::vector<uint32_t>& preferred_methods)
+{
+  std::vector<uint32_t> allowed_methods = get_methods(peer_type);
+  auto preferred = std::find_first_of(preferred_methods.begin(),
+                                      preferred_methods.end(),
+                                      allowed_methods.begin(),
+                                      allowed_methods.end());
+  if (preferred == preferred_methods.end()) {
+    ldout(cct,1) << "failed to pick compression method from client's "
+                 << preferred_methods
+                 << " and our " << allowed_methods << dendl;
+    return Compressor::COMP_ALG_NONE;
+  } else {
+    return static_cast<Compressor::CompressionAlgorithm>(*preferred);
+  }
+}
+
+Compressor::CompressionMode
+CompressorRegistry::get_mode(uint32_t peer_type, bool is_secure)
+{
+  std::scoped_lock l(lock);
+  ldout(cct, 20) << __func__ << " peer_type " << peer_type 
+    << " is_secure " << is_secure << dendl;
+
+  if (is_secure && !ms_compress_secure) {
+    return Compressor::COMP_NONE;
+  }
+
+  switch (peer_type) {
+  case CEPH_ENTITY_TYPE_OSD:
+    return static_cast<Compressor::CompressionMode>(ms_osd_compress_mode);
+  default:
+    return Compressor::COMP_NONE;
+  }
+}
diff --git a/src/msg/compressor_registry.h b/src/msg/compressor_registry.h
new file mode 100644
index 00000000000..d6b3f6867d8
--- /dev/null
+++ b/src/msg/compressor_registry.h
@@ -0,0 +1,69 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+
+#pragma once
+
+#include <map>
+#include <vector>
+
+#include "compressor/Compressor.h"
+#include "common/ceph_mutex.h"
+#include "common/ceph_context.h"
+#include "common/config_cacher.h"
+
+class CompressorRegistry : public md_config_obs_t {
+public:
+  CompressorRegistry(CephContext *cct);
+  ~CompressorRegistry();
+
+  void refresh_config() {
+    std::scoped_lock l(lock);
+    _refresh_config();
+  }
+
+  const char** get_tracked_conf_keys() const override;
+  void handle_conf_change(const ConfigProxy& conf,
+                          const std::set<std::string>& changed) override;
+
+  TOPNSPC::Compressor::CompressionAlgorithm pick_method(uint32_t peer_type,
+					       const std::vector<uint32_t>& preferred_methods);
+
+  TOPNSPC::Compressor::CompressionMode get_mode(uint32_t peer_type, bool is_secure);
+
+  const std::vector<uint32_t> get_methods(uint32_t peer_type) { 
+    std::scoped_lock l(lock);
+    switch (peer_type) {
+      case CEPH_ENTITY_TYPE_OSD:
+        return ms_osd_compression_methods;
+      default:
+        return {};
+    }
+   }
+
+  uint64_t get_min_compression_size(uint32_t peer_type) const {
+    std::scoped_lock l(lock);
+    switch (peer_type) {
+      case CEPH_ENTITY_TYPE_OSD:
+        return ms_osd_compress_min_size;
+      default:
+        return 0;
+    }
+  }
+
+  bool get_is_compress_secure() const { 
+    std::scoped_lock l(lock);
+    return ms_compress_secure; 
+  }
+
+private:
+  CephContext *cct;
+  mutable ceph::mutex lock = ceph::make_mutex("CompressorRegistry::lock");
+
+  uint32_t ms_osd_compress_mode;
+  bool ms_compress_secure;
+  std::uint64_t ms_osd_compress_min_size;
+  std::vector<uint32_t> ms_osd_compression_methods;
+
+  void _refresh_config();
+  std::vector<uint32_t> _parse_method_list(const std::string& s);
+};
diff --git a/src/msg/msg_fmt.h b/src/msg/msg_fmt.h
new file mode 100644
index 00000000000..41c4c6af89d
--- /dev/null
+++ b/src/msg/msg_fmt.h
@@ -0,0 +1,25 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-
+// vim: ts=8 sw=2 smarttab
+#pragma once
+
+/**
+ * \file fmtlib formatters for some msg_types.h classes
+ */
+
+#include <fmt/format.h>
+
+#include "msg/msg_types.h"
+
+template <>
+struct fmt::formatter<entity_name_t> {
+  constexpr auto parse(format_parse_context& ctx) { return ctx.begin(); }
+
+  template <typename FormatContext>
+  auto format(const entity_name_t& addr, FormatContext& ctx)
+  {
+    if (addr.is_new() || addr.num() < 0) {
+      return fmt::format_to(ctx.out(), "{}.?", addr.type_str());
+    }
+    return fmt::format_to(ctx.out(), "{}.{}", addr.type_str(), addr.num());
+  }
+};
diff --git a/src/msg/msg_types.cc b/src/msg/msg_types.cc
index 068d45a4643..d4114b06e59 100644
--- a/src/msg/msg_types.cc
+++ b/src/msg/msg_types.cc
@@ -1,3 +1,5 @@
+// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*- 
+// vim: ts=8 sw=2 smarttab
 
 #include "msg_types.h"
 
@@ -6,28 +8,62 @@
 #include <string.h>
 #include <netdb.h>
 
+#include <fmt/format.h>
+
 #include "common/Formatter.h"
 
-void entity_name_t::dump(Formatter *f) const
+bool entity_name_t::parse(std::string_view s)
+{
+  const char* start = s.data();
+  if (s.find("mon.") == 0) {
+    _type = TYPE_MON;
+    start += 4;
+  } else if (s.find("osd.") == 0) {
+    _type = TYPE_OSD;
+    start += 4;
+  } else if (s.find("mds.") == 0) {
+    _type = TYPE_MDS;
+    start += 4;
+  } else if (s.find("client.") == 0) {
+    _type = TYPE_CLIENT;
+    start += 7;
+  } else if (s.find("mgr.") == 0) {
+    _type = TYPE_MGR;
+    start += 4;
+  } else {
+    return false;
+  }
+  if (isspace(*start))
+    return false;
+  char *end = nullptr;
+  _num = strtoll(start, &end, 10);
+  if (end == nullptr || end == start) {
+    return false;
+  } else {
+    return end == s.data() + s.size();
+  }
+}
+
+void entity_name_t::dump(ceph::Formatter *f) const
 {
   f->dump_string("type", type_str());
   f->dump_unsigned("num", num());
 }
 
-void entity_addr_t::dump(Formatter *f) const
+void entity_addr_t::dump(ceph::Formatter *f) const
 {
   f->dump_string("type", get_type_name(type));
   f->dump_stream("addr") << get_sockaddr();
   f->dump_unsigned("nonce", nonce);
 }
 
-void entity_inst_t::dump(Formatter *f) const
+void entity_inst_t::dump(ceph::Formatter *f) const
 {
   f->dump_object("name", name);
   f->dump_object("addr", addr);
 }
 
-void entity_name_t::generate_test_instances(list<entity_name_t*>& o)
+void entity_name_t::generate_test_instances(std::list<entity_name_t*>& o)
 {
   o.push_back(new entity_name_t(entity_name_t::MON()));
   o.push_back(new entity_name_t(entity_name_t::MON(1)));
@@ -35,7 +71,7 @@ void entity_name_t::generate_test_instances(list<entity_name_t*>& o)
   o.push_back(new entity_name_t(entity_name_t::CLIENT(1)));
 }
 
-void entity_addr_t::generate_test_instances(list<entity_addr_t*>& o)
+void entity_addr_t::generate_test_instances(std::list<entity_addr_t*>& o)
 {
   o.push_back(new entity_addr_t());
   entity_addr_t *a = new entity_addr_t();
@@ -53,7 +89,7 @@ void entity_addr_t::generate_test_instances(list<entity_addr_t*>& o)
   o.push_back(b);
 }
 
-void entity_inst_t::generate_test_instances(list<entity_inst_t*>& o)
+void entity_inst_t::generate_test_instances(std::list<entity_inst_t*>& o)
 {
   o.push_back(new entity_inst_t());
   entity_name_t name;
@@ -62,11 +98,11 @@ void entity_inst_t::generate_test_instances(list<entity_inst_t*>& o)
   o.push_back(a);
 }
 
-bool entity_addr_t::parse(const std::string_view s)
+bool entity_addr_t::parse(const std::string_view s, int default_type)
 {
   const char* start = s.data();
   const char* end = nullptr;
-  bool got = parse(start, &end);
+  bool got = parse(start, &end, default_type);
   return got && end == start + s.size();
 }
 
@@ -79,7 +115,7 @@ bool entity_addr_t::parse(const char *s, const char **end, int default_type)
     *end = s;
   }
 
-  int newtype;
+  int newtype = default_type;
   if (strncmp("v1:", s, 3) == 0) {
     start += 3;
     newtype = TYPE_LEGACY;
@@ -95,8 +131,6 @@ bool entity_addr_t::parse(const char *s, const char **end, int default_type)
       *end = s + 1;
     }
     return true;
-  } else {
-    newtype = default_type ? default_type : TYPE_DEFAULT;
   }
 
   bool brackets = false;
@@ -183,7 +217,7 @@ bool entity_addr_t::parse(const char *s, const char **end, int default_type)
   return true;
 }
 
-ostream& operator<<(ostream& out, const entity_addr_t &addr)
+std::ostream& operator<<(std::ostream& out, const entity_addr_t &addr)
 {
   if (addr.type == entity_addr_t::TYPE_NONE) {
     return out << "-";
@@ -195,7 +229,7 @@ ostream& operator<<(ostream& out, const entity_addr_t &addr)
   return out;
 }
 
-ostream& operator<<(ostream& out, const sockaddr *psa)
+std::ostream& operator<<(std::ostream& out, const sockaddr *psa)
 {
   char buf[NI_MAXHOST] = { 0 };
 
@@ -219,7 +253,7 @@ ostream& operator<<(ostream& out, const sockaddr *psa)
   }
 }
 
-ostream& operator<<(ostream& out, const sockaddr_storage &ss)
+std::ostream& operator<<(std::ostream& out, const sockaddr_storage &ss)
 {
   return out << (const sockaddr*)&ss;
 }
@@ -282,7 +316,7 @@ bool entity_addrvec_t::parse(const char *s, const char **end)
   return !v.empty();
 }
 
-void entity_addrvec_t::encode(bufferlist& bl, uint64_t features) const
+void entity_addrvec_t::encode(ceph::buffer::list& bl, uint64_t features) const
 {
   using ceph::encode;
   if ((features & CEPH_FEATURE_MSG_ADDR2) == 0) {
@@ -294,7 +328,7 @@ void entity_addrvec_t::encode(bufferlist& bl, uint64_t features) const
   encode(v, bl, features);
 }
 
-void entity_addrvec_t::decode(bufferlist::const_iterator& bl)
+void entity_addrvec_t::decode(ceph::buffer::list::const_iterator& bl)
 {
   using ceph::decode;
   __u8 marker;
@@ -337,21 +371,20 @@ void entity_addrvec_t::decode(bufferlist::const_iterator& bl)
     return;
   }
   if (marker > 2)
-    throw buffer::malformed_input("entity_addrvec_marker > 2");
+    throw ceph::buffer::malformed_input("entity_addrvec_marker > 2");
   decode(v, bl);
 }
 
-void entity_addrvec_t::dump(Formatter *f) const
+void entity_addrvec_t::dump(ceph::Formatter *f) const
 {
   f->open_array_section("addrvec");
-  for (vector<entity_addr_t>::const_iterator p = v.begin();
-       p != v.end(); ++p) {
+  for (auto p = v.begin(); p != v.end(); ++p) {
     f->dump_object("addr", *p);
   }
   f->close_section();
 }
 
-void entity_addrvec_t::generate_test_instances(list<entity_addrvec_t*>& ls)
+void entity_addrvec_t::generate_test_instances(std::list<entity_addrvec_t*>& ls)
 {
   ls.push_back(new entity_addrvec_t());
   ls.push_back(new entity_addrvec_t());
@@ -379,3 +412,12 @@ std::string entity_addr_t::ip_only_to_str() const
   }
   return host_ip ? host_ip : "";
 }
+
+std::string entity_addr_t::ip_n_port_to_str() const
+{
+  if (is_ipv6()) {
+    return fmt::format("[{}]:{}", ip_only_to_str(), get_port());
+  } else {
+    return fmt::format("{}:{}", ip_only_to_str(), get_port());
+  }
+}
diff --git a/src/msg/msg_types.h b/src/msg/msg_types.h
index db1f20720a9..8420ff83e1a 100644
--- a/src/msg/msg_types.h
+++ b/src/msg/msg_types.h
@@ -18,6 +18,10 @@
 #include <sstream>
 
 #include <netinet/in.h>
+#include <fmt/format.h>
+#if FMT_VERSION >= 90000
+#include <fmt/ostream.h>
+#endif
 
 #include "include/ceph_features.h"
 #include "include/types.h"
@@ -26,6 +30,11 @@
 
 #define MAX_PORT_NUMBER 65535
 
+#ifdef _WIN32
+// ceph_sockaddr_storage matches the Linux format.
+#define AF_INET6_LINUX 10
+#endif
+
 namespace ceph {
   class Formatter;
 }
@@ -77,42 +86,11 @@ public:
   bool is_mgr() const { return type() == TYPE_MGR; }
 
   operator ceph_entity_name() const {
-    ceph_entity_name n = { _type, init_le64(_num) };
+    ceph_entity_name n = { _type, ceph_le64(_num) };
     return n;
   }
 
-  bool parse(const std::string& s) {
-    const char *start = s.c_str();
-    char *end;
-    bool got = parse(start, &end);
-    return got && end == start + s.length();
-  }
-  bool parse(const char *start, char **end) {
-    if (strstr(start, "mon.") == start) {
-      _type = TYPE_MON;
-      start += 4;
-    } else if (strstr(start, "osd.") == start) {
-      _type = TYPE_OSD;
-      start += 4;
-    } else if (strstr(start, "mds.") == start) {
-      _type = TYPE_MDS;
-      start += 4;
-    } else if (strstr(start, "client.") == start) {
-      _type = TYPE_CLIENT;
-      start += 7;
-    } else if (strstr(start, "mgr.") == start) {
-      _type = TYPE_MGR;
-      start += 4;
-    } else {
-      return false;
-    }
-    if (isspace(*start))
-      return false;
-    _num = strtoll(start, end, 10);
-    if (*end == NULL || *end == start)
-      return false;
-    return true;
-  }
+  bool parse(std::string_view s);
 
   DENC(entity_name_t, v, p) {
     denc(v._type, p);
@@ -192,10 +170,18 @@ static inline void encode(const sockaddr_storage& a, ceph::buffer::list& bl) {
 				  (unsigned char*)(&ss + 1) - dst);
   ::memcpy(dst, src, copy_size);
   encode(ss, bl);
-#else
+#elif defined(_WIN32)
   ceph_sockaddr_storage ss{};
+  ::memcpy(&ss, &a, std::min(sizeof(ss), sizeof(a)));
+  // The Windows AF_INET6 definition doesn't match the Linux one.
+  if (a.ss_family == AF_INET6) {
+    ss.ss_family = AF_INET6_LINUX;
+  }
+  encode(ss, bl);
+#else
+  ceph_sockaddr_storage ss;
   ::memset(&ss, '\0', sizeof(ss));
-  ::memcpy(&wireaddr, &ss, std::min(sizeof(ss), sizeof(a)));
+  ::memcpy(&ss, &a, std::min(sizeof(ss), sizeof(a)));
   encode(ss, bl);
 #endif
 }
@@ -217,6 +203,13 @@ static inline void decode(sockaddr_storage& a,
   auto const copy_size = std::min((unsigned char*)(&ss + 1) - src,
 				  (unsigned char*)(&a + 1) - dst);
   ::memcpy(dst, src, copy_size);
+#elif defined(_WIN32)
+  ceph_sockaddr_storage ss{};
+  decode(ss, bl);
+  ::memcpy(&a, &ss, std::min(sizeof(ss), sizeof(a)));
+  if (a.ss_family == AF_INET6_LINUX) {
+    a.ss_family = AF_INET6;
+  }
 #else
   ceph_sockaddr_storage ss{};
   decode(ss, bl);
@@ -228,7 +221,9 @@ static inline void decode(sockaddr_storage& a,
  * an entity's network address.
  * includes a random value that prevents it from being reused.
  * thus identifies a particular process instance.
- * ipv4 for now.
+ *
+ * This also happens to work to support cidr ranges, in which
+ * case the nonce contains the netmask. It's great!
  */
 struct entity_addr_t {
   typedef enum {
@@ -236,6 +231,7 @@ struct entity_addr_t {
     TYPE_LEGACY = 1,  ///< legacy msgr1 protocol (ceph jewel and older)
     TYPE_MSGR2 = 2,   ///< msgr2 protocol (new in ceph kraken)
     TYPE_ANY = 3,  ///< ambiguous
+    TYPE_CIDR = 4,
   } type_t;
   static const type_t TYPE_DEFAULT = TYPE_MSGR2;
   static std::string_view get_type_name(int t) {
@@ -244,6 +240,7 @@ struct entity_addr_t {
     case TYPE_LEGACY: return "v1";
     case TYPE_MSGR2: return "v2";
     case TYPE_ANY: return "any";
+    case TYPE_CIDR: return "cidr";
     default: return "???";
     }
   };
@@ -276,6 +273,8 @@ struct entity_addr_t {
   bool is_legacy() const { return type == TYPE_LEGACY; }
   bool is_msgr2() const { return type == TYPE_MSGR2; }
   bool is_any() const { return type == TYPE_ANY; }
+  // this isn't a guarantee; some client addrs will match it
+  bool maybe_cidr() const { return get_port() == 0 && nonce != 0; }
 
   __u32 get_nonce() const { return nonce; }
   void set_nonce(__u32 n) { nonce = n; }
@@ -368,10 +367,8 @@ struct entity_addr_t {
     switch (u.sa.sa_family) {
     case AF_INET:
       return ntohs(u.sin.sin_port);
-      break;
     case AF_INET6:
       return ntohs(u.sin6.sin6_port);
-      break;
     }
     return 0;
   }
@@ -433,6 +430,7 @@ struct entity_addr_t {
   }
 
   std::string ip_only_to_str() const;
+  std::string ip_n_port_to_str() const;
 
   std::string get_legacy_str() const {
     std::ostringstream ss;
@@ -440,8 +438,8 @@ struct entity_addr_t {
     return ss.str();
   }
 
-  bool parse(const std::string_view s);
-  bool parse(const char *s, const char **end = 0, int type=0);
+  bool parse(const std::string_view s, int default_type=TYPE_DEFAULT);
+  bool parse(const char *s, const char **end = 0, int default_type=TYPE_DEFAULT);
 
   void decode_legacy_addr_after_marker(ceph::buffer::list::const_iterator& bl)
   {
@@ -480,7 +478,7 @@ struct entity_addr_t {
       encode(type, bl);
     } else {
       // map any -> legacy for old clients.  this is primary for the benefit
-      // of OSDMap's blacklist, but is reasonable in general since any: is
+      // of OSDMap's blocklist, but is reasonable in general since any: is
       // meaningless for pre-nautilus clients or daemons.
       auto t = type;
       if (t == TYPE_ANY) {
@@ -496,7 +494,11 @@ struct entity_addr_t {
     encode(elen, bl);
     if (elen) {
       uint16_t ss_family = u.sa.sa_family;
-
+#if defined(_WIN32)
+      if (ss_family == AF_INET6) {
+        ss_family = AF_INET6_LINUX;
+      }
+#endif
       encode(ss_family, bl);
       elen -= sizeof(u.sa.sa_family);
       bl.append(u.sa.sa_data, elen);
@@ -524,13 +526,18 @@ struct entity_addr_t {
 #endif
       uint16_t ss_family;
       if (elen < sizeof(ss_family)) {
-	throw buffer::malformed_input("elen smaller than family len");
+	throw ceph::buffer::malformed_input("elen smaller than family len");
       }
       decode(ss_family, bl);
+#if defined(_WIN32)
+      if (ss_family == AF_INET6_LINUX) {
+        ss_family = AF_INET6;
+      }
+#endif
       u.sa.sa_family = ss_family;
       elen -= sizeof(ss_family);
       if (elen > get_sockaddr_len() - sizeof(u.sa.sa_family)) {
-	throw buffer::malformed_input("elen exceeds sockaddr len");
+	throw ceph::buffer::malformed_input("elen exceeds sockaddr len");
       }
       bl.copy(elen, u.sa.sa_data);
     }
@@ -544,6 +551,9 @@ struct entity_addr_t {
 WRITE_CLASS_ENCODER_FEATURES(entity_addr_t)
 
 std::ostream& operator<<(std::ostream& out, const entity_addr_t &addr);
+#if FMT_VERSION >= 90000
+template <> struct fmt::formatter<entity_addr_t> : fmt::ostream_formatter {};
+#endif
 
 inline bool operator==(const entity_addr_t& a, const entity_addr_t& b) { return memcmp(&a, &b, sizeof(a)) == 0; }
 inline bool operator!=(const entity_addr_t& a, const entity_addr_t& b) { return memcmp(&a, &b, sizeof(a)) != 0; }
@@ -571,12 +581,7 @@ struct entity_addrvec_t {
   bool empty() const { return v.empty(); }
 
   entity_addr_t legacy_addr() const {
-    for (auto& a : v) {
-      if (a.type == entity_addr_t::TYPE_LEGACY) {
-	return a;
-      }
-    }
-    return entity_addr_t();
+    return addr_of_type(entity_addr_t::TYPE_LEGACY);
   }
   entity_addr_t as_legacy_addr() const {
     for (auto& a : v) {
@@ -606,22 +611,14 @@ struct entity_addrvec_t {
 	return a;
       }
     }
-    if (!v.empty()) {
-      return v.front();
-    }
-    return entity_addr_t();
+    return front();
   }
   std::string get_legacy_str() const {
     return legacy_or_front_addr().get_legacy_str();
   }
 
   entity_addr_t msgr2_addr() const {
-    for (auto &a : v) {
-      if (a.type == entity_addr_t::TYPE_MSGR2) {
-        return a;
-      }
-    }
-    return entity_addr_t();
+    return addr_of_type(entity_addr_t::TYPE_MSGR2);
   }
   bool has_msgr2() const {
     for (auto& a : v) {
@@ -632,6 +629,35 @@ struct entity_addrvec_t {
     return false;
   }
 
+  entity_addr_t pick_addr(uint32_t type) const {
+    entity_addr_t picked_addr;
+    switch (type) {
+    case entity_addr_t::TYPE_LEGACY:
+      [[fallthrough]];
+    case entity_addr_t::TYPE_MSGR2:
+      picked_addr = addr_of_type(type);
+      break;
+    case entity_addr_t::TYPE_ANY:
+      return front();
+    default:
+      return {};
+    }
+    if (!picked_addr.is_blank_ip()) {
+      return picked_addr;
+    } else {
+      return addr_of_type(entity_addr_t::TYPE_ANY);
+    }
+  }
+
+  entity_addr_t addr_of_type(uint32_t type) const {
+    for (auto &a : v) {
+      if (a.type == type) {
+        return a;
+      }
+    }
+    return entity_addr_t();
+  }
+
   bool parse(const char *s, const char **end = 0);
 
   void get_ports(std::set<int> *ports) const {
@@ -711,8 +737,14 @@ struct entity_addrvec_t {
   friend bool operator<(const entity_addrvec_t& l, const entity_addrvec_t& r) {
     return l.v < r.v;  // see lexicographical_compare()
   }
+  friend bool operator>(const entity_addrvec_t& l, const entity_addrvec_t& r) {
+    return l.v > r.v;  // see lexicographical_compare()
+  }
 };
 WRITE_CLASS_ENCODER_FEATURES(entity_addrvec_t);
+#if FMT_VERSION >= 90000
+template <> struct fmt::formatter<entity_addrvec_t> : fmt::ostream_formatter {};
+#endif
 
 namespace std {
 template<> struct hash<entity_addrvec_t> {
