FR004支持OP请求发送:SR002, FR001, FR003
  ... 前置准备(sclient创建)
  客户端创建集群(rados_create2), 入参:集群地址, 集群名, 用户名, 标记
    实例化日志
    注册日志观察者
    注册MGR观察者
    实例化化性能统计(计数器)
    实例化 asok, 实例化套接字钩子, 注册命令行命令
    实例化内存池
  读配置文件(可选)(rados_conf_read_file)
  解析命令行参数(可选)(rados_conf_parse_argv)
  连接集群(rados_connect)
    启动日志线程
    启动monitor客户端(MonC)
    构造OP连接Monitor(待细化)
    启动定时任务线程
    启动性能统计线程
    启动MAP订阅线程
    启动asok线程(并定端口, 监听和处理命令行)
    初始化HomeLess队列(IO无家可归(osd异常)时入该队列, flag: CEPH_OSDMAP_PAUSERD, homeless_session)
    对象初始化
      序列化的初始化(如性能统计)
      更新本地crush
      添加观察者(map订阅)
    订阅mgrmap及执行
  创建池级别IO上下文(rados_ioctx_create), 入参(集群,池名,IO上下文地址)
    根据池名在map中查询池ID
    实例化IO上下文(绑定对象, 池ID)
  -----------------------------------------------------
  1. 客户端写数据(同步写)(rados_write)
  2. 调用池IO上下文的write方法
  3. 构造对象OP
  4. 调用对象操作的write方法, 封装为对象操作
     添加数据: (1) 封装OP, 添加操作码, 比如: CEPH_OSD_OP_WRITE (2) 拷贝客户端IO
     添加OP参数: 如: 截断参数
  5. 执行对象操作
     准备可变OP(将对象操作封装为更灵活的可变OP)
       实例化可变OP, 设置回调
       在OP上初始化调试跟踪(trace)
     -------------------------------- FR从这里开始
     提交操作(发送OP)
       计算目标OSD(调用crush算法)
       检查OSD状态,是否将IO放入homeless -> op->target.paused -> _maybe_request_map -> epoch过期 -> 订阅和更新map
       拆分EC/副本请求
       OP操作序列化为RPC/BULK, 生成副本任务(依赖任务)
       发送RPC/BULK(hrpc_req_send)
  6. 业务调用trigger: 轮训/中断(等响应事件)(hrpc_trigger/epoll_wait)
      执行发送完成回调函数(如有)


FR005支持OP回复处理, 轮训/中断, 模式切换
业务调用trigger: 轮训/中断(等响应事件)(hrpc_trigger/epoll_wait)
轮训模式:
  hrpc_trrigger调用RPC公用回调, 如: hrpc_cb(const struct rpc_cb_info *cb_info), 参考: daos_rpc_cb
    tse_task_t	*task = cb_info->cci_arg -> 从参数中拿到task指针
    tse_task_complete(task, rc) -> 执行task完成 ..
      最终执行业务回调


中断模式:
单独线程
监听eq相关的fd
epoll_wait
网络回包触发fd可读
该线程从eq中拿出事件ev
解析出task -> 执行回调(参考轮训模式)





FR007engine故障场景OP发送控制, 引擎故障, backoff, map刷新, 超时检测和返回(网络层), 1, 2 homeless队列如何保证性能
参考: osd_state: up/down/in/out

AR001(原FR006支持map订阅和更新)
  MonC实例化和初始化
  构造OP连接Monitor, 完成认证
  向Monitor注册订阅(monc->sub_want, renew_subs)  // monitor通知monc
  ...
  处理Monitor发来的Map更新(MonClient::ms_dispatch)
  case 消息类型 -> 执行各自的map更新处理逻辑, 如: case CEPH_MSG_OSD_MAP -> return handle_osd_map

OSD异常
...
计算目标节点
测试目标节点连通性
  如果OSD无法访问, 判断是否将IO放入 homeless_session
...



FR009性能统计(嵌入发送流程), dump指标: ceph daemon osd.0 perf dump, 增加计数: logger->inc, 指标demo: l_osdc_linger_send | l_osdc_op_w
定义枚举(指标变量): enum -> 如: l_osdc_linger_send
对象初始化中(注册指标): void Objecter::init()
  pcb.add_u64_counter(l_osdc_linger_send, "linger_send", -> 增加计数器指标 | pcb.add_u64_avg -> 或增加均值指标
  ...
void Objecter::_send_linger
  logger->inc(l_osdc_linger_send) -> 发送心跳业务中增加该计数器 -> 或: _send_op_account 登记OP中增加计数器(l_osdc_op_w)
使用指标: ceph daemon osd.0 perf dump
重置指标






FR007 asock功能支持(嵌入发送流程)
  实例化asok, 实例化套接字钩子, 注册命令行命令
  启动asok线程(并定端口, 监听和处理命令行)



F8: 池实例创建销毁和池级别io操作
创建集群, 解析参数(可选), 连接集群
创建池(rados_pool_create(rados, pool_name)) -> rados_pool_create(*cluster, pool_name.c_str())
更新OSD_MAP
设置创池操作(POOL_OP_CREATE)
通过MonC给Monitor发送创池消息


F9: fio压测对象语义
实现fio引擎语义(ioengine_ops ioengine)
rados初始化
rados IO入队(aio和回调)
获取IO完成事件(判断当前是否还有没有处理完的io events)
统计IO完成事件
清理
打开文件(不实现)
IO初始化(io单元)
IO释放


F12: 支持op调度(tse?, 已调研, 待融合)


OP语义, OP事务(class Transaction {):
OP_WRITE -> rados_write 同步写 -> CEPH_RADOS_API int rados_write(rados_ioctx_t io, const char *oid, const char *buf, size_t len, uint64_t off)
...

aio_write -> 异步写 -> CEPH_RADOS_API int rados_aio_write(rados_ioctx_t io, const char *oid, rados_completion_t completion, const char *buf, size_t len, uint64_t off)
  ...
  Context *oncomplete = new C_aio_Complete(c)
  queue_aio_write(c)
    c->aio_write_seq = ++aio_write_seq
     aio_write_list.push_back(&c->aio_write_list_item) -> 将IO加入队列
  prepare_write_op -> CEPH_OSD_OP_WRITE
  objecter->op_submit(o, &c->tid)
  ...
  flush_aio_writes

OP_WRITEFULL -> write_full -> 异步写入整个对象 该对象填充有提供的数据。 如果该对象存在，则会自动截断该对象，然后写入。 将 write_full 排队并返回。 成功时完成的返回值为 0，失败时为负错误代码 -> CEPH_OSD_OP_WRITEFULL -> CEPH_RADOS_API int rados_aio_write_full(rados_ioctx_t io, const char *oid, rados_completion_t completion, const char *buf, size_t len)

OP_READ -> 读 -> CEPH_RADOS_API int rados_read(rados_ioctx_t io, const char *oid, char *buf, size_t len, uint64_t off)
  CEPH_OSD_OP_READ
  operate_read
    Objecter::Op *objecter_op = objecter->prepare_read_op
    objecter->op_submit(objecter_op)


OP_TRUNCATE -> 截断对象, 丢弃对象中超出指定大小的所有数据, 调整对象大小 如果这放大了对象，则新区域在逻辑上会用零填充。 如果这缩小了对象，多余的数据将被删除
  CEPH_RADOS_API int rados_trunc(rados_ioctx_t io, const char *oid, uint64_t size);
  op.truncate(size)
    add_data(CEPH_OSD_OP_TRUNCATE, off, 0, bl)
    ...
  return operate(oid, &op, NULL)



OP_ZERO -> 将对象清零, 将对象内指定的字节范围清零。 一些ObjectStore实例可能会对此进行优化以释放底层存储空间。 如果零范围超出了对象的末尾，则对象大小会扩展，就像我们正在写入一个充满零的缓冲区一样。 除非长度为 0，在这种情况下（就像 0 长度写入一样）我们不调整对象大小
CEPH_RADOS_API void rados_write_op_zero(rados_write_op_t write_op,
			                uint64_t offset,
			                uint64_t len);
  ((::ObjectOperation *)write_op)->zero(offset, len)
    add_data(CEPH_OSD_OP_ZERO
  

OP_CREATE -> 新建对象 -> CEPH_OSD_OP_CREATE, 应用场景,如:创建RBD image | cls_cxx_create
...
rbd/cls_rbd_client层：添加image到RBD目录
handle_add_image_to_directory
  op.create(true) -> 封装OP写操作
  add_op(CEPH_OSD_OP_CREATE)
  ...

CEPH_RADOS_API void rados_write_op_create(rados_write_op_t write_op,
                                          int exclusive, // 独占, 如果对象已存在，设置为 LIBRADOS_CREATE_EXCLUSIVE 或 LIBRADOS_CREATE_IDEMPOTENT 将出错
                                          const char* category);



OP_DELETE
RGWOp* RGWHandler_REST::get_op -> op_delete -> rgw语义?


OP_STAT -> CEPH_RADOS_API int rados_stat(rados_ioctx_t io, const char *o, uint64_t *psize, time_t *pmtime)
C_ObjectOperation_stat *h = new C_ObjectOperation_stat
add_op(CEPH_OSD_OP_STAT)


OP_CALL
OMAP*
OP_READ_REPAIE(新加语义)
OP_STAT_WRITE (新加语义)

